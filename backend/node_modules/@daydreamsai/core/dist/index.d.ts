import { LanguageModelV1, Schema } from 'ai';
export { LanguageModelV1, Schema } from 'ai';
import { z, ZodRawShape, ZodObject, ZodType } from 'zod';
import * as json_schema from 'json-schema';
import * as zod_to_json_schema from 'zod-to-json-schema';
export { v7 as randomUUIDv7 } from 'uuid';

/**
 * Represents a constructor function that creates an instance of type T.
 */
type Constructor<T> = new (...args: any[]) => T;
/**
 * Represents a factory function that creates an instance of type T using the container.
 */
type Factory<T> = (container: Container) => T;
/**
 * Represents any function type.
 */
type FunctionType = (...args: any[]) => any;
/**
 * Represents a dependency injection token that can be a string, symbol, constructor, or function.
 */
type Token = string | symbol | Constructor<any> | FunctionType;
/**
 * Interface for a dependency injection container.
 */
interface Container {
    /**
     * Registers a factory function for a token.
     * Each time the token is resolved, the factory will be called to create a new instance.
     *
     * @param token - The token to register
     * @param factory - The factory function that creates the instance
     * @returns The container instance for chaining
     */
    register: <T>(token: Token, factory: Factory<T>) => Container;
    /**
     * Registers a singleton factory function for a token.
     * The factory will be called only once when the token is first resolved,
     * and the same instance will be returned for subsequent resolutions.
     *
     * @param token - The token to register
     * @param factory - The factory function that creates the singleton instance
     * @returns The container instance for chaining
     */
    singleton: <T>(token: Token, factory: Factory<T>) => Container;
    /**
     * Registers a pre-created instance for a token.
     *
     * @param token - The token to register
     * @param instance - The instance to register
     * @returns The container instance for chaining
     */
    instance: <T>(token: Token, instance: T) => Container;
    /**
     * Creates an alias for an existing token.
     *
     * @param aliasToken - The alias token (must be a string or symbol)
     * @param originalToken - The original token to alias
     * @returns The container instance for chaining
     */
    alias: (aliasToken: string | symbol, originalToken: Token) => Container;
    /**
     * Resolves a token to its registered instance.
     *
     * @param token - The token to resolve
     * @returns The resolved instance
     * @throws Error if no registration is found for the token
     */
    resolve: <T>(token: Token) => T;
}
/**
 * Creates a new dependency injection container.
 *
 * @returns A new Container instance
 *
 * @example
 * ```typescript
 * const container = createContainer();
 *
 * // Register a transient dependency
 * container.register('logger', () => new Logger());
 *
 * // Register a singleton
 * container.singleton('database', (c) => new Database(c.resolve('config')));
 *
 * // Register a pre-created instance
 * container.instance('config', { connectionString: 'mongodb://localhost:27017' });
 *
 * // Create an alias
 * container.alias('db', 'database');
 *
 * // Resolve dependencies
 * const db = container.resolve<Database>('db');
 * ```
 */
declare const createContainer: () => Container;

type ServiceProvider = {
    register?: (container: Container) => void;
    boot?: (container: Container) => void | Promise<void>;
};
type ServiceManager = {
    register: (provider: ServiceProvider) => void;
    bootAll: () => Promise<void>;
    isBooted: (provider: ServiceProvider) => boolean;
    isRegistered: (provider: ServiceProvider) => boolean;
};
declare const service: (config: ServiceProvider) => ServiceProvider;
declare const createServiceManager: (container: Container) => ServiceManager;

/**
 * Base memory implementation providing storage and vector capabilities
 */
type BaseMemory = {
    /** Store for conversation memory data */
    store: MemoryStore;
    /** Store for vector embeddings and similarity search */
    vector: VectorStore;
    vectorModel?: LanguageModelV1;
    generateMemories?: boolean;
};
/**
 * Creates a new BaseMemory instance
 * @param store - Memory store implementation for conversation data
 * @param vector - Vector store implementation for embeddings
 * @param vectorModel - Vector model implementation for embeddings
 * @returns A new BaseMemory instance
 */
declare function createMemory(store: MemoryStore, vector: VectorStore, vectorModel?: LanguageModelV1): BaseMemory;
/**
 * Creates a new in-memory store for conversation data
 * @returns A MemoryStore implementation using a Map for storage
 */
declare function createMemoryStore(): MemoryStore;
/**
 * Creates a no-op vector store implementation
 * @returns A VectorStore implementation that performs no operations
 */
declare function createVectorStore(): VectorStore;

/**
 * Options for configuring a task.
 */
type TaskOptions = {
    limit?: number;
    retry?: number | boolean | ((failureCount: number, error: unknown) => boolean);
    debug?: Debugger;
    priority?: number;
    callId?: string;
    abortSignal?: AbortSignal;
};
/**
 * Context provided to a task.
 */
type TaskContext = {
    callId: string;
    debug: Debugger;
};
/**
 * A task function that takes parameters and options and returns a promise.
 */
type Task<in Params, out Result> = (params: Params, options?: TaskOptions) => Promise<Result>;
type InferTaskParams<T extends Task<any, any>> = T extends Task<infer Params, any> ? Params : unknown;
type InferTaskResult<T extends Task<any, any>> = T extends Task<any, infer Result> ? Result : unknown;
/**
 * Manages the execution of tasks with concurrency control.
 */
declare class TaskRunner {
    private queue;
    private running;
    private concurrency;
    private processing;
    /**
     * Creates a new TaskRunner instance.
     * @param concurrency - The maximum number of tasks to run concurrently.
     */
    constructor(concurrency?: number);
    /**
     * Sets the concurrency level for the task runner.
     * @param concurrency - The new concurrency level.
     */
    setConcurrency(concurrency: number): void;
    /**
     * Processes the task queue, running tasks up to the concurrency limit.
     */
    private processQueue;
    /**
     * Enqueues a task for execution.
     * @param taskFn - The function to execute as a task.
     * @param priority - The priority of the task.
     * @returns A promise that resolves when the task is completed.
     */
    enqueue<T>(taskFn: () => Promise<T>, priority?: number): Promise<T>;
    /**
     * Gets the number of active tasks.
     */
    get activeTasksCount(): number;
    /**
     * Gets the number of tasks in the queue.
     */
    get queuedTasksCount(): number;
    /**
     * Enqueues a task function for execution.
     * @param taskFn - The task function to execute
     * @param params - Parameters to pass to the task
     * @param options - Task options including priority
     * @returns A promise that resolves when the task is completed
     */
    enqueueTask<TTask extends Task<any, any>>(taskFn: TTask, params: InferTaskParams<TTask>, options?: TaskOptions): Promise<InferTaskResult<TTask>>;
}
/**
 * Creates a task function that can be executed or enqueued.
 * @param key - A unique key for the task.
 * @param fn - The function to execute as the task.
 * @param defaultOptions - Default options for the task.
 * @returns A task function that can be executed directly or enqueued.
 */
declare function task<Params, Result>(key: string, fn: (params: Params, ctx: TaskContext) => Promise<Result>, defaultOptions?: Omit<TaskOptions, "callId">): (params: Params, options?: TaskOptions) => Promise<Result>;

type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
type MaybePromise<T = any> = T | Promise<T>;
/**
 * Represents a memory configuration for storing data
 * @template Data - Type of data stored in memory
 */
type Memory<Data = any> = {
    /** Unique identifier for this memory */
    key: string;
    /** Function to initialize memory data */
    create: () => Promise<Data> | Data;
};
/**
 * Extracts the data type from a Memory type
 * @template TMemory - Memory type to extract data from
 */
type InferMemoryData<TMemory extends Memory<any>> = TMemory extends Memory<infer Data> ? Data : never;
/**
 * Represents an execution chain with experts and metadata
 */
type Chain = {
    /** Unique identifier for the chain */
    id: string;
    /** Current thinking/reasoning state */
    thinking: string;
    /** Goal or purpose of this chain */
    purpose: string;
    /** List of experts involved in the chain */
    experts: {
        name: string;
        data: string;
    }[];
};
/**
 * Interface for storing and retrieving memory data
 */
interface MemoryStore {
    /**
     * Retrieves data from memory
     * @template T - Type of data to retrieve
     * @param key - Key to lookup
     * @returns Promise resolving to data or null if not found
     */
    get<T>(key: string): Promise<T | null>;
    /**
     * Stores data in memory
     * @template T - Type of data to store
     * @param key - Key to store under
     * @param value - Data to store
     */
    set<T>(key: string, value: T): Promise<void>;
    /**
     * Removes data from memory
     * @param key - Key to remove
     */
    delete(key: string): Promise<void>;
    /**
     * Removes all data from memory
     */
    clear(): Promise<void>;
}
/**
 * Interface for storing and retrieving vector data
 */
interface VectorStore {
    /** Optional connection string for the vector store */
    connection?: string;
    /**
     * Adds or updates data in the vector store
     * @param contextId - Unique identifier for the context
     * @param data - Data to add or update
     */
    upsert(contextId: string, data: any): Promise<void>;
    /**
     * Searches the vector store for similar data
     * @param contextId - Context to search within
     * @param query - Query text to search for
     * @returns Array of matching documents
     */
    query(contextId: string, query: string): Promise<any[]>;
    /**
     * Creates a new index in the vector store
     * @param indexName - Name of the index to create
     */
    createIndex(indexName: string): Promise<void>;
    /**
     * Deletes an existing index from the vector store
     * @param indexName - Name of the index to delete
     */
    deleteIndex(indexName: string): Promise<void>;
}
/**
 * Represents the working memory state during execution
 */
interface WorkingMemory {
    /** List of input references */
    inputs: InputRef[];
    /** List of output references */
    outputs: OutputRef[];
    /** List of thought records */
    thoughts: Thought[];
    /** List of action calls */
    calls: ActionCall[];
    /** List of action results */
    results: ActionResult[];
    episodicMemory?: EpisodicMemory;
    /** Current image URL for multimodal context */
    currentImage?: URL;
    runs: RunRef[];
    steps: StepRef[];
    events: EventRef[];
}
type InferSchema<T> = T extends {
    schema?: infer S extends z.AnyZodObject;
} ? z.infer<S> : unknown;
type InferAgentContext<TAgent extends AnyAgent> = TAgent extends Agent<infer Content> ? Content : never;
type InferAgentMemory<TAgent extends AnyAgent> = InferContextMemory<InferAgentContext<TAgent>>;
/**
 * Represents an evaluator that can validate action/output results
 * @template Data - Type of data being evaluated
 * @template Context - Context type for the evaluation
 */
type Evaluator<Data = any, Context extends AgentContext<any> = AgentContext<any>, TAgent extends AnyAgent = AnyAgent> = {
    name: string;
    description?: string;
    /** Schema for the evaluation result */
    schema?: z.ZodType<any>;
    /** Custom prompt template for LLM-based evaluation */
    prompt?: string;
    /** Custom handler for evaluation logic */
    handler?: (data: Data, ctx: Context, agent: TAgent) => Promise<boolean> | boolean;
    /** Optional callback when evaluation fails */
    onFailure?: (ctx: Context, agent: TAgent) => Promise<void> | void;
};
type ActionSchema = ZodRawShape | z.AnyZodObject | Schema<any> | undefined;
type InferActionArguments<TSchema = undefined> = TSchema extends ZodRawShape ? z.infer<ZodObject<TSchema>> : TSchema extends z.AnyZodObject ? z.infer<TSchema> : TSchema extends Schema ? TSchema["_type"] : undefined;
type ActionContext<TContext extends AnyContext = AnyContext, AContext extends AnyContext = AnyContext, ActionMemory extends Memory<any> = Memory<any>> = AgentContext<TContext> & {
    actionMemory: InferMemoryData<ActionMemory>;
    agentMemory: InferContextMemory<AContext> | undefined;
    abortSignal?: AbortSignal;
};
type ActionCallContext<Schema extends ActionSchema = undefined, TContext extends AnyContext = AnyContext, AContext extends AnyContext = AnyContext, ActionMemory extends Memory<any> = Memory<any>> = ActionContext<TContext, AContext, ActionMemory> & {
    call: ActionCall<InferActionArguments<Schema>>;
} & ContextStateApi<TContext>;
type ActionHandler<Schema extends ActionSchema = undefined, Result = any, TContext extends AnyContext = AnyContext, TAgent extends AnyAgent = AnyAgent, TMemory extends Memory<any> = Memory<any>> = Schema extends undefined ? (ctx: ActionCallContext<Schema, TContext, InferAgentContext<TAgent>, TMemory>, agent: TAgent) => MaybePromise<Result> : (args: InferActionArguments<Schema>, ctx: ActionCallContext<Schema, TContext, InferAgentContext<TAgent>, TMemory>, agent: TAgent) => MaybePromise<Result>;
/**
 * Represents an action that can be executed with typed parameters
 * @template Schema - Zod schema defining parameter types
 * @template Result - Return type of the action
 * @template Context - Context type for the action execution
 */
interface Action<Schema extends ActionSchema = ActionSchema, Result = any, TError = unknown, TContext extends AnyContext = AnyContext, TAgent extends AnyAgent = AnyAgent, TMemory extends Memory<any> = Memory<any>> {
    name: string;
    description?: string;
    instructions?: string;
    schema: Schema;
    memory?: TMemory;
    install?: (agent: TAgent) => Promise<void> | void;
    enabled?: (ctx: ActionContext<TContext, InferAgentContext<TAgent>, TMemory>) => boolean;
    handler: ActionHandler<Schema, Result, TContext, TAgent, TMemory>;
    returns?: ActionSchema;
    format?: (result: ActionResult<Result>) => string | string[];
    /** Optional evaluator for this specific action */
    evaluator?: Evaluator<Result, AgentContext<TContext>, TAgent>;
    context?: TContext;
    onSuccess?: (result: ActionResult<Result>, ctx: ActionCallContext<Schema, TContext, InferAgentContext<TAgent>, TMemory>, agent: TAgent) => Promise<void> | void;
    retry?: boolean | number | ((failureCount: number, error: TError) => boolean);
    onError?: (err: TError, ctx: ActionCallContext<Schema, TContext, InferAgentContext<TAgent>, TMemory>, agent: TAgent) => Promise<void> | void;
}
type ActionCtxRef = AnyAction & {
    ctxId: string;
};
type OutputSchema = z.AnyZodObject | z.ZodString | ZodRawShape;
type InferOutputSchemaParams<Schema extends OutputSchema> = Schema extends ZodRawShape ? z.infer<ZodObject<Schema>> : Schema extends z.AnyZodObject | z.ZodString ? z.infer<Schema> : never;
type OutputRefResponse = Pick<OutputRef, "data" | "params"> & {
    processed?: boolean;
};
type OutputResponse = OutputRefResponse | OutputRefResponse[] | undefined | void;
type Output<Schema extends OutputSchema = OutputSchema, TContext extends AnyContext = AnyContext, TAgent extends AnyAgent = AnyAgent> = {
    type: string;
    description?: string;
    instructions?: string;
    required?: boolean;
    schema?: Schema;
    attributes?: OutputSchema;
    install?: (agent: TAgent) => MaybePromise<void>;
    enabled?: (ctx: AgentContext<TContext>) => boolean;
    handler?: (data: InferOutputSchemaParams<Schema>, ctx: AgentContext<TContext> & {
        outputRef: OutputRef<InferOutputSchemaParams<Schema>>;
    }, agent: TAgent) => MaybePromise<OutputResponse>;
    format?: (res: OutputResponse) => string | string[] | XMLElement;
    /** Optional evaluator for this specific output */
    evaluator?: Evaluator<OutputResponse, AgentContext<Context>, TAgent>;
    examples?: string[];
};
type AnyAction = Action<any, any, any, any, AnyAgent, any>;
type AnyActionWithContext<Ctx extends Context<any, any, any, any, any>> = Action<any, any, any, Ctx, AnyAgent, any>;
/**
 * Represents an input handler with validation and subscription capability
 * @template Schema - Zod schema for input parameters
 * @template Context - Context type for input handling
 */
type Input<Schema extends z.AnyZodObject | z.ZodString | z.ZodRawShape = z.AnyZodObject | z.ZodString | z.ZodRawShape, TContext extends AnyContext = AnyContext, TAgent extends AnyAgent = AnyAgent> = {
    type: string;
    description?: string;
    schema?: Schema;
    context?: TContext;
    install?: (agent: TAgent) => MaybePromise<void>;
    enabled?: (state: AgentContext<TContext>) => Promise<boolean> | boolean;
    handler?: (data: InferSchemaArguments<Schema>, ctx: AgentContext<TContext>, agent: TAgent) => MaybePromise<Pick<InputRef, "params" | "data">>;
    format?: (ref: InputRef<InferSchemaArguments<Schema>>) => string | string[] | XMLElement;
    subscribe?: (send: <TContext extends AnyContext>(context: TContext, args: InferSchemaArguments<TContext["schema"]>, data: InferSchemaArguments<Schema>) => MaybePromise<void>, agent: TAgent) => (() => void) | void | Promise<void | (() => void)>;
};
type RunRef = {
    id: string;
    ref: "run";
    type: string;
    data: any;
    timestamp: number;
    processed: boolean;
    stopReason?: string;
};
type StepRef = {
    id: string;
    ref: "step";
    type: string;
    step: number;
    data: {
        prompt?: string;
        response?: string;
    };
    timestamp: number;
    processed: boolean;
};
/** Reference to an input event in the system */
type InputRef<Data = any> = {
    id: string;
    ref: "input";
    type: string;
    content: any;
    data: Data;
    params?: Record<string, string>;
    timestamp: number;
    processed: boolean;
    formatted?: string | string[] | XMLElement;
};
/** Reference to an output event in the system */
type OutputRef<Data = any> = {
    id: string;
    ref: "output";
    type: string;
    params?: Record<string, string>;
    content: string;
    data: Data;
    timestamp: number;
    processed: boolean;
    formatted?: string | string[] | XMLElement;
    error?: unknown;
};
/** Represents a call to an action */
type ActionCall<Data = any> = {
    ref: "action_call";
    id: string;
    name: string;
    content: string;
    data: Data;
    timestamp: number;
    processed: boolean;
};
/** Represents the result of an action execution */
type ActionResult<Data = any> = {
    ref: "action_result";
    id: string;
    callId: string;
    name: string;
    data: Data;
    timestamp: number;
    processed: boolean;
    formatted?: string | string[] | XMLElement;
};
/** Represents a thought or reasoning step */
type Thought = {
    ref: "thought";
    id: string;
    content: string;
    timestamp: number;
    processed: boolean;
};
/** Represents a event */
type EventRef<Data = any> = {
    ref: "event";
    id: string;
    name: string;
    params?: Record<string, string>;
    data: Data;
    timestamp: number;
    processed: boolean;
    formatted?: string | string[] | XMLElement;
};
type Log = InputRef | OutputRef | Thought | ActionCall | ActionResult | EventRef;
type AnyRef = InputRef | OutputRef | Thought | ActionCall | ActionResult | EventRef | StepRef | RunRef;
/** Properties required for Chain-of-Thought execution */
type COTProps = {
    model: LanguageModelV1;
    plan: string;
    inputs: InputRef[];
    actions: Action[];
    outputs: Output[];
    logs: Log[];
};
/** Response structure from Chain-of-Thought execution */
type COTResponse = {
    plan: string[];
    actions: ActionCall[];
    outputs: OutputRef[];
    thinking: Thought[];
};
/** Represents an XML element structure */
type XMLElement = {
    tag: string;
    params?: Record<string, string>;
    children?: string | (XMLElement | string)[];
};
/** Utility type to preserve type information */
type Pretty<type> = {
    [key in keyof type]: type[key];
} & unknown;
/**
 * Extracts variable names from a template string
 * @template T - Template string type
 */
type ExtractTemplateVariables<T extends string> = T extends `${infer Start}{{${infer Var}}}${infer Rest}` ? Var | ExtractTemplateVariables<Rest> : never;
/**
 * Creates a type mapping template variables (including nested paths) to values
 * @template T - Template string type
 * @template V - Value type at the leaf (defaults to string)
 */
type TemplateVariables<T extends string, V = any> = {
    [K in ExtractTemplateVariables<T>]: any;
};
/** Represents an expert system with instructions and actions */
type Expert = {
    type: string;
    description: string;
    instructions: string;
    model?: LanguageModelV1;
    actions?: AnyAction[];
};
interface AgentContext<TContext extends AnyContext = AnyContext> {
    id: string;
    context: TContext;
    args: InferSchemaArguments<TContext["schema"]>;
    options: InferContextOptions<TContext>;
    settings: ContextSettings;
    memory: InferContextMemory<TContext>;
    workingMemory: WorkingMemory;
}
type AnyAgent = Agent<any>;
interface Handlers {
    onLogStream: (log: AnyRef, done: boolean) => void;
    onThinking: (thought: Thought) => void;
}
type Registry = {
    contexts: Map<string, AnyContext>;
    actions: Map<string, AnyAction>;
    inputs: Map<string, Input>;
    outputs: Map<string, Output>;
    extensions: Map<string, Extension>;
    prompts: Map<string, string>;
    models: Map<string, LanguageModelV1>;
};
interface AgentDef<TContext extends AnyContext = AnyContext> {
    /**
     * The memory store and vector store used by the agent.
     */
    memory: BaseMemory;
    /**
     * The current context of the agent.
     */
    context?: TContext;
    /**
     * Debugger function for the agent.
     */
    debugger: Debugger;
    /**
     * The container used by the agent.
     */
    container: Container;
    /**
     * The task runner used by the agent.
     */
    taskRunner: TaskRunner;
    /**
     * The primary language model used by the agent.
     */
    model: LanguageModelV1;
    /**
     * The reasoning model used by the agent, if any.
     */
    reasoningModel?: LanguageModelV1;
    /**
     * The vector model used by the agent, if any.
     */
    vectorModel?: LanguageModelV1;
    /**
     * A record of input configurations for the agent.
     */
    inputs: Record<string, InputConfig<any, AnyContext, Agent<TContext>>>;
    /**
     * A record of output configurations for the agent.
     */
    outputs: Record<string, Omit<Output<any, TContext, any>, "type">>;
    /**
     * A record of event schemas for the agent.
     */
    events: Record<string, z.AnyZodObject>;
    /**
     * A record of expert configurations for the agent.
     */
    experts: Record<string, ExpertConfig>;
    /**
     * An array of actions available to the agent.
     */
    actions: Action<any, any, unknown, AnyContext, Agent<TContext>, Memory<any>>[];
    /**
     * Whether to export training data for episodes
     */
    exportTrainingData?: boolean;
    /**
     * Path to save training data
     */
    trainingDataPath?: string;
}
/**
 * Represents an agent with various configurations and methods for handling contexts, inputs, outputs, and more.
 * @template Memory - The type of memory used by the agent.
 * @template TContext - The type of context used by the agent.
 */
interface Agent<TContext extends AnyContext = AnyContext> extends AgentDef<TContext> {
    registry: Registry;
    isBooted(): boolean;
    /**
     * Exports all episodes as training data
     * @param filePath Optional path to save the training data
     */
    exportAllTrainingData?: (filePath?: string) => Promise<void>;
    /**
     * Emits an event with the provided arguments.
     * @param args - Arguments to pass to the event handler.
     */
    emit: (...args: any[]) => void;
    /**
     * Runs the agent with the provided options.
     * @param opts - Options for running the agent.
     * @returns A promise that resolves to an array of logs.
     */
    run: <TContext extends AnyContext, SubContextRefs extends AnyContext[] = AnyContext[]>(opts: {
        context: TContext;
        args: InferSchemaArguments<TContext["schema"]>;
        model?: LanguageModelV1;
        contexts?: ContextRefArray<SubContextRefs>;
        outputs?: Record<string, Omit<Output<any, TContext, any>, "type">>;
        actions?: AnyAction[];
        handlers?: Partial<Handlers>;
        abortSignal?: AbortSignal;
        chain?: Log[];
    }) => Promise<AnyRef[]>;
    /**
     * Sends an input to the agent with the provided options.
     * @param opts - Options for sending input to the agent.
     * @returns A promise that resolves to an array of logs.
     */
    send: <SContext extends AnyContext, SubContextRefs extends AnyContext[] = AnyContext[]>(opts: {
        context: SContext;
        args: InferSchemaArguments<SContext["schema"]>;
        input: {
            type: string;
            data: any;
        };
        model?: LanguageModelV1;
        contexts?: ContextRefArray<SubContextRefs>;
        outputs?: Record<string, Omit<Output<any, SContext, any>, "type">>;
        actions?: AnyAction[];
        handlers?: Partial<Handlers>;
        abortSignal?: AbortSignal;
        chain?: Log[];
    }) => Promise<AnyRef[]>;
    /**
     * Evaluates the provided context.
     * @param ctx - The context to evaluate.
     * @returns A promise that resolves when evaluation is complete.
     */
    evaluator<SContext extends AnyContext>(ctx: AgentContext<SContext>): Promise<void>;
    /**
     * Starts the agent with the provided arguments.
     * @param args - Arguments to pass to the agent on start.
     * @returns A promise that resolves to the agent instance.
     */
    start(args?: InferSchemaArguments<TContext["schema"]>): Promise<this>;
    /**
     * Stops the agent.
     * @returns A promise that resolves when the agent is stopped.
     */
    stop(): Promise<void>;
    /**
     * Retrieves the contexts managed by the agent.
     * @returns A promise that resolves to an array of context objects.
     */
    getContexts(): Promise<{
        id: string;
        type: string;
        args?: any;
        settings?: ContextSettings;
    }[]>;
    /**
     * Retrieves the ID for a given context and arguments.
     * @param params - Parameters for retrieving the context ID.
     * @returns The context ID.
     */
    getContextId<TContext extends AnyContext = AnyContext>(params: {
        context: TContext;
        args: InferSchemaArguments<TContext["schema"]>;
    }): string;
    /**
     * Retrieves the state of a given context and arguments.
     * @param params - Parameters for retrieving the context state.
     * @returns A promise that resolves to the context state.
     */
    getContext<TContext extends AnyContext>(params: {
        context: TContext;
        args: InferSchemaArguments<TContext["schema"]>;
    }): Promise<ContextState<TContext>>;
    loadContext<TContext extends AnyContext>(params: {
        context: TContext;
        args: InferSchemaArguments<TContext["schema"]>;
    }): Promise<ContextState<TContext> | null>;
    saveContext(state: ContextState<AnyContext>, workingMemory?: WorkingMemory): Promise<boolean>;
    getContextById<TContext extends AnyContext>(id: string): Promise<ContextState<TContext> | null>;
    /**
     * Retrieves the working memory for a given context ID.
     * @param contextId - The ID of the context.
     * @returns A promise that resolves to the working memory.
     */
    getWorkingMemory(contextId: string): Promise<WorkingMemory>;
    deleteContext(contextId: string): Promise<void>;
    subscribeContext(contextId: string, handler: (log: AnyRef, done: boolean) => void): () => void;
}
type Debugger = (contextId: string, keys: string[], data: any) => void;
type Config<TContext extends AnyContext = AnyContext> = Partial<AgentDef<TContext>> & {
    model: Agent["model"];
    reasoningModel?: Agent["reasoningModel"];
    logger?: LogLevel;
    contexts?: AnyContext[];
    services?: ServiceProvider[];
    extensions?: Extension<TContext>[];
    /** Whether to export training data for episodes */
    exportTrainingData?: boolean;
    /** Path to save training data */
    trainingDataPath?: string;
};
/** Configuration type for inputs without type field */
type InputConfig<Schema extends z.AnyZodObject | z.ZodString | z.ZodRawShape = z.AnyZodObject | z.ZodString | z.ZodRawShape, TContext extends AnyContext = AnyContext, TAgent extends AnyAgent = AnyAgent> = Omit<Input<Schema, TContext, TAgent>, "type">;
/** Configuration type for outputs without type field */
type OutputConfig<Schema extends OutputSchema = OutputSchema, TContext extends AnyContext = AnyContext, TAgent extends AnyAgent = AnyAgent> = Omit<Output<Schema, TContext, TAgent>, "type">;
/** Configuration type for experts without type field */
type ExpertConfig = Omit<Expert, "type">;
/** Function type for subscription cleanup */
type Subscription = () => void;
/** Enum defining available log levels */
declare enum LogLevel {
    ERROR = 0,
    WARN = 1,
    INFO = 2,
    DEBUG = 3,
    TRACE = 4
}
/** Interface for custom log writers */
interface LogWriter {
    init(logPath: string): void;
    write(data: string): void;
}
/** Configuration options for logging */
interface LoggerConfig {
    level: LogLevel;
    enableTimestamp?: boolean;
    enableColors?: boolean;
    logToFile?: boolean;
    logPath?: string;
    logWriter?: LogWriter;
}
/** Structure of a log entry */
interface LogEntry {
    level: LogLevel;
    timestamp: Date;
    context: string;
    message: string;
    data?: any;
}
/** Results from a research operation */
interface ResearchResult {
    learnings: string[];
    visitedUrls: string[];
}
/** Configuration for research operations */
interface ResearchConfig {
    query: string;
    breadth: number;
    depth: number;
    learnings?: string[];
    visitedUrls?: string[];
}
interface IChain {
    /**
     * A unique identifier for the chain (e.g., "starknet", "ethereum", "solana", etc.)
     */
    chainId: string;
    /**
     * Read (call) a contract or perform a query on this chain.
     * The `call` parameter can be chain-specific data.
     */
    read(call: unknown): Promise<any>;
    /**
     * Write (execute a transaction) on this chain, typically requiring signatures, etc.
     */
    write(call: unknown): Promise<any>;
}
/** Type representing instructions that can be either a single string or array of strings */
type Instruction = string | string[];
/** Type representing any Context with generic type parameters */
type AnyContext = Context<any, any, any, any, any>;
/**
 * Extracts the Memory type from a Context type
 * @template TContext - The Context type to extract Memory from
 */
type InferContextMemory<TContext extends AnyContext> = TContext extends Context<infer TMemory, any, any, any, any> ? TMemory : never;
/**
 * Extracts the Context type from a Context type
 * @template TContext - The Context type to extract Ctx from
 */
type InferContextOptions<TContext extends AnyContext> = TContext extends Context<any, any, infer Options, any, any> ? Options : never;
/**
 * Configuration for a context that manages state and behavior
 * @template Memory - Type of memory for this context
 * @template Args - Zod schema type for context arguments
 * @template Ctx - Type of context data
 * @template Exports - Type of exported data
 */
type InferSchemaArguments<Schema extends z.ZodTypeAny | ZodRawShape | undefined = z.ZodTypeAny> = Schema extends ZodRawShape ? z.infer<ZodObject<Schema>> : Schema extends z.ZodTypeAny ? z.infer<Schema> : never;
interface ContextConfigApi<TMemory = any, Schema extends z.ZodTypeAny | ZodRawShape = z.ZodTypeAny, Ctx = any, Actions extends AnyAction[] = AnyAction[], Events extends Record<string, z.ZodTypeAny | ZodRawShape> = Record<string, z.ZodTypeAny | ZodRawShape>> {
    setActions<TActions extends AnyActionWithContext<Context<TMemory, Schema, Ctx, any, Events>>[]>(actions: TActions): Context<TMemory, Schema, Ctx, TActions, Events>;
    setInputs<TSchemas extends Record<string, z.AnyZodObject | z.ZodString | z.ZodRawShape>>(inputs: {
        [K in keyof TSchemas]: InputConfig<TSchemas[K], Context<TMemory, Schema, Ctx, Actions, Events>, AnyAgent>;
    }): Context<TMemory, Schema, Ctx, Actions, Events>;
    setOutputs<TSchemas extends Record<string, z.AnyZodObject | z.ZodString | z.ZodRawShape>>(outputs: {
        [K in keyof TSchemas]: Output<TSchemas[K], Context<TMemory, Schema, Ctx, Actions, Events>, AnyAgent>;
    }): Context<TMemory, Schema, Ctx, Actions, Events>;
}
type EventDef<Schema extends z.ZodTypeAny | ZodRawShape = z.ZodTypeAny> = {
    name: string;
    schema: Schema;
};
type ContextsEventsRecord<T extends Record<string, EventDef>> = {
    [K in keyof T]: T[K]["schema"];
};
type ContextConfig<TMemory = any, Args extends z.ZodTypeAny | ZodRawShape = any, Ctx = any, Actions extends AnyAction[] = AnyAction[], Events extends Record<string, z.ZodTypeAny | z.ZodRawShape> = Record<string, z.ZodTypeAny | z.ZodRawShape>> = Optional<Omit<Context<TMemory, Args, Ctx, Actions, Events>, keyof ContextConfigApi>, "actions" | "events" | "inputs" | "outputs">;
interface Context<TMemory = any, Schema extends z.ZodTypeAny | ZodRawShape = z.ZodTypeAny, Ctx = any, Actions extends AnyAction[] = AnyAction[], Events extends Record<string, z.ZodTypeAny | ZodRawShape> = Record<string, z.ZodTypeAny | ZodRawShape>> extends ContextConfigApi<TMemory, Schema, Ctx, Actions, Events> {
    /** Unique type identifier for this context */
    type: string;
    /** Zod schema for validating context arguments */
    schema: Schema;
    /** Function to generate a unique key from context arguments */
    key?: (args: InferSchemaArguments<Schema>) => string;
    /** Setup function to initialize context data */
    setup?: (args: InferSchemaArguments<Schema>, settings: ContextSettings, agent: AnyAgent) => Promise<Ctx> | Ctx;
    /** Optional function to create new memory for this context */
    create?: (params: {
        id: string;
        key: string;
        args: InferSchemaArguments<Schema>;
        options: Ctx;
        settings: ContextSettings;
    }, agent: AnyAgent) => TMemory | Promise<TMemory>;
    /** Optional instructions for this context */
    instructions?: Instruction | ((state: ContextState<this>) => Instruction);
    /** Optional description of this context */
    description?: string | string[] | ((state: ContextState<this>) => string | string[]);
    /** Optional function to load existing memory */
    load?: (state: Omit<ContextState<this>, "memory">) => Promise<TMemory>;
    /** Optional function to save memory state */
    save?: (state: ContextState<this>) => Promise<void>;
    /** Optional function to render memory state */
    render?: (state: ContextState<this>) => string | string[] | XMLElement | XMLElement[] | (string | XMLElement)[];
    model?: LanguageModelV1;
    onRun?: (ctx: AgentContext<this>, agent: AnyAgent) => Promise<void>;
    onStep?: (ctx: AgentContext<this>, agent: AnyAgent) => Promise<void>;
    shouldContinue?: (ctx: AgentContext<this>) => boolean;
    onError?: (error: unknown, ctx: AgentContext<this>, agent: AnyAgent) => Promise<void>;
    loader?: (state: ContextState<this>, agent: AnyAgent) => Promise<void>;
    maxSteps?: number;
    maxWorkingMemorySize?: number;
    actions: Actions | ((state: ContextState<this>) => Actions | Promise<Actions>);
    events: Events;
    /**
     * A record of input configurations for the context.
     */
    inputs: Record<string, InputConfig<any, any, AnyAgent>>;
    /**
     * A record of output configurations for the context.
     */
    outputs: Record<string, Omit<Output<any, AnyContext, any>, "type">>;
}
type ContextSettings = {
    model?: LanguageModelV1;
    maxSteps?: number;
    maxWorkingMemorySize?: number;
};
type ContextRef<TContext extends AnyContext = AnyContext> = {
    context: TContext;
    args: InferSchemaArguments<TContext["schema"]>;
};
type ContextsRefRecord<T extends Record<string, AnyContext>> = {
    [K in keyof T]: ContextRef<T[K]>;
};
type ContextRefArray<T extends Context<any>[]> = {
    [K in keyof T]: ContextRef<T[K]>;
};
type InferContextEvents<TContext extends AnyContext> = TContext extends Context<any, any, any, any, infer Events> ? Events : never;
type ContextEventEmitter<TContext extends AnyContext> = <T extends keyof InferContextEvents<TContext>>(event: T, args: InferSchema<InferContextEvents<TContext>[T]>, options?: {
    processed?: boolean;
}) => void;
type ContextStateApi<TContext extends AnyContext> = {
    emit: ContextEventEmitter<TContext>;
    push: (log: Log) => void;
};
type ContextState<TContext extends AnyContext = AnyContext> = {
    id: string;
    key: string;
    context: TContext;
    args: InferSchemaArguments<TContext["schema"]>;
    options: InferContextOptions<TContext>;
    memory: InferContextMemory<TContext>;
    settings: ContextSettings;
    contexts: string[];
};
type Extension<TContext extends AnyContext = AnyContext, Contexts extends Record<string, AnyContext> = Record<string, AnyContext>, Inputs extends Record<string, InputConfig<any, any>> = Record<string, InputConfig<any, any>>> = Pick<Config<TContext>, "inputs" | "outputs" | "actions" | "services" | "events"> & {
    name: string;
    install?: (agent: AnyAgent) => Promise<void> | void;
    contexts?: Contexts;
    inputs: Inputs;
};
interface Episode {
    id: string;
    timestamp: number;
    observation: string;
    result: string;
    thoughts: string;
    metadata?: {
        success?: boolean;
        tags?: string[];
        [key: string]: any;
    };
}
interface EpisodicMemory {
    episodes: Episode[];
    index?: number;
}

declare function createDreams<TContext extends AnyContext = AnyContext>(config: Config<TContext>): Agent<TContext>;

/**
 * Creates an input configuration
 * @template Schema - Zod schema type for input validation
 * @template Context - Context type for input handling
 * @param config - Input configuration object
 * @returns Typed input configuration
 */
declare function input<Schema extends z.AnyZodObject | z.ZodString | z.ZodRawShape = z.ZodString, TContext extends AnyContext = AnyContext, TAgent extends AnyAgent = AnyAgent>(config: InputConfig<Schema, TContext, TAgent>): InputConfig<Schema, TContext, TAgent>;
/**
 * Creates an action configuration
 * @template Schema - Zod schema type for action parameters
 * @template Result - Return type of the action
 * @template Context - Context type for action execution
 * @param action - Action configuration object
 * @returns Typed action configuration
 */
declare function action<TSchema extends ActionSchema = undefined, Result = any, TError = any, TContext extends AnyContext = AnyContext, TAgent extends AnyAgent = AnyAgent, TMemory extends Memory<any> = Memory<any>>(action: Optional<Action<TSchema, Result, TError, TContext, TAgent, TMemory>, "schema">): Action<TSchema, Result, TError, TContext, TAgent, TMemory>;
/**
 * Creates an output configuration
 * @template Schema - Zod schema type for output validation
 * @template Context - Context type for output handling
 * @param config - Output configuration object
 * @returns Typed output configuration
 */
declare function output<Schema extends OutputSchema = OutputSchema, Context extends AnyContext = AnyContext>(config: OutputConfig<Schema, Context>): OutputConfig<Schema, Context>;
/**
 * Creates an expert configuration
 * @template Context - Context type for expert execution
 * @param config - Expert configuration object
 * @returns Typed expert configuration
 */
declare function expert(config: ExpertConfig): ExpertConfig;
/**
 * Options for text chunking
 */
type ChunkOptions = {
    maxChunkSize: number;
};
/**
 * Splits text into chunks based on maximum chunk size
 * @param text - The text to split into chunks
 * @param options - Chunking options including maximum chunk size
 * @returns Array of text chunks
 */
declare function splitTextIntoChunks(text: string, options: ChunkOptions): string[];
/**
 * Creates a memory configuration
 * @template Data - Type of data stored in memory
 * @param memory - Memory configuration object
 * @returns Typed memory configuration
 */
declare function memory<Data = any>(memory: Memory<Data>): Memory<Data>;
declare function extension<Contexts extends Record<string, AnyContext> = Record<string, AnyContext>, Inputs extends Record<string, InputConfig<any, any>> = Record<string, InputConfig<any, any>>>(config: Optional<Extension<AnyContext, Contexts, Inputs>, "inputs">): Extension<AnyContext, Contexts, Inputs>;
/**
 * Validates environment variables against a Zod schema
 * @param schema The Zod schema to validate against
 * @param env The environment object to validate (defaults to process.env)
 * @returns The validated environment variables
 */
declare function validateEnv<T extends z.ZodTypeAny>(schema: T, env?: NodeJS.ProcessEnv): z.infer<T>;
type TrimWorkingMemoryOptions = {
    thoughts: number;
    inputs: number;
    outputs: number;
    actions: number;
};
declare function trimWorkingMemory(workingMemory: WorkingMemory, options?: TrimWorkingMemoryOptions): void;
/**
 * Utility function to safely execute a function asynchronously
 * This is an implementation of the Promise.try pattern which isn't available in standard JS
 * @param fn The function to execute
 * @param ...args The arguments to pass to the function
 * @returns A promise that resolves with the result of the function
 */
declare function tryAsync<T>(fn: Function, ...args: any[]): Promise<T>;

/**
 * Creates a regular expression to match XML tags with a specific name
 * @param tagName - The name of the XML tag to match
 * @returns RegExp that matches the specified XML tag and captures its attributes and content
 */
declare function createTagRegex(tagName: string): RegExp;
declare function createTagParser<T = string>(tagName: string, contentParser?: (content: any) => T): (content: string) => {
    tag: string;
    params: Record<string, string>;
    content: T extends string ? string : T;
}[];
type TextNode = {
    type: "text";
    content: string;
    parent?: Node;
    children?: never;
};
type ElementNode<Attributes extends Record<string, string> = Record<string, any>> = {
    type: "element";
    name: string;
    attributes: Attributes;
    content: string;
    parent?: Node;
    children?: Node[];
    closed?: true;
};
type Node = TextNode | ElementNode;
type NodeVisitor = (node: Node, parse: () => Node[]) => Node;
declare function parseAttributes(text: string): Record<string, string>;
declare function parse(text: string, visitor: NodeVisitor, depth?: number, parent?: Node | undefined): Node[];
declare function isElement(node: Node): node is ElementNode;
declare function isText(node: Node): node is TextNode;
type StartTag = {
    type: "start";
    name: string;
    attributes: Record<string, string>;
};
type EndTag = {
    type: "end";
    name: string;
};
type TextContent = {
    type: "text";
    content: string;
};
type SelfClosingTag = {
    type: "self-closing";
    name: string;
    attributes: Record<string, string>;
};
type XMLToken = StartTag | EndTag | TextContent | SelfClosingTag;
declare function xmlStreamParser(parseTags: Set<string>, shouldParse: (tagName: string, isClosingTag: boolean) => boolean): Generator<XMLToken | void, void, string>;

declare class Logger {
    private config;
    private logWriter?;
    constructor(config: LoggerConfig);
    error(context: string, message: string, data?: any): void;
    warn(context: string, message: string, data?: any): void;
    info(context: string, message: string, data?: any): void;
    debug(context: string, message: string, data?: any): void;
    trace(context: string, message: string, data?: any): void;
    private log;
    private formatLogEntry;
    private colorize;
    private initLogFile;
    private writeToFile;
}

declare function xml(tag: string, params?: Record<string, any>, children?: string | XMLElement[] | any): XMLElement;
/**
 * Formats an XML element into a string representation
 * @param tag - The XML tag name
 * @param params - Optional parameters/attributes for the XML tag
 * @param content - The content of the XML element (string or nested elements)
 * @returns Formatted XML string
 */
declare function formatXml(el: XMLElement): string;
/**
 * Formats an input reference into XML format
 * @param input - The input reference to format
 * @returns XML string representation of the input
 */
declare function formatInput(input: InputRef): XMLElement;
/**
 * Formats an output reference into XML format
 * @param output - The output reference to format
 * @returns XML string representation of the output
 */
declare function formatOutput(output: OutputRef): XMLElement;
declare function formatSchema(schema: any, key?: string): json_schema.JSONSchema7 | {
    title?: string;
    default?: any;
    description?: string;
    markdownDescription?: string;
};
/**
 * Formats an output interface definition into XML format
 * @param output - The output interface to format
 * @returns XML string representation of the output interface
 */
declare function formatOutputInterface(output: Output<any>): XMLElement;
declare function formatAction(action: AnyAction): XMLElement;
declare function formatContextState(state: ContextState): XMLElement;
type Msg = {
    role: "user";
    user: string;
    content: string;
} | {
    role: "assistant";
    content: string;
};
declare function formatMsg(msg: Msg): XMLElement;
declare function formatContextLog(i: Log): string | string[] | XMLElement;
declare function formatContextLog2(i: Log): XMLElement;
/**
 * Formats a value for template rendering
 * @param value - The value to format
 * @returns Formatted string representation of the value
 */
declare function formatValue(value: any): string;
/**
 * Renders a template string by replacing variables with provided values
 * @template Template - The template string type containing variables in {{var}} format
 * @param str - The template string to render
 * @param data - Object containing values for template variables
 * @returns The rendered string with variables replaced
 */
declare function render<Template extends string>(str: Template, data: TemplateVariables<Template>): string;

type Formatter<Variables extends Record<string, any> = Record<string, any>, Data = any> = (data: Data) => Record<keyof Variables, any>;
type InferFormatter<TPrompt extends AnyPrompt> = TPrompt extends Prompt<infer Data, infer Variables> ? Formatter<Variables, Data> : never;
type PromptVisitor<Output = any, Attributes extends Record<string, any> = Record<string, any>> = (output: Output, node: ElementNode<Attributes>, parse: () => Node[]) => void;
type GetVisitors<Output = any, T extends Record<string, Record<string, any>> = Record<string, Record<string, any>>> = {
    [K in keyof T]?: PromptVisitor<Output, T[K]>;
} & {
    [key: string]: PromptVisitor<Output, any>;
};
type Prompt<Data = any, Variables extends Record<string, any> = Record<string, any>> = <TData extends Data>(data: TData, formatter?: Formatter<Variables, TData>) => string;
type AnyPrompt = Prompt<any, any>;
type InferPromptVariables<TPrompt extends AnyPrompt> = TPrompt extends Prompt<any, infer Vars> ? Vars : never;
type InferPromptData<TPrompt extends AnyPrompt> = TPrompt extends Prompt<infer Data> ? Data : never;
type GeneratePromptConfig<TPrompt extends AnyPrompt | string = any, Variables extends Record<string, any> = any, Data = Record<string, any>, TFormatter extends Formatter<Variables, Data> = Formatter<Variables, Data>> = {
    template: TPrompt;
    variables: Variables;
    data: Data;
    formatter?: TFormatter;
};
type InferGeneratePromptConfig<TPrompt extends AnyPrompt | string> = (TPrompt extends Prompt<infer Data, infer Variables> ? GeneratePromptConfig<TPrompt, Variables, Data> : never) | (TPrompt extends string ? GeneratePromptConfig<TPrompt, TemplateVariables<TPrompt>> : never);
type InferPromptComponents<TPrompt extends AnyPrompt | string> = TPrompt extends Prompt<any, infer Components> ? Components : never;
declare function getZodJsonSchema(schema: ZodType<any>): zod_to_json_schema.JsonSchema7Type;
declare function createPrompt<Template extends string = string, Variables extends TemplateVariables<Template> = TemplateVariables<Template>, Data extends Record<string, any> = Record<string, any>>(prompt: Template, formatter?: Formatter<Variables, Data>): Prompt<Data, Variables>;
type Parser<Output> = (content: string) => Output;
declare function createParser<Output = any, Components extends Record<string, Record<string, any>> = Record<string, Record<string, any>>, Visitors extends GetVisitors<Output, Components> = GetVisitors<Output, Components>>(getOutput: () => Output, visitors: Visitors): Parser<Output>;

/**
 * Creates a context configuration
 * @template Memory - Type of working memory
 * @template Args - Zod schema type for context arguments
 * @template Ctx - Type of context data
 * @template Exports - Type of exported data
 * @param ctx - Context configuration object
 * @returns Typed context configuration
 */
declare function context<TMemory = any, Args extends z.ZodTypeAny | ZodRawShape = any, Ctx = any, Actions extends AnyAction[] = AnyAction[], Events extends Record<string, z.ZodTypeAny | z.ZodRawShape> = Record<string, z.ZodTypeAny | z.ZodRawShape>>(config: ContextConfig<TMemory, Args, Ctx, Actions, Events>): Context<TMemory, Args, Ctx, Actions, Events>;
/**
 * Retrieves and sorts working memory logs
 * @param memory - Working memory object
 * @param includeThoughts - Whether to include thought logs (default: true)
 * @returns Sorted array of memory logs
 */
declare function getWorkingMemoryLogs(memory: Partial<WorkingMemory>, includeThoughts?: boolean): Log[];
declare function getWorkingMemoryAllLogs(memory: Partial<WorkingMemory>, includeThoughts?: boolean): AnyRef[];
declare function formatWorkingMemory({ memory, processed, size, }: {
    memory: Partial<WorkingMemory>;
    processed: boolean;
    size?: number;
}): (string | XMLElement)[];
/**
 * Creates a default working memory object
 * @returns Empty working memory with initialized arrays
 */
declare function createWorkingMemory(): WorkingMemory;
declare function pushToWorkingMemory(workingMemory: WorkingMemory, ref: Log): void;
/**
 * Default working memory config
 * Provides a memory container with standard working memory structure
 */
declare const defaultWorkingMemory: Memory<WorkingMemory>;
declare function getContextId<TContext extends AnyContext>(context: TContext, args: z.infer<TContext["schema"]>): string;
declare function createContextState<TContext extends AnyContext>({ agent, context, args, contexts, settings: initialSettings, }: {
    agent: AnyAgent;
    context: TContext;
    args: InferSchemaArguments<TContext["schema"]>;
    contexts?: string[];
    settings?: ContextSettings;
}): Promise<ContextState<TContext>>;
declare function getContextWorkingMemory(agent: AnyAgent, contextId: string): Promise<WorkingMemory>;
declare function saveContextWorkingMemory(agent: AnyAgent, contextId: string, workingMemory: WorkingMemory): Promise<void>;
declare function saveContextState(agent: AnyAgent, state: ContextState): Promise<void>;
declare function loadContextState(agent: AnyAgent, context: AnyContext, contextId: string): Promise<Omit<ContextState, "options" | "memory"> | null>;
declare function saveContextsIndex(agent: AnyAgent, contextIds: Set<string>): Promise<void>;
declare function getContexts(contextIds: Set<string>, contexts: Map<string, ContextState>): ({
    id: string;
    type: string;
    key: string;
    args: any;
    settings: ContextSettings;
} | {
    id: string;
    type: string;
    key: string;
    args?: undefined;
    settings?: undefined;
})[];
declare function deleteContext(agent: AnyAgent, contextId: string): Promise<void>;

declare class NotFoundError extends Error {
    ref: ActionCall | OutputRef | InputRef;
    constructor(ref: ActionCall | OutputRef | InputRef);
}
declare class ParsingError extends Error {
    ref: ActionCall | OutputRef | InputRef;
    parsingError: unknown;
    constructor(ref: ActionCall | OutputRef | InputRef, parsingError: unknown);
}
interface TemplateInfo {
    path: (string | number)[];
    template_string: string;
    expression: string;
    primary_key: string | null;
}
declare function getPathSegments(pathString: string): string[];
declare function resolvePathSegments<T = any>(source: any, segments: string[]): T | undefined;
/**
 * Native implementation to safely get a nested value from an object/array
 * using a string path like 'a.b[0].c'.
 */
declare function getValueByPath(source: any, pathString: string): any;
/**
 * Resolves detected templates in an arguments object using provided data sources.
 * Modifies the input object directly. Uses native helper functions.
 */
declare function resolveTemplates(argsObject: any, // The object containing templates (will be mutated)
detectedTemplates: TemplateInfo[], resolver: (primary_key: string, path: string) => Promise<any>): Promise<void>;
declare function prepareActionCall({ call, actions, logger, }: {
    call: ActionCall;
    actions: ActionCtxRef[];
    logger: Logger;
}): Promise<{
    action: ActionCtxRef;
    json: any;
    templates: TemplateInfo[];
}>;
declare function handleActionCall({ state, workingMemory, action, logger, call, taskRunner, agent, agentState, abortSignal, pushLog, }: {
    state: ContextState<AnyContext>;
    workingMemory: WorkingMemory;
    call: ActionCall;
    action: AnyAction;
    logger: Logger;
    taskRunner: TaskRunner;
    agent: AnyAgent;
    agentState?: ContextState;
    abortSignal?: AbortSignal;
    pushLog?: (log: Log) => void;
}): Promise<ActionResult>;
declare function handleOutput({ outputRef, outputs, logger, state, workingMemory, agent, }: {
    outputs: Output[];
    outputRef: OutputRef;
    logger: Logger;
    workingMemory: WorkingMemory;
    state: ContextState;
    agent: AnyAgent;
}): Promise<OutputRef | OutputRef[]>;
declare function prepareContextActions(params: {
    context: Context;
    state: ContextState<AnyContext>;
    workingMemory: WorkingMemory;
    agent: AnyAgent;
    agentCtxState: ContextState<AnyContext> | undefined;
}): Promise<ActionCtxRef[]>;
declare function prepareAction({ action, context, state, workingMemory, agent, agentCtxState, }: {
    action: AnyAction;
    context: AnyContext;
    state: ContextState<AnyContext>;
    workingMemory: WorkingMemory;
    agent: AnyAgent;
    agentCtxState: ContextState<AnyContext> | undefined;
}): Promise<ActionCtxRef | undefined>;
declare function prepareContext({ agent, ctxState, agentCtxState, workingMemory, params, }: {
    agent: AnyAgent;
    ctxState: ContextState;
    agentCtxState?: ContextState;
    workingMemory: WorkingMemory;
    params?: {
        outputs?: Record<string, Omit<Output, "type">>;
        inputs?: Record<string, InputConfig>;
        actions?: AnyAction[];
        contexts?: ContextRef[];
    };
}): Promise<{
    contexts: ContextState<AnyContext>[];
    outputs: Output[];
    actions: ActionCtxRef[];
    inputs: Input[];
}>;
declare function handleInput({ inputs, inputRef, logger, ctxState, workingMemory, agent, }: {
    inputs: Record<string, InputConfig>;
    inputRef: InputRef;
    logger: Logger;
    workingMemory: WorkingMemory;
    ctxState: ContextState;
    agent: AnyAgent;
}): Promise<void>;

/**
 * A helper function to perform GraphQL queries.
 * - `endpoint`: the GraphQL endpoint URL.
 * - `query`: the GraphQL query string.
 * - `variables`: an optional variables object for the query.
 */
declare function fetchGraphQL<DataType = unknown>(endpoint: string, query: string, variables?: Record<string, unknown>): Promise<DataType | Error>;

type QueryParams = Record<string, string | number | boolean | null | undefined> | URLSearchParams;
interface RetryOptions {
    maxRetries?: number;
    initialDelay?: number;
    maxDelay?: number;
    backoffFactor?: number;
    retryableStatuses?: number[];
}
interface RequestOptions extends RequestInit {
    retryOptions?: RetryOptions;
    params?: QueryParams;
}
declare const http: {
    request(url: string, options?: RequestOptions): Promise<Response>;
    json<T = any>(url: string, options?: RequestOptions): Promise<T>;
    get: {
        request(url: string, params?: QueryParams, options?: RequestInit): Promise<Response>;
        json<T = any>(url: string, params?: QueryParams, options?: RequestInit): Promise<T>;
    };
    post: {
        request(url: string, body: object, options?: RequestOptions): Promise<Response>;
        json<ReturnType = any, Body extends object = object>(url: string, body: Body, options?: RequestOptions): Promise<ReturnType>;
    };
    jsonrpc<ReturnType = any, Params extends object = object>(url: string, method: string, params: Params, headers?: HeadersInit): Promise<ReturnType>;
    graphql<ReturnType = any, Variables extends object = object>(url: string, query: string, variables: Variables, headers?: HeadersInit): Promise<ReturnType>;
};

declare const templateSections: {
    readonly intro: "  You are tasked with analyzing inputs, formulating outputs, and initiating actions based on the given contexts. \n  You will be provided with a set of available actions, outputs, and contexts. \n  Your instructions are to analyze the situation and respond appropriately.";
    readonly instructions: "Follow these steps to process the updates:\n\n1. Analyze the updates and available data:\n   Wrap your reasoning process in <reasoning> tags. Consider:\n\n   - Check the available data to avoid redundant action calls\n   - The availabe contexts and their state\n   - The available actions and their asynchronous nature\n   - The content of the new updates\n   - Potential dependencies between actions\n\n   Response determination guidelines:\n\n   a) First check if required state exists in the available contexts\n   b) Respond to direct questions or requests for information\n\n2. Plan actions:\n   Before formulating a response, consider:\n\n   - What data is already available\n   - Which actions need to be initiated\n   - The order of dependencies between actions\n   - How to handle potential action failures\n   - What information to provide while actions are processing\n\n3. Formulate a output (if needed):\n   If you decide to respond to the message, use <output> tags to enclose your output.\n   Consider:\n\n   - Using available data when possible\n   - Acknowledging that certain information may not be immediately available\n   - Setting appropriate expectations about action processing time\n   - Indicating what will happen after actions complete\n   - You can only use outputs listed in the <available_outputs> section\n   - Follow the schemas provided for each output\n  \n4. Initiate actions (if needed):\n   Use <action_call> tags to initiate actions. Remember:\n\n   - Actions are processed asynchronously after your response\n   - Results will not be immediately available\n   - You can only use actions listed in the <available_actions> section\n   - Follow the schemas provided for each action\n   - Actions should be used when necessary to fulfill requests or provide information that cannot be conveyed through a simple response\n\n5. No output or action:\n   If you determine that no output or action is necessary, don't respond to that message.";
    readonly content: "Here are the available actions you can initiate:\n{{actions}}\n\nHere are the available outputs you can use:\n{{outputs}}\n\nHere is the current contexts:\n{{contexts}}\n\n<template-engine>\nPurpose: Utilize the template engine ({{...}} syntax) primarily to streamline workflows by transferring data between different components within the same turn. This includes passing outputs from actions into subsequent action arguments, or embedding data from various sources directly into response outputs. This enhances efficiency and reduces interaction latency.\n\nData Referencing: You can reference data from:\nAction Results: Use {{calls[index].path.to.value}} to access outputs from preceding actions in the current turn (e.g., {{calls[0].sandboxId}}). Ensure the index correctly points to the intended action call.\nShort-Term Memory: Retrieve values stored in short-term memory using {{shortTermMemory.key}}\n\nWhen to Use:\nData Injection: Apply templating when an action argument or a response output requires specific data (like an ID, filename, status, or content) from an action result, configuration, or short-term memory available within the current turn.\nDirect Dependencies: Particularly useful when an action requires a specific result from an action called immediately before it in the same turn.\n</template-engine>\n\nHere is the current working memory:\n{{workingMemory}}\n\nNow, analyze the following updates:\n{{updates}}";
    readonly response: "Here's how you structure your response:\n<response>\n<reasoning>\n[Your reasoning of the context, think, messages, and planned actions]\n</reasoning>\n\n[List of async action calls to be initiated, if applicable]\n<action_call name=\"[Action name]\">[action arguments using the schema as JSON]</action_call>\n\n[List of outputs, if applicable]\n<output type=\"[Output type]\" {...output attributes using the schema}>\n[output content using the content_schema]\n</output>\n</response>";
    readonly footer: "Remember:\n- Always correlate results with their original actions using callId\n- Never repeat your outputs\n- Consider the complete chain of events when formulating responses\n- Address any failures or unexpected results explicitly\n- Initiate follow-up actions only when necessary\n- Provide clear, actionable insights based on the combined results\n- Maintain context awareness between original request and final results\n\nIMPORTANT: \nAlways include the 'type' attribute in the output tag and ensure it matches one of the available output types listed above.\nRemember to include the other attribute in the output tag and ensure it matches the output attributes schema.\nIf you say you will perform an action, you MUST issue the corresponding action call here";
};
declare const promptTemplate = "{{intro}}\n\n{{instructions}}\n\n{{content}}\n\n{{response}}\n\n{{footer}}\n";
declare function formatPromptSections({ contexts, outputs, actions, workingMemory, maxWorkingMemorySize, chainOfThoughtSize, }: {
    contexts: ContextState<AnyContext>[];
    outputs: Output[];
    actions: AnyAction[];
    workingMemory: WorkingMemory;
    maxWorkingMemorySize?: number;
    chainOfThoughtSize?: number;
}): {
    actions: XMLElement;
    outputs: XMLElement;
    contexts: XMLElement;
    workingMemory: XMLElement;
    thoughts: XMLElement;
    updates: XMLElement;
};
declare const mainStep: {
    readonly name: "main";
    readonly template: "{{intro}}\n\n{{instructions}}\n\n{{content}}\n\n{{response}}\n\n{{footer}}\n";
    readonly sections: {
        readonly intro: "  You are tasked with analyzing inputs, formulating outputs, and initiating actions based on the given contexts. \n  You will be provided with a set of available actions, outputs, and contexts. \n  Your instructions are to analyze the situation and respond appropriately.";
        readonly instructions: "Follow these steps to process the updates:\n\n1. Analyze the updates and available data:\n   Wrap your reasoning process in <reasoning> tags. Consider:\n\n   - Check the available data to avoid redundant action calls\n   - The availabe contexts and their state\n   - The available actions and their asynchronous nature\n   - The content of the new updates\n   - Potential dependencies between actions\n\n   Response determination guidelines:\n\n   a) First check if required state exists in the available contexts\n   b) Respond to direct questions or requests for information\n\n2. Plan actions:\n   Before formulating a response, consider:\n\n   - What data is already available\n   - Which actions need to be initiated\n   - The order of dependencies between actions\n   - How to handle potential action failures\n   - What information to provide while actions are processing\n\n3. Formulate a output (if needed):\n   If you decide to respond to the message, use <output> tags to enclose your output.\n   Consider:\n\n   - Using available data when possible\n   - Acknowledging that certain information may not be immediately available\n   - Setting appropriate expectations about action processing time\n   - Indicating what will happen after actions complete\n   - You can only use outputs listed in the <available_outputs> section\n   - Follow the schemas provided for each output\n  \n4. Initiate actions (if needed):\n   Use <action_call> tags to initiate actions. Remember:\n\n   - Actions are processed asynchronously after your response\n   - Results will not be immediately available\n   - You can only use actions listed in the <available_actions> section\n   - Follow the schemas provided for each action\n   - Actions should be used when necessary to fulfill requests or provide information that cannot be conveyed through a simple response\n\n5. No output or action:\n   If you determine that no output or action is necessary, don't respond to that message.";
        readonly content: "Here are the available actions you can initiate:\n{{actions}}\n\nHere are the available outputs you can use:\n{{outputs}}\n\nHere is the current contexts:\n{{contexts}}\n\n<template-engine>\nPurpose: Utilize the template engine ({{...}} syntax) primarily to streamline workflows by transferring data between different components within the same turn. This includes passing outputs from actions into subsequent action arguments, or embedding data from various sources directly into response outputs. This enhances efficiency and reduces interaction latency.\n\nData Referencing: You can reference data from:\nAction Results: Use {{calls[index].path.to.value}} to access outputs from preceding actions in the current turn (e.g., {{calls[0].sandboxId}}). Ensure the index correctly points to the intended action call.\nShort-Term Memory: Retrieve values stored in short-term memory using {{shortTermMemory.key}}\n\nWhen to Use:\nData Injection: Apply templating when an action argument or a response output requires specific data (like an ID, filename, status, or content) from an action result, configuration, or short-term memory available within the current turn.\nDirect Dependencies: Particularly useful when an action requires a specific result from an action called immediately before it in the same turn.\n</template-engine>\n\nHere is the current working memory:\n{{workingMemory}}\n\nNow, analyze the following updates:\n{{updates}}";
        readonly response: "Here's how you structure your response:\n<response>\n<reasoning>\n[Your reasoning of the context, think, messages, and planned actions]\n</reasoning>\n\n[List of async action calls to be initiated, if applicable]\n<action_call name=\"[Action name]\">[action arguments using the schema as JSON]</action_call>\n\n[List of outputs, if applicable]\n<output type=\"[Output type]\" {...output attributes using the schema}>\n[output content using the content_schema]\n</output>\n</response>";
        readonly footer: "Remember:\n- Always correlate results with their original actions using callId\n- Never repeat your outputs\n- Consider the complete chain of events when formulating responses\n- Address any failures or unexpected results explicitly\n- Initiate follow-up actions only when necessary\n- Provide clear, actionable insights based on the combined results\n- Maintain context awareness between original request and final results\n\nIMPORTANT: \nAlways include the 'type' attribute in the output tag and ensure it matches one of the available output types listed above.\nRemember to include the other attribute in the output tag and ensure it matches the output attributes schema.\nIf you say you will perform an action, you MUST issue the corresponding action call here";
    };
    readonly render: (data: ReturnType<typeof formatPromptSections>) => string;
    readonly formatter: typeof formatPromptSections;
    readonly shouldContinue: (state: {
        chain: AnyRef[];
    }) => boolean;
};
type StepConfig = typeof mainStep;

type ModelConfig = {
    assist?: boolean;
    prefix?: string;
    thinkTag?: string;
};
declare const modelsResponseConfig: Record<string, ModelConfig>;
declare const reasoningModels: string[];
type GenerateOptions = {
    prompt: string;
    workingMemory: WorkingMemory;
    logger: Logger;
    model: LanguageModelV1;
    onError: (error: unknown) => void;
    abortSignal?: AbortSignal;
};
declare const runGenerate: (params: GenerateOptions, options?: TaskOptions) => Promise<{
    getTextResponse: () => Promise<string>;
    stream: AsyncGenerator<string, void, unknown>;
}>;
/**
 * Task that executes an action with the given context and parameters.
 *
 * @param options - Configuration options
 * @param options.ctx - The agent context with memory
 * @param options.action - The action to execute
 * @param options.call - The action call details
 * @param options.agent - The agent instance
 * @param options.logger - The logger instance
 * @returns The result of the action execution
 * @throws Will throw an error if the action execution fails
 */
declare const runAction: <TContext extends AnyContext>(params: {
    ctx: ActionCallContext<any, TContext>;
    action: AnyAction;
    agent: AnyAgent;
    logger: Logger;
}, options?: TaskOptions) => Promise<any>;

export { type Action, type ActionCall, type ActionCallContext, type ActionContext, type ActionCtxRef, type ActionHandler, type ActionResult, type ActionSchema, type Agent, type AgentContext, type AnyAction, type AnyActionWithContext, type AnyAgent, type AnyContext, type AnyPrompt, type AnyRef, type BaseMemory, type COTProps, type COTResponse, type Chain, type Config, type Container, type Context, type ContextConfig, type ContextRef, type ContextRefArray, type ContextSettings, type ContextState, type ContextStateApi, type ContextsEventsRecord, type ContextsRefRecord, type Debugger, type ElementNode, type Episode, type EpisodicMemory, type Evaluator, type EventDef, type EventRef, type Expert, type ExpertConfig, type Extension, type ExtractTemplateVariables, type Formatter, type GeneratePromptConfig, type GetVisitors, type Handlers, type IChain, type InferActionArguments, type InferAgentContext, type InferAgentMemory, type InferContextMemory, type InferContextOptions, type InferFormatter, type InferGeneratePromptConfig, type InferMemoryData, type InferPromptComponents, type InferPromptData, type InferPromptVariables, type InferSchema, type InferSchemaArguments, type Input, type InputConfig, type InputRef, type Instruction, type Log, type LogEntry, LogLevel, type LogWriter, Logger, type LoggerConfig, type MaybePromise, type Memory, type MemoryStore, type Msg, type Node, type NodeVisitor, NotFoundError, type Optional, type Output, type OutputConfig, type OutputRef, type OutputRefResponse, type OutputResponse, type OutputSchema, type Parser, ParsingError, type Pretty, type Prompt, type PromptVisitor, type Registry, type ResearchConfig, type ResearchResult, type RunRef, type ServiceManager, type ServiceProvider, type StepConfig, type StepRef, type Subscription, type Task, type TaskContext, type TaskOptions, TaskRunner, type TemplateInfo, type TemplateVariables, type TextNode, type Thought, type VectorStore, type WorkingMemory, type XMLElement, action, context, createContainer, createContextState, createDreams, createMemory, createMemoryStore, createParser, createPrompt, createServiceManager, createTagParser, createTagRegex, createVectorStore, createWorkingMemory, defaultWorkingMemory, deleteContext, expert, extension, fetchGraphQL, formatAction, formatContextLog, formatContextLog2, formatContextState, formatInput, formatMsg, formatOutput, formatOutputInterface, formatPromptSections, formatSchema, formatValue, formatWorkingMemory, formatXml, getContextId, getContextWorkingMemory, getContexts, getPathSegments, getValueByPath, getWorkingMemoryAllLogs, getWorkingMemoryLogs, getZodJsonSchema, handleActionCall, handleInput, handleOutput, http, input, isElement, isText, loadContextState, mainStep, memory, modelsResponseConfig, output, parse, parseAttributes, prepareAction, prepareActionCall, prepareContext, prepareContextActions, promptTemplate, pushToWorkingMemory, reasoningModels, render, resolvePathSegments, resolveTemplates, runAction, runGenerate, saveContextState, saveContextWorkingMemory, saveContextsIndex, service, splitTextIntoChunks, task, templateSections, trimWorkingMemory, tryAsync, validateEnv, xml, xmlStreamParser };
