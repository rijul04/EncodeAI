{"version":3,"sources":["../../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js","../src/dreams.ts","../src/types.ts","../src/logger.ts","../src/container.ts","../src/serviceProvider.ts","../src/task.ts","../src/context.ts","../src/formatters.ts","../src/utils.ts","../src/memory/base.ts","../src/tasks/index.ts","../src/streaming.ts","../src/handlers.ts","../src/memory/utils.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/combine-headers.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/convert-async-iterator-to-readable-stream.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/delay.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/event-source-parser-stream.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/generate-id.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/get-error-message.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/get-from-api.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/remove-undefined-entries.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/load-api-key.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/load-optional-setting.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/load-setting.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/parse-json.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/validate-types.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/validator.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/parse-provider-options.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/post-to-api.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/resolve.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/response-handler.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.3_zod@3.24.2/node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts","../../../node_modules/.pnpm/nanoid@3.3.9/node_modules/nanoid/non-secure/index.js","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/openai-provider.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/openai-chat-language-model.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/convert-to-openai-chat-messages.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/map-openai-chat-logprobs.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/map-openai-finish-reason.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/openai-error.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/get-response-metadata.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/openai-prepare-tools.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/openai-completion-language-model.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/convert-to-openai-completion-prompt.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/map-openai-completion-logprobs.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/openai-embedding-model.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/openai-image-model.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/openai-image-settings.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/responses/openai-responses-language-model.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/responses/convert-to-openai-responses-messages.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/responses/map-openai-responses-finish-reason.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/responses/openai-responses-prepare-tools.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.6_zod@3.24.2/node_modules/@ai-sdk/openai/src/openai-tools.ts","../src/xml.ts","../src/prompts/main.ts","../src/prompt.ts","../src/providers/api.ts","../src/http.ts"],"sourcesContent":["'use strict'\n\nconst hasBuffer = typeof Buffer !== 'undefined'\nconst suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/\n\nfunction _parse (text, reviver, options) {\n  // Normalize arguments\n  if (options == null) {\n    if (reviver !== null && typeof reviver === 'object') {\n      options = reviver\n      reviver = undefined\n    }\n  }\n\n  if (hasBuffer && Buffer.isBuffer(text)) {\n    text = text.toString()\n  }\n\n  // BOM checker\n  if (text && text.charCodeAt(0) === 0xFEFF) {\n    text = text.slice(1)\n  }\n\n  // Parse normally, allowing exceptions\n  const obj = JSON.parse(text, reviver)\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  const protoAction = (options && options.protoAction) || 'error'\n  const constructorAction = (options && options.constructorAction) || 'error'\n\n  // options: 'error' (default) / 'remove' / 'ignore'\n  if (protoAction === 'ignore' && constructorAction === 'ignore') {\n    return obj\n  }\n\n  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {\n    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {\n    if (suspectProtoRx.test(text) === false) {\n      return obj\n    }\n  } else {\n    if (suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  }\n\n  // Scan result for proto keys\n  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })\n}\n\nfunction filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {\n  let next = [obj]\n\n  while (next.length) {\n    const nodes = next\n    next = []\n\n    for (const node of nodes) {\n      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.__proto__ // eslint-disable-line no-proto\n      }\n\n      if (constructorAction !== 'ignore' &&\n          Object.prototype.hasOwnProperty.call(node, 'constructor') &&\n          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (constructorAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.constructor\n      }\n\n      for (const key in node) {\n        const value = node[key]\n        if (value && typeof value === 'object') {\n          next.push(value)\n        }\n      }\n    }\n  }\n  return obj\n}\n\nfunction parse (text, reviver, options) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, options)\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nfunction safeParse (text, reviver) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, { safe: true })\n  } catch (_e) {\n    return null\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nmodule.exports = parse\nmodule.exports.default = parse\nmodule.exports.parse = parse\nmodule.exports.safeParse = safeParse\nmodule.exports.scan = filter\n","import { z } from \"zod\";\nimport type {\n  Agent,\n  AnyContext,\n  Config,\n  Debugger,\n  Subscription,\n  ContextState,\n  Episode,\n  Registry,\n  InputRef,\n  WorkingMemory,\n  Log,\n  AnyRef,\n} from \"./types\";\nimport { Logger } from \"./logger\";\nimport { createContainer } from \"./container\";\nimport { createServiceManager } from \"./serviceProvider\";\nimport { TaskRunner } from \"./task\";\nimport {\n  getContextId,\n  createContextState,\n  getContextWorkingMemory,\n  saveContextWorkingMemory,\n  saveContextState,\n  saveContextsIndex,\n  loadContextState,\n  getContexts,\n  deleteContext,\n} from \"./context\";\nimport { createMemoryStore } from \"./memory\";\nimport { createMemory } from \"./memory\";\nimport { createVectorStore } from \"./memory/base\";\nimport { runGenerate } from \"./tasks\";\nimport { exportEpisodesAsTrainingData } from \"./memory/utils\";\nimport { LogLevel } from \"./types\";\nimport { randomUUIDv7, tryAsync } from \"./utils\";\nimport { createContextStreamHandler, handleStream } from \"./streaming\";\nimport { mainStep, promptTemplate } from \"./prompts/main\";\n\ntype RunState = ReturnType<typeof createContextStreamHandler>;\n\nexport function createDreams<TContext extends AnyContext = AnyContext>(\n  config: Config<TContext>\n): Agent<TContext> {\n  let booted = false;\n\n  const inputSubscriptions = new Map<string, Subscription>();\n\n  const contextIds = new Set<string>();\n  const contexts = new Map<string, ContextState>();\n  const contextsRunning = new Map<string, RunState>();\n\n  const workingMemories = new Map<string, WorkingMemory>();\n\n  const ctxSubscriptions = new Map<\n    string,\n    Set<(ref: AnyRef, done: boolean) => void>\n  >();\n\n  // todo register everything into registry, remove from agent\n  const registry: Registry = {\n    contexts: new Map(),\n    actions: new Map(),\n    outputs: new Map(),\n    inputs: new Map(),\n    extensions: new Map(),\n    models: new Map(),\n    prompts: new Map(),\n  };\n\n  registry.prompts.set(\"step\", promptTemplate);\n\n  const {\n    inputs = {},\n    outputs = {},\n    events = {},\n    actions = [],\n    experts = {},\n    services = [],\n    extensions = [],\n    model,\n    reasoningModel,\n    exportTrainingData,\n    trainingDataPath,\n  } = config;\n\n  const container = config.container ?? createContainer();\n\n  const taskRunner = config.taskRunner ?? new TaskRunner(3);\n\n  const logger = new Logger({\n    level: config.logger ?? LogLevel.INFO,\n    enableTimestamp: true,\n    enableColors: true,\n  });\n\n  container.instance(\"logger\", logger);\n\n  logger.debug(\"dreams\", \"Creating agent\", {\n    hasModel: !!model,\n    hasReasoningModel: !!reasoningModel,\n    inputsCount: Object.keys(inputs).length,\n    outputsCount: Object.keys(outputs).length,\n    actionsCount: actions.length,\n    servicesCount: services.length,\n    extensionsCount: extensions.length,\n  });\n\n  const debug: Debugger = (...args) => {\n    if (!config.debugger) return;\n    try {\n      config.debugger(...args);\n    } catch {\n      console.log(\"debugger failed\");\n    }\n  };\n\n  const serviceManager = createServiceManager(container);\n\n  for (const service of services) {\n    serviceManager.register(service);\n  }\n\n  if (config.contexts) {\n    for (const ctx of config.contexts) {\n      registry.contexts.set(ctx.type, ctx);\n    }\n  }\n\n  for (const extension of extensions) {\n    if (extension.inputs) Object.assign(inputs, extension.inputs);\n    if (extension.outputs) Object.assign(outputs, extension.outputs);\n    if (extension.events) Object.assign(events, extension.events);\n    if (extension.actions) actions.push(...extension.actions);\n    if (extension.services) {\n      for (const service of extension.services) {\n        serviceManager.register(service);\n      }\n    }\n\n    if (extension.contexts) {\n      for (const context of Object.values(extension.contexts)) {\n        registry.contexts.set(context.type, context);\n      }\n    }\n  }\n\n  const agent: Agent<TContext> = {\n    inputs,\n    outputs,\n    events,\n    actions,\n    experts,\n    memory:\n      config.memory ?? createMemory(createMemoryStore(), createVectorStore()),\n    container,\n    model,\n    reasoningModel,\n    taskRunner,\n    debugger: debug,\n    context: config.context ?? undefined,\n    exportTrainingData,\n    trainingDataPath,\n    registry,\n    emit: (event: string, data: any) => {\n      logger.debug(\"agent:event\", event, data);\n    },\n\n    isBooted() {\n      return booted;\n    },\n\n    subscribeContext(contextId, handler) {\n      if (!ctxSubscriptions.has(contextId)) {\n        ctxSubscriptions.set(contextId, new Set());\n      }\n\n      const subs = ctxSubscriptions.get(contextId)!;\n\n      if (subs.has(handler)) {\n        throw new Error(\"handler already registered\");\n      }\n\n      subs.add(handler);\n\n      return () => {\n        subs.delete(handler);\n      };\n    },\n\n    async getContexts() {\n      return getContexts(contextIds, contexts);\n    },\n\n    async getContextById<TContext extends AnyContext>(\n      id: string\n    ): Promise<ContextState<TContext> | null> {\n      if (contexts.has(id)) return contexts.get(id)! as ContextState<TContext>;\n\n      const [type] = id.split(\":\");\n\n      const context = registry.contexts.get(type) as TContext | undefined;\n\n      if (context && contextIds.has(id)) {\n        const stateSnapshot = await loadContextState(agent, context, id);\n\n        if (stateSnapshot) {\n          const state = await createContextState({\n            agent,\n            context,\n            args: stateSnapshot.args,\n            settings: stateSnapshot.settings,\n            contexts: stateSnapshot.contexts,\n          });\n\n          await this.saveContext(state);\n\n          return state;\n        }\n      }\n\n      return null;\n    },\n\n    async getContext(params) {\n      if (!registry.contexts.has(params.context.type))\n        registry.contexts.set(params.context.type, params.context);\n\n      const ctxSchema =\n        \"parse\" in params.context.schema\n          ? params.context.schema\n          : z.object(params.context.schema);\n\n      const args = ctxSchema.parse(params.args);\n      const id = getContextId(params.context, args);\n\n      if (!contexts.has(id) && contextIds.has(id)) {\n        const stateSnapshot = await loadContextState(agent, params.context, id);\n\n        if (stateSnapshot) {\n          await this.saveContext(\n            await createContextState({\n              agent,\n              context: params.context,\n              args: params.args,\n              settings: stateSnapshot.settings,\n              contexts: stateSnapshot.contexts,\n            })\n          );\n        }\n      }\n\n      if (!contexts.has(id)) {\n        await this.saveContext(\n          await createContextState({\n            agent,\n            context: params.context,\n            args: params.args,\n          })\n        );\n      }\n\n      return contexts.get(id)! as ContextState<typeof params.context>;\n    },\n\n    async loadContext(params) {\n      if (!registry.contexts.has(params.context.type))\n        registry.contexts.set(params.context.type, params.context);\n\n      const ctxSchema =\n        \"parse\" in params.context.schema\n          ? params.context.schema\n          : z.object(params.context.schema);\n\n      const args = ctxSchema.parse(params.args);\n      const id = getContextId(params.context, args);\n\n      if (!contexts.has(id) && contextIds.has(id)) {\n        console.log({ id });\n\n        const stateSnapshot = await loadContextState(agent, params.context, id);\n\n        if (stateSnapshot) {\n          await this.saveContext(\n            await createContextState({\n              agent,\n              context: params.context,\n              args: params.args,\n              settings: stateSnapshot.settings,\n              contexts: stateSnapshot.contexts,\n            })\n          );\n        }\n      }\n\n      return (contexts.get(id) as ContextState<typeof params.context>) ?? null;\n    },\n\n    async saveContext(ctxState, workingMemory) {\n      contextIds.add(ctxState.id);\n      contexts.set(ctxState.id, ctxState);\n\n      await saveContextState(agent, ctxState);\n\n      if (workingMemory) {\n        workingMemories.set(ctxState.id, workingMemory);\n        await saveContextWorkingMemory(agent, ctxState.id, workingMemory);\n      }\n\n      await saveContextsIndex(agent, contextIds);\n\n      return true;\n    },\n\n    getContextId(params) {\n      logger.trace(\"agent:getContextId\", \"Getting context id\", params);\n      return getContextId(params.context, params.args);\n    },\n\n    async getWorkingMemory(contextId) {\n      logger.trace(\"agent:getWorkingMemory\", \"Getting working memory\", {\n        contextId,\n      });\n\n      if (!workingMemories.has(contextId)) {\n        workingMemories.set(\n          contextId,\n          await getContextWorkingMemory(agent, contextId)\n        );\n      }\n\n      return workingMemories.get(contextId)!;\n    },\n\n    async deleteContext(contextId) {\n      //todo: handle if its running;\n\n      contexts.delete(contextId);\n      contextIds.delete(contextId);\n\n      contextsRunning.delete(contextId);\n      workingMemories.delete(contextId);\n\n      await deleteContext(agent, contextId);\n\n      await saveContextsIndex(agent, contextIds);\n    },\n\n    async start(args) {\n      if (booted) return agent;\n      logger.info(\"agent:start\", \"Starting agent\", { args, booted });\n\n      booted = true;\n\n      logger.debug(\"agent:start\", \"Booting services\");\n      await serviceManager.bootAll();\n\n      logger.debug(\"agent:start\", \"Installing extensions\", {\n        count: extensions.length,\n      });\n\n      for (const extension of extensions) {\n        if (extension.install) await tryAsync(extension.install, agent);\n      }\n\n      logger.debug(\"agent:start\", \"Setting up inputs\", {\n        count: Object.keys(agent.inputs).length,\n      });\n\n      const inputs = {\n        ...agent.inputs,\n      };\n\n      for (const ctx of registry.contexts.values()) {\n        if (ctx.inputs) Object.assign(inputs, ctx.inputs);\n      }\n\n      for (const [type, input] of Object.entries(inputs)) {\n        if (input.install) {\n          logger.trace(\"agent:start\", \"Installing input\", { type });\n          await tryAsync(input.install, agent);\n        }\n\n        if (input.subscribe) {\n          logger.trace(\"agent:start\", \"Subscribing to input\", { type });\n          let subscription = await tryAsync<Subscription>(\n            input.subscribe,\n            (context: any, args: any, data: any) => {\n              logger.debug(\"agent\", \"input\", { context, args, data });\n              agent\n                .send({\n                  context,\n                  input: { type, data },\n                  args,\n                })\n                .catch((err) => {\n                  logger.error(\"agent:input\", \"error\", err);\n                });\n            },\n            agent\n          );\n\n          if (subscription) inputSubscriptions.set(type, subscription);\n        }\n      }\n\n      logger.debug(\"agent:start\", \"Setting up outputs\", {\n        count: Object.keys(outputs).length,\n      });\n\n      for (const [type, output] of Object.entries(outputs)) {\n        if (output.install) {\n          logger.trace(\"agent:start\", \"Installing output\", { type });\n          await tryAsync(output.install, agent);\n        }\n      }\n\n      logger.debug(\"agent:start\", \"Setting up actions\", {\n        count: actions.length,\n      });\n\n      for (const action of actions) {\n        if (action.install) {\n          logger.trace(\"agent:start\", \"Installing action\", {\n            name: action.name,\n          });\n          await tryAsync(action.install, agent);\n        }\n      }\n\n      logger.debug(\"agent:start\", \"Loading saved contexts\");\n      const savedContexts = await agent.memory.store.get<string[]>(\"contexts\");\n\n      if (savedContexts) {\n        logger.trace(\"agent:start\", \"Restoring saved contexts\", {\n          count: savedContexts.length,\n        });\n\n        for (const id of savedContexts) {\n          contextIds.add(id);\n        }\n      }\n\n      if (agent.context) {\n        logger.debug(\"agent:start\", \"Setting up agent context\", {\n          type: agent.context.type,\n        });\n\n        const agentState = await agent.getContext({\n          context: agent.context,\n          args: args!,\n        });\n\n        contexts.set(\"agent:context\", agentState);\n      }\n\n      logger.info(\"agent:start\", \"Agent started successfully\");\n      return agent;\n    },\n\n    async stop() {\n      logger.info(\"agent:stop\", \"Stopping agent\");\n    },\n\n    async run(params) {\n      const { context, args, outputs, handlers, abortSignal } = params;\n      console.log(params.chain);\n      if (!booted) {\n        logger.error(\"agent:run\", \"Agent not booted\");\n        throw new Error(\"Not booted\");\n      }\n\n      logger.info(\"agent:run\", \"Running context\", {\n        contextType: context.type,\n        hasArgs: !!args,\n        hasCustomOutputs: !!outputs,\n        hasHandlers: !!handlers,\n      });\n\n      const ctxId = agent.getContextId({ context, args });\n\n      // try to move this to state\n      // we need this here now because its needed to create the handler\n      // and we will use that state from contextsRunning so we need to wait before checking and creating\n      const ctxState = await agent.getContext({ context, args });\n      const workingMemory = await agent.getWorkingMemory(ctxId);\n      const agentContextEntry = contexts.get(\"agent:context\");\n      const agentCtxState =\n        agent.context && agentContextEntry\n          ? await agent.getContext({\n              context: agent.context,\n              args: agentContextEntry.args,\n            })\n          : undefined;\n\n      // todo: allow to control what happens when new input is sent while the ctx is running\n      // context.onInput?\n      // we should allow to abort the current run, or just push it to current run\n      // state.controller.abort()\n      if (contextsRunning.has(ctxId)) {\n        logger.debug(\"agent:run\", \"Context already running\", {\n          id: ctxId,\n        });\n\n        const { state, push } = contextsRunning.get(ctxId)!;\n        params.chain?.forEach((el) => push(el, true));\n        return state.defer.promise;\n      }\n\n      logger.debug(\"agent:run\", \"Added context to running set\", {\n        id: ctxId,\n      });\n\n      if (!ctxSubscriptions.has(ctxId)) {\n        ctxSubscriptions.set(ctxId, new Set());\n      }\n\n      const { state, handler, push, tags, stepConfig } =\n        createContextStreamHandler({\n          agent,\n          agentCtxState,\n          ctxState,\n          handlers,\n          logger,\n          taskRunner,\n          workingMemory,\n          abortSignal,\n          stepConfig: mainStep,\n          subscriptions: ctxSubscriptions.get(ctxId)!,\n        });\n\n      contextsRunning.set(ctxId, { state, handler, push, tags, stepConfig });\n\n      let maxSteps = 0;\n\n      function getMaxSteps() {\n        return ctxState.settings.maxSteps ?? 5;\n      }\n\n      await state.setParams({\n        actions: params.actions,\n        outputs: params.outputs,\n        contexts: params.contexts,\n      });\n\n      if (params.chain) {\n        await Promise.all(params.chain.map((log) => push(log, true)));\n      }\n\n      if (state.calls.length > 0) {\n        await Promise.allSettled(state.calls);\n        state.calls.length = 0;\n      }\n\n      let stepRef = await state.start();\n\n      const model =\n        params.model ?? context.model ?? config.reasoningModel ?? config.model;\n\n      while ((maxSteps = getMaxSteps()) >= state.step) {\n        logger.info(\"agent:run\", `Starting step ${state.step}/${maxSteps}`, {\n          contextId: ctxState.id,\n        });\n\n        try {\n          if (state.step > 1) {\n            stepRef = await state.nextStep();\n          }\n\n          const promptData = stepConfig.formatter({\n            contexts: state.contexts,\n            actions: state.actions,\n            outputs: state.outputs,\n            workingMemory,\n            chainOfThoughtSize: 0,\n            maxWorkingMemorySize: ctxState.settings.maxWorkingMemorySize,\n          });\n\n          const prompt = stepConfig.render(promptData);\n\n          stepRef.data.prompt = prompt;\n\n          let streamError: any = null;\n\n          const unprocessed = [\n            ...workingMemory.inputs.filter((i) => i.processed === false),\n            ...state.chain.filter((i) => i.processed === false),\n          ];\n\n          const { stream, getTextResponse } = await taskRunner.enqueueTask(\n            runGenerate,\n            {\n              model,\n              prompt,\n              workingMemory,\n              logger,\n              abortSignal,\n              onError: (error) => {\n                streamError = error;\n                state.errors.push(error);\n              },\n            },\n            {\n              debug: agent.debugger,\n              abortSignal,\n            }\n          );\n\n          logger.debug(\"agent:run\", \"Processing stream\", { step: state.step });\n\n          await handleStream(stream, state.index, tags, handler, {});\n\n          if (streamError) {\n            throw streamError;\n          }\n\n          const response = await getTextResponse();\n          stepRef.data.response = response;\n\n          unprocessed.forEach((i) => {\n            i.processed = true;\n          });\n\n          await saveContextWorkingMemory(agent, ctxState.id, workingMemory);\n\n          logger.debug(\"agent:run\", \"Waiting for action calls to complete\", {\n            pendingCalls: state.calls.length,\n          });\n\n          await Promise.allSettled(state.calls);\n\n          state.calls.length = 0;\n\n          stepRef.processed = true;\n\n          await saveContextWorkingMemory(agent, ctxState.id, workingMemory);\n\n          await Promise.all(\n            state.contexts.map((state) =>\n              state.context.onStep?.(\n                {\n                  ...state,\n                  workingMemory,\n                },\n                agent\n              )\n            )\n          );\n\n          await Promise.all(\n            state.contexts.map((state) => agent.saveContext(state))\n          );\n\n          if (state.controller.signal.aborted) break;\n\n          if (!state.shouldContinue()) break;\n\n          state.step++;\n        } catch (error) {\n          await agent.saveContext(ctxState);\n\n          console.error(error);\n\n          await Promise.allSettled(\n            state.contexts.map((state) => agent.saveContext(state))\n          );\n\n          if (context.onError) {\n            try {\n              await context.onError(\n                error,\n                {\n                  ...ctxState,\n                  workingMemory,\n                },\n                agent\n              );\n            } catch (error) {\n              break;\n            }\n          } else {\n            break;\n          }\n        }\n      }\n\n      logger.debug(\n        \"agent:run\",\n        \"Marking all working memory chain as processed\"\n      );\n\n      workingMemory.inputs.forEach((i) => {\n        i.processed = true;\n      });\n\n      state.chain.forEach((i) => {\n        i.processed = true;\n      });\n\n      await Promise.all(\n        state.contexts.map((state) =>\n          state.context.onRun?.(\n            {\n              ...state,\n              workingMemory,\n            },\n            agent\n          )\n        )\n      );\n\n      await Promise.all(\n        state.contexts.map((state) => agent.saveContext(state))\n      );\n\n      logger.debug(\"agent:run\", \"Removing context from running set\", {\n        id: ctxState.id,\n      });\n\n      contextsRunning.delete(ctxState.id);\n\n      logger.info(\"agent:run\", \"Run completed\", {\n        contextId: ctxState.id,\n        chainLength: state.chain.length,\n      });\n\n      state.defer.resolve(state.chain);\n\n      return state.chain;\n    },\n\n    async send(params) {\n      const inputRef: InputRef = {\n        id: randomUUIDv7(),\n        ref: \"input\",\n        type: params.input.type,\n        content: params.input.data,\n        data: undefined,\n        timestamp: Date.now(),\n        processed: false,\n      };\n\n      return await agent.run({\n        ...params,\n        chain: params.chain ? [...params.chain, inputRef] : [inputRef],\n      });\n    },\n\n    async evaluator(ctx) {\n      const { id, memory } = ctx;\n      logger.debug(\"agent:evaluator\", \"memory\", memory);\n    },\n\n    /**\n     * Exports all episodes as training data\n     * @param filePath Optional path to save the training data\n     */\n    async exportAllTrainingData(filePath?: string) {\n      logger.info(\n        \"agent:exportTrainingData\",\n        \"Exporting episodes as training data\"\n      );\n\n      // Get all contexts\n      const contexts = await agent.getContexts();\n\n      // Collect all episodes from all contexts\n      const allEpisodes: Episode[] = [];\n\n      for (const { id } of contexts) {\n        const episodes = await agent.memory.vector.query(id, \"\");\n        if (episodes.length > 0) {\n          allEpisodes.push(...episodes);\n        }\n      }\n\n      logger.info(\n        \"agent:exportTrainingData\",\n        `Found ${allEpisodes.length} episodes to export`\n      );\n\n      // Export episodes as training data\n      if (allEpisodes.length > 0) {\n        await exportEpisodesAsTrainingData(\n          allEpisodes,\n          filePath || config.trainingDataPath || \"./training-data.jsonl\"\n        );\n        logger.info(\n          \"agent:exportTrainingData\",\n          \"Episodes exported successfully\"\n        );\n      } else {\n        logger.warn(\"agent:exportTrainingData\", \"No episodes found to export\");\n      }\n    },\n  };\n\n  container.instance(\"agent\", agent);\n\n  return agent;\n}\n","import { type LanguageModelV1, type Schema } from \"ai\";\nimport { z, ZodObject, ZodType, type ZodRawShape } from \"zod\";\nimport type { Container } from \"./container\";\nimport type { ServiceProvider } from \"./serviceProvider\";\nimport type { BaseMemory } from \"./memory\";\nimport type { TaskRunner } from \"./task\";\n\nexport { type LanguageModelV1, type Schema } from \"ai\";\n\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport type MaybePromise<T = any> = T | Promise<T>;\n\n/**\n * Represents a memory configuration for storing data\n * @template Data - Type of data stored in memory\n */\nexport type Memory<Data = any> = {\n  /** Unique identifier for this memory */\n  key: string;\n  /** Function to initialize memory data */\n  create: () => Promise<Data> | Data;\n};\n\n/**\n * Extracts the data type from a Memory type\n * @template TMemory - Memory type to extract data from\n */\nexport type InferMemoryData<TMemory extends Memory<any>> =\n  TMemory extends Memory<infer Data> ? Data : never;\n\n/**\n * Represents an execution chain with experts and metadata\n */\nexport type Chain = {\n  /** Unique identifier for the chain */\n  id: string;\n  /** Current thinking/reasoning state */\n  thinking: string;\n  /** Goal or purpose of this chain */\n  purpose: string;\n  /** List of experts involved in the chain */\n  experts: { name: string; data: string }[];\n};\n\n/**\n * Interface for storing and retrieving memory data\n */\nexport interface MemoryStore {\n  /**\n   * Retrieves data from memory\n   * @template T - Type of data to retrieve\n   * @param key - Key to lookup\n   * @returns Promise resolving to data or null if not found\n   */\n  get<T>(key: string): Promise<T | null>;\n\n  /**\n   * Stores data in memory\n   * @template T - Type of data to store\n   * @param key - Key to store under\n   * @param value - Data to store\n   */\n  set<T>(key: string, value: T): Promise<void>;\n\n  /**\n   * Removes data from memory\n   * @param key - Key to remove\n   */\n  delete(key: string): Promise<void>;\n\n  /**\n   * Removes all data from memory\n   */\n  clear(): Promise<void>;\n}\n\n/**\n * Interface for storing and retrieving vector data\n */\nexport interface VectorStore {\n  /** Optional connection string for the vector store */\n  connection?: string;\n\n  /**\n   * Adds or updates data in the vector store\n   * @param contextId - Unique identifier for the context\n   * @param data - Data to add or update\n   */\n  upsert(contextId: string, data: any): Promise<void>;\n\n  /**\n   * Searches the vector store for similar data\n   * @param contextId - Context to search within\n   * @param query - Query text to search for\n   * @returns Array of matching documents\n   */\n  query(contextId: string, query: string): Promise<any[]>;\n\n  /**\n   * Creates a new index in the vector store\n   * @param indexName - Name of the index to create\n   */\n  createIndex(indexName: string): Promise<void>;\n\n  /**\n   * Deletes an existing index from the vector store\n   * @param indexName - Name of the index to delete\n   */\n  deleteIndex(indexName: string): Promise<void>;\n}\n\n/**\n * Represents the working memory state during execution\n */\nexport interface WorkingMemory {\n  /** List of input references */\n  inputs: InputRef[];\n  /** List of output references */\n  outputs: OutputRef[];\n  /** List of thought records */\n  thoughts: Thought[];\n  /** List of action calls */\n  calls: ActionCall[];\n  /** List of action results */\n  results: ActionResult[];\n  // chains: Chain[];\n  episodicMemory?: EpisodicMemory;\n  /** Current image URL for multimodal context */\n  currentImage?: URL;\n\n  runs: RunRef[];\n\n  steps: StepRef[];\n\n  events: EventRef[];\n}\n\nexport type InferSchema<T> = T extends {\n  schema?: infer S extends z.AnyZodObject;\n}\n  ? z.infer<S>\n  : unknown;\n\nexport type InferAgentContext<TAgent extends AnyAgent> =\n  TAgent extends Agent<infer Content> ? Content : never;\n\nexport type InferAgentMemory<TAgent extends AnyAgent> = InferContextMemory<\n  InferAgentContext<TAgent>\n>;\n\n/**\n * Represents an evaluator that can validate action/output results\n * @template Data - Type of data being evaluated\n * @template Context - Context type for the evaluation\n */\nexport type Evaluator<\n  Data = any,\n  Context extends AgentContext<any> = AgentContext<any>,\n  TAgent extends AnyAgent = AnyAgent,\n> = {\n  name: string;\n  description?: string;\n  /** Schema for the evaluation result */\n  schema?: z.ZodType<any>;\n  /** Custom prompt template for LLM-based evaluation */\n  prompt?: string;\n  /** Custom handler for evaluation logic */\n  handler?: (\n    data: Data,\n    ctx: Context,\n    agent: TAgent\n  ) => Promise<boolean> | boolean;\n  /** Optional callback when evaluation fails */\n  onFailure?: (ctx: Context, agent: TAgent) => Promise<void> | void;\n};\n\nexport type ActionSchema =\n  | ZodRawShape\n  | z.AnyZodObject\n  | Schema<any>\n  | undefined;\n\nexport type InferActionArguments<TSchema = undefined> =\n  TSchema extends ZodRawShape\n    ? z.infer<ZodObject<TSchema>>\n    : TSchema extends z.AnyZodObject\n      ? z.infer<TSchema>\n      : TSchema extends Schema\n        ? TSchema[\"_type\"]\n        : undefined;\n\nexport type ActionContext<\n  TContext extends AnyContext = AnyContext,\n  AContext extends AnyContext = AnyContext,\n  ActionMemory extends Memory<any> = Memory<any>,\n> = AgentContext<TContext> & {\n  actionMemory: InferMemoryData<ActionMemory>;\n  agentMemory: InferContextMemory<AContext> | undefined;\n  abortSignal?: AbortSignal;\n};\n\nexport type ActionCallContext<\n  Schema extends ActionSchema = undefined,\n  TContext extends AnyContext = AnyContext,\n  AContext extends AnyContext = AnyContext,\n  ActionMemory extends Memory<any> = Memory<any>,\n> = ActionContext<TContext, AContext, ActionMemory> & {\n  call: ActionCall<InferActionArguments<Schema>>;\n} & ContextStateApi<TContext>;\n\ntype InferActionResult<Result> = Result extends ZodRawShape\n  ? z.infer<ZodObject<Result>>\n  : Result extends ZodType\n    ? z.infer<Result>\n    : Result extends Schema\n      ? Result[\"_type\"]\n      : Result;\n\nexport type ActionHandler<\n  Schema extends ActionSchema = undefined,\n  Result = any,\n  TContext extends AnyContext = AnyContext,\n  TAgent extends AnyAgent = AnyAgent,\n  TMemory extends Memory<any> = Memory<any>,\n> = Schema extends undefined\n  ? (\n      ctx: ActionCallContext<\n        Schema,\n        TContext,\n        InferAgentContext<TAgent>,\n        TMemory\n      >,\n      agent: TAgent\n    ) => MaybePromise<Result>\n  : (\n      args: InferActionArguments<Schema>,\n      ctx: ActionCallContext<\n        Schema,\n        TContext,\n        InferAgentContext<TAgent>,\n        TMemory\n      >,\n      agent: TAgent\n    ) => MaybePromise<Result>;\n\n/**\n * Represents an action that can be executed with typed parameters\n * @template Schema - Zod schema defining parameter types\n * @template Result - Return type of the action\n * @template Context - Context type for the action execution\n */\nexport interface Action<\n  Schema extends ActionSchema = ActionSchema,\n  Result = any,\n  TError = unknown,\n  TContext extends AnyContext = AnyContext,\n  TAgent extends AnyAgent = AnyAgent,\n  TMemory extends Memory<any> = Memory<any>,\n> {\n  name: string;\n  description?: string;\n  instructions?: string;\n  schema: Schema;\n  memory?: TMemory;\n  install?: (agent: TAgent) => Promise<void> | void;\n\n  enabled?: (\n    ctx: ActionContext<TContext, InferAgentContext<TAgent>, TMemory>\n  ) => boolean;\n\n  handler: ActionHandler<Schema, Result, TContext, TAgent, TMemory>;\n\n  returns?: ActionSchema;\n\n  format?: (result: ActionResult<Result>) => string | string[];\n  /** Optional evaluator for this specific action */\n  evaluator?: Evaluator<Result, AgentContext<TContext>, TAgent>;\n\n  context?: TContext;\n\n  onSuccess?: (\n    result: ActionResult<Result>,\n    ctx: ActionCallContext<\n      Schema,\n      TContext,\n      InferAgentContext<TAgent>,\n      TMemory\n    >,\n    agent: TAgent\n  ) => Promise<void> | void;\n\n  retry?: boolean | number | ((failureCount: number, error: TError) => boolean);\n\n  onError?: (\n    err: TError,\n    ctx: ActionCallContext<\n      Schema,\n      TContext,\n      InferAgentContext<TAgent>,\n      TMemory\n    >,\n    agent: TAgent\n  ) => Promise<void> | void;\n}\n\nexport type ActionCtxRef = AnyAction & { ctxId: string };\n\nexport type OutputSchema = z.AnyZodObject | z.ZodString | ZodRawShape;\n\ntype InferOutputSchemaParams<Schema extends OutputSchema> =\n  Schema extends ZodRawShape\n    ? z.infer<ZodObject<Schema>>\n    : Schema extends z.AnyZodObject | z.ZodString\n      ? z.infer<Schema>\n      : never;\n\nexport type OutputRefResponse = Pick<OutputRef, \"data\" | \"params\"> & {\n  processed?: boolean;\n};\n\nexport type OutputResponse =\n  | OutputRefResponse\n  | OutputRefResponse[]\n  | undefined\n  | void;\n\nexport type Output<\n  Schema extends OutputSchema = OutputSchema,\n  // Response extends OutputResponse = OutputResponse,\n  TContext extends AnyContext = AnyContext,\n  TAgent extends AnyAgent = AnyAgent,\n> = {\n  type: string;\n  description?: string;\n  instructions?: string;\n  required?: boolean;\n  schema?: Schema;\n  attributes?: OutputSchema;\n  install?: (agent: TAgent) => MaybePromise<void>;\n  enabled?: (ctx: AgentContext<TContext>) => boolean;\n  handler?: (\n    data: InferOutputSchemaParams<Schema>,\n    ctx: AgentContext<TContext> & {\n      outputRef: OutputRef<InferOutputSchemaParams<Schema>>;\n    },\n    agent: TAgent\n  ) => MaybePromise<OutputResponse>;\n  format?: (res: OutputResponse) => string | string[] | XMLElement;\n  /** Optional evaluator for this specific output */\n  evaluator?: Evaluator<OutputResponse, AgentContext<Context>, TAgent>;\n\n  examples?: string[];\n};\n\nexport type AnyAction = Action<any, any, any, any, AnyAgent, any>;\n\nexport type AnyActionWithContext<Ctx extends Context<any, any, any, any, any>> =\n  Action<any, any, any, Ctx, AnyAgent, any>;\n\n/**\n * Represents an input handler with validation and subscription capability\n * @template Schema - Zod schema for input parameters\n * @template Context - Context type for input handling\n */\nexport type Input<\n  Schema extends z.AnyZodObject | z.ZodString | z.ZodRawShape =\n    | z.AnyZodObject\n    | z.ZodString\n    | z.ZodRawShape,\n  TContext extends AnyContext = AnyContext,\n  TAgent extends AnyAgent = AnyAgent,\n> = {\n  type: string;\n  description?: string;\n  schema?: Schema;\n  context?: TContext;\n\n  install?: (agent: TAgent) => MaybePromise<void>;\n  enabled?: (state: AgentContext<TContext>) => Promise<boolean> | boolean;\n  handler?: (\n    data: InferSchemaArguments<Schema>,\n    ctx: AgentContext<TContext>,\n    agent: TAgent\n  ) => MaybePromise<Pick<InputRef, \"params\" | \"data\">>;\n  format?: (\n    ref: InputRef<InferSchemaArguments<Schema>>\n  ) => string | string[] | XMLElement;\n  subscribe?: (\n    send: <TContext extends AnyContext>(\n      context: TContext,\n      args: InferSchemaArguments<TContext[\"schema\"]>,\n      data: InferSchemaArguments<Schema>\n    ) => MaybePromise<void>,\n    agent: TAgent\n  ) => (() => void) | void | Promise<void | (() => void)>;\n};\n\nexport type RunRef = {\n  id: string;\n  ref: \"run\";\n  type: string;\n  data: any;\n  // metrics: {\n  //   duration: number;\n  //   steps: number;\n  //   inputs: number;\n  //   thoughts: number;\n  //   calls: number;\n  //   results: number;\n  //   outputs: number;\n  // };\n  // metadata: any;\n  timestamp: number;\n  processed: boolean;\n  stopReason?: string;\n};\n\nexport type StepRef = {\n  id: string;\n  ref: \"step\";\n  type: string;\n  step: number;\n  data: {\n    prompt?: string;\n    response?: string;\n  };\n  timestamp: number;\n  processed: boolean;\n};\n\n/** Reference to an input event in the system */\nexport type InputRef<Data = any> = {\n  id: string;\n  ref: \"input\";\n  type: string;\n  content: any;\n  data: Data;\n  params?: Record<string, string>;\n  timestamp: number;\n  processed: boolean;\n  formatted?: string | string[] | XMLElement;\n};\n\n/** Reference to an output event in the system */\nexport type OutputRef<Data = any> = {\n  id: string;\n  ref: \"output\";\n  type: string;\n  params?: Record<string, string>;\n  content: string;\n  data: Data;\n  timestamp: number;\n  processed: boolean;\n  formatted?: string | string[] | XMLElement;\n  error?: unknown;\n};\n\n/** Represents a call to an action */\nexport type ActionCall<Data = any> = {\n  ref: \"action_call\";\n  id: string;\n  name: string;\n  content: string;\n  data: Data;\n  timestamp: number;\n  processed: boolean;\n};\n\n/** Represents the result of an action execution */\nexport type ActionResult<Data = any> = {\n  ref: \"action_result\";\n  id: string;\n  callId: string;\n  name: string;\n  data: Data;\n  timestamp: number;\n  processed: boolean;\n  formatted?: string | string[] | XMLElement;\n};\n\n/** Represents a thought or reasoning step */\nexport type Thought = {\n  ref: \"thought\";\n  id: string;\n  content: string;\n  timestamp: number;\n  processed: boolean;\n};\n\n/** Represents a event */\nexport type EventRef<Data = any> = {\n  ref: \"event\";\n  id: string;\n  name: string;\n  params?: Record<string, string>;\n  data: Data;\n  timestamp: number;\n  processed: boolean;\n  formatted?: string | string[] | XMLElement;\n};\n\nexport type Log =\n  | InputRef\n  | OutputRef\n  | Thought\n  | ActionCall\n  | ActionResult\n  | EventRef;\n\nexport type AnyRef =\n  | InputRef\n  | OutputRef\n  | Thought\n  | ActionCall\n  | ActionResult\n  | EventRef\n  | StepRef\n  | RunRef;\n\n/** Properties required for Chain-of-Thought execution */\nexport type COTProps = {\n  model: LanguageModelV1;\n  plan: string;\n  inputs: InputRef[];\n  actions: Action[];\n  outputs: Output[];\n  logs: Log[];\n};\n\n/** Response structure from Chain-of-Thought execution */\nexport type COTResponse = {\n  plan: string[];\n  actions: ActionCall[];\n  outputs: OutputRef[];\n  thinking: Thought[];\n};\n\n/** Represents an XML element structure */\nexport type XMLElement = {\n  tag: string;\n  params?: Record<string, string>;\n  children?: string | (XMLElement | string)[];\n};\n\n/** Utility type to preserve type information */\nexport type Pretty<type> = { [key in keyof type]: type[key] } & unknown;\n\n/**\n * Extracts variable names from a template string\n * @template T - Template string type\n */\nexport type ExtractTemplateVariables<T extends string> =\n  T extends `${infer Start}{{${infer Var}}}${infer Rest}`\n    ? Var | ExtractTemplateVariables<Rest>\n    : never;\n\n/**\n * Converts a dot-separated path into a nested object type\n * @template P - Path string\n * @template V - Value type at the leaf\n */\ntype PathToObject<\n  P extends string,\n  V = string,\n> = P extends `${infer Key}.${infer Rest}`\n  ? { [K in Key]: PathToObject<Rest, V> }\n  : { [K in P]: V };\n\n/**\n * Merges a union of paths into a single nested object type\n * @template T - Union of path strings\n * @template V - Value type at the leaf\n */\ntype UnionToObject<T, V = string> = T extends string\n  ? PathToObject<T, V>\n  : never;\n\n/**\n * Merges multiple object types into one (handles union overlap)\n */\ntype Merge<T> = { [K in keyof T]: T[K] extends object ? Merge<T[K]> : T[K] };\n\ntype Prettify<T> = T extends object ? { [K in keyof T]: Prettify<T[K]> } : T;\n/**\n * Creates a type mapping template variables (including nested paths) to values\n * @template T - Template string type\n * @template V - Value type at the leaf (defaults to string)\n */\nexport type TemplateVariables<T extends string, V = any> = {\n  [K in ExtractTemplateVariables<T>]: any;\n};\n\n/** Represents an expert system with instructions and actions */\nexport type Expert = {\n  type: string;\n  description: string;\n  instructions: string;\n  model?: LanguageModelV1;\n  actions?: AnyAction[];\n};\n\nexport interface AgentContext<TContext extends AnyContext = AnyContext> {\n  id: string;\n  context: TContext;\n  args: InferSchemaArguments<TContext[\"schema\"]>;\n  options: InferContextOptions<TContext>;\n  settings: ContextSettings;\n  memory: InferContextMemory<TContext>;\n  workingMemory: WorkingMemory;\n}\n\nexport type AnyAgent = Agent<any>;\n\nexport interface Handlers {\n  onLogStream: (log: AnyRef, done: boolean) => void;\n  onThinking: (thought: Thought) => void;\n}\n\nexport type Registry = {\n  contexts: Map<string, AnyContext>;\n  actions: Map<string, AnyAction>;\n  inputs: Map<string, Input>;\n  outputs: Map<string, Output>;\n  extensions: Map<string, Extension>;\n  prompts: Map<string, string>;\n  models: Map<string, LanguageModelV1>;\n};\n\ninterface AgentDef<TContext extends AnyContext = AnyContext> {\n  /**\n   * The memory store and vector store used by the agent.\n   */\n  memory: BaseMemory;\n\n  /**\n   * The current context of the agent.\n   */\n  context?: TContext;\n\n  /**\n   * Debugger function for the agent.\n   */\n  debugger: Debugger;\n\n  /**\n   * The container used by the agent.\n   */\n  container: Container;\n\n  /**\n   * The task runner used by the agent.\n   */\n  taskRunner: TaskRunner;\n\n  /**\n   * The primary language model used by the agent.\n   */\n  model: LanguageModelV1;\n\n  /**\n   * The reasoning model used by the agent, if any.\n   */\n  reasoningModel?: LanguageModelV1;\n\n  /**\n   * The vector model used by the agent, if any.\n   */\n  vectorModel?: LanguageModelV1;\n\n  /**\n   * A record of input configurations for the agent.\n   */\n  inputs: Record<string, InputConfig<any, AnyContext, Agent<TContext>>>;\n\n  /**\n   * A record of output configurations for the agent.\n   */\n  outputs: Record<string, Omit<Output<any, TContext, any>, \"type\">>;\n\n  /**\n   * A record of event schemas for the agent.\n   */\n  events: Record<string, z.AnyZodObject>;\n\n  /**\n   * A record of expert configurations for the agent.\n   */\n  experts: Record<string, ExpertConfig>;\n\n  /**\n   * An array of actions available to the agent.\n   */\n  actions: Action<\n    any,\n    any,\n    unknown,\n    AnyContext,\n    Agent<TContext>,\n    Memory<any>\n  >[];\n\n  /**\n   * Whether to export training data for episodes\n   */\n  exportTrainingData?: boolean;\n\n  /**\n   * Path to save training data\n   */\n  trainingDataPath?: string;\n}\n\n/**\n * Represents an agent with various configurations and methods for handling contexts, inputs, outputs, and more.\n * @template Memory - The type of memory used by the agent.\n * @template TContext - The type of context used by the agent.\n */\nexport interface Agent<TContext extends AnyContext = AnyContext>\n  extends AgentDef<TContext> {\n  registry: Registry;\n\n  isBooted(): boolean;\n\n  /**\n   * Exports all episodes as training data\n   * @param filePath Optional path to save the training data\n   */\n  exportAllTrainingData?: (filePath?: string) => Promise<void>;\n\n  /**\n   * Emits an event with the provided arguments.\n   * @param args - Arguments to pass to the event handler.\n   */\n  emit: (...args: any[]) => void;\n\n  /**\n   * Runs the agent with the provided options.\n   * @param opts - Options for running the agent.\n   * @returns A promise that resolves to an array of logs.\n   */\n  run: <\n    TContext extends AnyContext,\n    SubContextRefs extends AnyContext[] = AnyContext[],\n  >(opts: {\n    context: TContext;\n    args: InferSchemaArguments<TContext[\"schema\"]>;\n    model?: LanguageModelV1;\n    contexts?: ContextRefArray<SubContextRefs>;\n    outputs?: Record<string, Omit<Output<any, TContext, any>, \"type\">>;\n    actions?: AnyAction[];\n    handlers?: Partial<Handlers>;\n    abortSignal?: AbortSignal;\n    chain?: Log[];\n  }) => Promise<AnyRef[]>;\n\n  /**\n   * Sends an input to the agent with the provided options.\n   * @param opts - Options for sending input to the agent.\n   * @returns A promise that resolves to an array of logs.\n   */\n  send: <\n    SContext extends AnyContext,\n    SubContextRefs extends AnyContext[] = AnyContext[],\n  >(opts: {\n    context: SContext;\n    args: InferSchemaArguments<SContext[\"schema\"]>;\n    input: { type: string; data: any };\n    model?: LanguageModelV1;\n    contexts?: ContextRefArray<SubContextRefs>;\n    outputs?: Record<string, Omit<Output<any, SContext, any>, \"type\">>;\n    actions?: AnyAction[];\n    handlers?: Partial<Handlers>;\n    abortSignal?: AbortSignal;\n    chain?: Log[];\n  }) => Promise<AnyRef[]>;\n\n  /**\n   * Evaluates the provided context.\n   * @param ctx - The context to evaluate.\n   * @returns A promise that resolves when evaluation is complete.\n   */\n  evaluator<SContext extends AnyContext>(\n    ctx: AgentContext<SContext>\n  ): Promise<void>;\n\n  /**\n   * Starts the agent with the provided arguments.\n   * @param args - Arguments to pass to the agent on start.\n   * @returns A promise that resolves to the agent instance.\n   */\n  start(args?: InferSchemaArguments<TContext[\"schema\"]>): Promise<this>;\n\n  /**\n   * Stops the agent.\n   * @returns A promise that resolves when the agent is stopped.\n   */\n  stop(): Promise<void>;\n\n  /**\n   * Retrieves the contexts managed by the agent.\n   * @returns A promise that resolves to an array of context objects.\n   */\n  getContexts(): Promise<\n    { id: string; type: string; args?: any; settings?: ContextSettings }[]\n  >;\n\n  /**\n   * Retrieves the ID for a given context and arguments.\n   * @param params - Parameters for retrieving the context ID.\n   * @returns The context ID.\n   */\n  getContextId<TContext extends AnyContext = AnyContext>(params: {\n    context: TContext;\n    args: InferSchemaArguments<TContext[\"schema\"]>;\n  }): string;\n\n  /**\n   * Retrieves the state of a given context and arguments.\n   * @param params - Parameters for retrieving the context state.\n   * @returns A promise that resolves to the context state.\n   */\n  getContext<TContext extends AnyContext>(params: {\n    context: TContext;\n    args: InferSchemaArguments<TContext[\"schema\"]>;\n  }): Promise<ContextState<TContext>>;\n\n  loadContext<TContext extends AnyContext>(params: {\n    context: TContext;\n    args: InferSchemaArguments<TContext[\"schema\"]>;\n  }): Promise<ContextState<TContext> | null>;\n\n  saveContext(\n    state: ContextState<AnyContext>,\n    workingMemory?: WorkingMemory\n  ): Promise<boolean>;\n\n  getContextById<TContext extends AnyContext>(\n    id: string\n  ): Promise<ContextState<TContext> | null>;\n\n  /**\n   * Retrieves the working memory for a given context ID.\n   * @param contextId - The ID of the context.\n   * @returns A promise that resolves to the working memory.\n   */\n  getWorkingMemory(contextId: string): Promise<WorkingMemory>;\n\n  deleteContext(contextId: string): Promise<void>;\n\n  subscribeContext(\n    contextId: string,\n    handler: (log: AnyRef, done: boolean) => void\n  ): () => void;\n}\n\nexport type Debugger = (contextId: string, keys: string[], data: any) => void;\n\nexport type Config<TContext extends AnyContext = AnyContext> = Partial<\n  AgentDef<TContext>\n> & {\n  model: Agent[\"model\"];\n  reasoningModel?: Agent[\"reasoningModel\"];\n  logger?: LogLevel;\n  contexts?: AnyContext[];\n  services?: ServiceProvider[];\n  extensions?: Extension<TContext>[];\n  /** Whether to export training data for episodes */\n  exportTrainingData?: boolean;\n  /** Path to save training data */\n  trainingDataPath?: string;\n};\n\n/** Configuration type for inputs without type field */\nexport type InputConfig<\n  Schema extends z.AnyZodObject | z.ZodString | z.ZodRawShape =\n    | z.AnyZodObject\n    | z.ZodString\n    | z.ZodRawShape,\n  TContext extends AnyContext = AnyContext,\n  TAgent extends AnyAgent = AnyAgent,\n> = Omit<Input<Schema, TContext, TAgent>, \"type\">;\n\n/** Configuration type for outputs without type field */\nexport type OutputConfig<\n  Schema extends OutputSchema = OutputSchema,\n  // Response extends OutputResponse = OutputResponse,\n  TContext extends AnyContext = AnyContext,\n  TAgent extends AnyAgent = AnyAgent,\n> = Omit<Output<Schema, TContext, TAgent>, \"type\">;\n\n/** Configuration type for experts without type field */\nexport type ExpertConfig = Omit<Expert, \"type\">;\n\n/** Function type for subscription cleanup */\nexport type Subscription = () => void;\n\n/** Enum defining available log levels */\nexport enum LogLevel {\n  ERROR = 0,\n  WARN = 1,\n  INFO = 2,\n  DEBUG = 3,\n  TRACE = 4,\n}\n\n/** Interface for custom log writers */\nexport interface LogWriter {\n  init(logPath: string): void;\n  write(data: string): void;\n}\n\n/** Configuration options for logging */\nexport interface LoggerConfig {\n  level: LogLevel;\n  enableTimestamp?: boolean;\n  enableColors?: boolean;\n  logToFile?: boolean;\n  logPath?: string;\n  logWriter?: LogWriter;\n}\n\n/** Structure of a log entry */\nexport interface LogEntry {\n  level: LogLevel;\n  timestamp: Date;\n  context: string;\n  message: string;\n  data?: any;\n}\n\n/** Results from a research operation */\nexport interface ResearchResult {\n  learnings: string[];\n  visitedUrls: string[];\n}\n\n/** Configuration for research operations */\nexport interface ResearchConfig {\n  query: string;\n  breadth: number;\n  depth: number;\n  learnings?: string[];\n  visitedUrls?: string[];\n}\n\nexport interface IChain {\n  /**\n   * A unique identifier for the chain (e.g., \"starknet\", \"ethereum\", \"solana\", etc.)\n   */\n  chainId: string;\n\n  /**\n   * Read (call) a contract or perform a query on this chain.\n   * The `call` parameter can be chain-specific data.\n   */\n  read(call: unknown): Promise<any>;\n\n  /**\n   * Write (execute a transaction) on this chain, typically requiring signatures, etc.\n   */\n  write(call: unknown): Promise<any>;\n}\n/** Type representing instructions that can be either a single string or array of strings */\nexport type Instruction = string | string[];\n\n/** Type representing any Context with generic type parameters */\nexport type AnyContext = Context<any, any, any, any, any>;\n\n/**\n * Extracts the Memory type from a Context type\n * @template TContext - The Context type to extract Memory from\n */\nexport type InferContextMemory<TContext extends AnyContext> =\n  TContext extends Context<infer TMemory, any, any, any, any> ? TMemory : never;\n\n/**\n * Extracts the Context type from a Context type\n * @template TContext - The Context type to extract Ctx from\n */\nexport type InferContextOptions<TContext extends AnyContext> =\n  TContext extends Context<any, any, infer Options, any, any> ? Options : never;\n\n/**\n * Configuration for a context that manages state and behavior\n * @template Memory - Type of memory for this context\n * @template Args - Zod schema type for context arguments\n * @template Ctx - Type of context data\n * @template Exports - Type of exported data\n */\n\nexport type InferSchemaArguments<\n  Schema extends z.ZodTypeAny | ZodRawShape | undefined = z.ZodTypeAny,\n> = Schema extends ZodRawShape\n  ? z.infer<ZodObject<Schema>>\n  : Schema extends z.ZodTypeAny\n    ? z.infer<Schema>\n    : never;\n\ntype ActionArray<T extends AnyAction[]> = {\n  [K in keyof T]: T[K];\n};\n\ntype MergeArrays<T extends Array<any>, C extends Array<any>> = T & C;\n\ninterface ContextConfigApi<\n  TMemory = any,\n  Schema extends z.ZodTypeAny | ZodRawShape = z.ZodTypeAny,\n  Ctx = any,\n  Actions extends AnyAction[] = AnyAction[],\n  Events extends Record<string, z.ZodTypeAny | ZodRawShape> = Record<\n    string,\n    z.ZodTypeAny | ZodRawShape\n  >,\n> {\n  setActions<\n    TActions extends AnyActionWithContext<\n      Context<TMemory, Schema, Ctx, any, Events>\n    >[],\n  >(\n    actions: TActions\n  ): Context<TMemory, Schema, Ctx, TActions, Events>;\n  setInputs<\n    TSchemas extends Record<\n      string,\n      z.AnyZodObject | z.ZodString | z.ZodRawShape\n    >,\n  >(inputs: {\n    [K in keyof TSchemas]: InputConfig<\n      TSchemas[K],\n      Context<TMemory, Schema, Ctx, Actions, Events>,\n      AnyAgent\n    >;\n  }): Context<TMemory, Schema, Ctx, Actions, Events>;\n  setOutputs<\n    TSchemas extends Record<\n      string,\n      z.AnyZodObject | z.ZodString | z.ZodRawShape\n    >,\n  >(outputs: {\n    [K in keyof TSchemas]: Output<\n      TSchemas[K],\n      Context<TMemory, Schema, Ctx, Actions, Events>,\n      AnyAgent\n    >;\n  }): Context<TMemory, Schema, Ctx, Actions, Events>;\n}\n\nexport type EventDef<Schema extends z.ZodTypeAny | ZodRawShape = z.ZodTypeAny> =\n  {\n    name: string;\n    schema: Schema;\n    // description?: string;\n  };\n\nexport type ContextsEventsRecord<T extends Record<string, EventDef>> = {\n  [K in keyof T]: T[K][\"schema\"];\n};\n\nexport type ContextConfig<\n  TMemory = any,\n  Args extends z.ZodTypeAny | ZodRawShape = any,\n  Ctx = any,\n  Actions extends AnyAction[] = AnyAction[],\n  Events extends Record<string, z.ZodTypeAny | z.ZodRawShape> = Record<\n    string,\n    z.ZodTypeAny | z.ZodRawShape\n  >,\n> = Optional<\n  Omit<Context<TMemory, Args, Ctx, Actions, Events>, keyof ContextConfigApi>,\n  \"actions\" | \"events\" | \"inputs\" | \"outputs\"\n>;\n\nexport interface Context<\n  TMemory = any,\n  Schema extends z.ZodTypeAny | ZodRawShape = z.ZodTypeAny,\n  Ctx = any,\n  Actions extends AnyAction[] = AnyAction[],\n  Events extends Record<string, z.ZodTypeAny | ZodRawShape> = Record<\n    string,\n    z.ZodTypeAny | ZodRawShape\n  >,\n> extends ContextConfigApi<TMemory, Schema, Ctx, Actions, Events> {\n  /** Unique type identifier for this context */\n  type: string;\n  /** Zod schema for validating context arguments */\n  schema: Schema;\n  /** Function to generate a unique key from context arguments */\n  key?: (args: InferSchemaArguments<Schema>) => string;\n\n  /** Setup function to initialize context data */\n  setup?: (\n    args: InferSchemaArguments<Schema>,\n    settings: ContextSettings,\n    agent: AnyAgent\n  ) => Promise<Ctx> | Ctx;\n\n  /** Optional function to create new memory for this context */\n  create?: (\n    params: {\n      id: string;\n      key: string;\n      args: InferSchemaArguments<Schema>;\n      options: Ctx;\n      settings: ContextSettings;\n    },\n    agent: AnyAgent\n  ) => TMemory | Promise<TMemory>;\n\n  /** Optional instructions for this context */\n  instructions?: Instruction | ((state: ContextState<this>) => Instruction);\n\n  /** Optional description of this context */\n  description?:\n    | string\n    | string[]\n    | ((state: ContextState<this>) => string | string[]);\n\n  /** Optional function to load existing memory */\n  load?: (state: Omit<ContextState<this>, \"memory\">) => Promise<TMemory>;\n  /** Optional function to save memory state */\n  save?: (state: ContextState<this>) => Promise<void>;\n\n  /** Optional function to render memory state */\n  render?: (\n    state: ContextState<this>\n  ) => string | string[] | XMLElement | XMLElement[] | (string | XMLElement)[];\n\n  model?: LanguageModelV1;\n\n  onRun?: (ctx: AgentContext<this>, agent: AnyAgent) => Promise<void>;\n\n  onStep?: (ctx: AgentContext<this>, agent: AnyAgent) => Promise<void>;\n\n  shouldContinue?: (ctx: AgentContext<this>) => boolean;\n\n  onError?: (\n    error: unknown,\n    ctx: AgentContext<this>,\n    agent: AnyAgent\n  ) => Promise<void>;\n\n  loader?: (state: ContextState<this>, agent: AnyAgent) => Promise<void>;\n\n  maxSteps?: number;\n\n  maxWorkingMemorySize?: number;\n\n  actions:\n    | Actions\n    | ((state: ContextState<this>) => Actions | Promise<Actions>);\n\n  events: Events;\n\n  /**\n   * A record of input configurations for the context.\n   */\n  inputs: Record<string, InputConfig<any, any, AnyAgent>>;\n\n  /**\n   * A record of output configurations for the context.\n   */\n  outputs: Record<string, Omit<Output<any, AnyContext, any>, \"type\">>;\n}\n\nexport type ContextSettings = {\n  model?: LanguageModelV1;\n  maxSteps?: number;\n  maxWorkingMemorySize?: number;\n};\n\nexport type ContextRef<TContext extends AnyContext = AnyContext> = {\n  context: TContext;\n  args: InferSchemaArguments<TContext[\"schema\"]>;\n};\n\nexport type ContextsRefRecord<T extends Record<string, AnyContext>> = {\n  [K in keyof T]: ContextRef<T[K]>;\n};\n\nexport type ContextRefArray<T extends Context<any>[]> = {\n  [K in keyof T]: ContextRef<T[K]>;\n};\n\ntype InferContextEvents<TContext extends AnyContext> =\n  TContext extends Context<any, any, any, any, infer Events> ? Events : never;\n\ntype ContextEventEmitter<TContext extends AnyContext> = <\n  T extends keyof InferContextEvents<TContext>,\n>(\n  event: T,\n  args: InferSchema<InferContextEvents<TContext>[T]>,\n  options?: { processed?: boolean }\n) => void;\n\n//wip\nexport type ContextStateApi<TContext extends AnyContext> = {\n  emit: ContextEventEmitter<TContext>;\n  push: (log: Log) => void;\n};\n\nexport type ContextState<TContext extends AnyContext = AnyContext> = {\n  id: string;\n  key: string;\n  context: TContext;\n  args: InferSchemaArguments<TContext[\"schema\"]>;\n  options: InferContextOptions<TContext>;\n  memory: InferContextMemory<TContext>;\n  settings: ContextSettings;\n  contexts: string[];\n};\n\nexport type Extension<\n  TContext extends AnyContext = AnyContext,\n  Contexts extends Record<string, AnyContext> = Record<string, AnyContext>,\n  Inputs extends Record<string, InputConfig<any, any>> = Record<\n    string,\n    InputConfig<any, any>\n  >,\n> = Pick<\n  Config<TContext>,\n  \"inputs\" | \"outputs\" | \"actions\" | \"services\" | \"events\"\n> & {\n  name: string;\n  install?: (agent: AnyAgent) => Promise<void> | void;\n  contexts?: Contexts;\n  inputs: Inputs;\n};\n\nexport interface Episode {\n  id: string;\n  timestamp: number;\n  observation: string; // Context and setup\n  result: string; // Outcomes of actions\n  thoughts: string;\n  metadata?: {\n    success?: boolean;\n    tags?: string[];\n    [key: string]: any;\n  };\n}\n\nexport interface EpisodicMemory {\n  episodes: Episode[];\n  index?: number; // For vector store indexing\n}\n","import { LogLevel } from \"./types\";\n\nimport type { LogEntry, LoggerConfig, LogWriter } from \"./types\";\n\nexport class Logger {\n  private config: Omit<Required<LoggerConfig>, \"logWriter\">;\n  private logWriter?: LogWriter;\n\n  constructor(config: LoggerConfig) {\n    this.config = {\n      level: config.level,\n      enableTimestamp: config.enableTimestamp ?? true,\n      enableColors: config.enableColors ?? true,\n      logToFile: config.logToFile ?? false,\n      logPath: config.logPath ?? \"./logs\",\n    };\n\n    if (this.config.logToFile && !config.logWriter) {\n      throw new Error(\"LogWriter must be provided when logToFile is enabled\");\n    }\n\n    if (config.logWriter) {\n      this.logWriter = config.logWriter;\n    }\n  }\n\n  error(context: string, message: string, data?: any) {\n    this.log(LogLevel.ERROR, context, message, data);\n\n    if (data) console.error(data);\n  }\n\n  warn(context: string, message: string, data?: any) {\n    this.log(LogLevel.WARN, context, message, data);\n  }\n\n  info(context: string, message: string, data?: any) {\n    this.log(LogLevel.INFO, context, message, data);\n  }\n\n  debug(context: string, message: string, data?: any) {\n    this.log(LogLevel.DEBUG, context, message, data);\n  }\n\n  trace(context: string, message: string, data?: any) {\n    this.log(LogLevel.TRACE, context, message, data);\n  }\n\n  private log(level: LogLevel, context: string, message: string, data?: any) {\n    if (level > this.config.level) return;\n\n    const entry: LogEntry = {\n      level,\n      timestamp: new Date(),\n      context,\n      message,\n      data,\n    };\n\n    const formatted = this.formatLogEntry(entry);\n\n    if (this.config.enableColors) {\n      console.log(this.colorize(formatted, level));\n    } else {\n      console.log(formatted);\n    }\n\n    if (this.config.logToFile) {\n      this.writeToFile(entry);\n    }\n  }\n\n  private formatLogEntry(entry: LogEntry): string {\n    const parts: string[] = [];\n\n    if (this.config.enableTimestamp) {\n      parts.push(`[${entry.timestamp.toISOString()}]`);\n    }\n\n    parts.push(`[${LogLevel[entry.level]}]`);\n    parts.push(`[${entry.context}]`);\n    parts.push(entry.message);\n\n    if (entry.data) {\n      parts.push(JSON.stringify(entry.data, null, 2));\n    }\n\n    return parts.join(\" \");\n  }\n\n  private colorize(message: string, level: LogLevel): string {\n    const colors = {\n      [LogLevel.ERROR]: \"\\x1b[31m\", // Red\n      [LogLevel.WARN]: \"\\x1b[33m\", // Yellow\n      [LogLevel.INFO]: \"\\x1b[36m\", // Cyan\n      [LogLevel.DEBUG]: \"\\x1b[32m\", // Green\n      [LogLevel.TRACE]: \"\\x1b[90m\", // Gray\n    };\n\n    const reset = \"\\x1b[0m\";\n    return `${colors[level]}${message}${reset}`;\n  }\n\n  private initLogFile() {\n    if (!this.logWriter) {\n      throw new Error(\"LogWriter not configured\");\n    }\n    this.logWriter.init(this.config.logPath);\n  }\n\n  private writeToFile(entry: LogEntry) {\n    if (!this.logWriter) {\n      throw new Error(\"LogWriter not configured\");\n    }\n\n    const logLine = this.formatLogEntry(entry) + \"\\n\";\n    this.logWriter.write(logLine);\n  }\n}\n","/**\n * Represents a constructor function that creates an instance of type T.\n */\ntype Constructor<T> = new (...args: any[]) => T;\n\n/**\n * Represents a factory function that creates an instance of type T using the container.\n */\ntype Factory<T> = (container: Container) => T;\n\n/**\n * Represents any function type.\n */\ntype FunctionType = (...args: any[]) => any;\n\n/**\n * Represents a dependency injection token that can be a string, symbol, constructor, or function.\n */\ntype Token = string | symbol | Constructor<any> | FunctionType;\n\n/**\n * Interface for a dependency injection container.\n */\nexport interface Container {\n  /**\n   * Registers a factory function for a token.\n   * Each time the token is resolved, the factory will be called to create a new instance.\n   *\n   * @param token - The token to register\n   * @param factory - The factory function that creates the instance\n   * @returns The container instance for chaining\n   */\n  register: <T>(token: Token, factory: Factory<T>) => Container;\n\n  /**\n   * Registers a singleton factory function for a token.\n   * The factory will be called only once when the token is first resolved,\n   * and the same instance will be returned for subsequent resolutions.\n   *\n   * @param token - The token to register\n   * @param factory - The factory function that creates the singleton instance\n   * @returns The container instance for chaining\n   */\n  singleton: <T>(token: Token, factory: Factory<T>) => Container;\n\n  /**\n   * Registers a pre-created instance for a token.\n   *\n   * @param token - The token to register\n   * @param instance - The instance to register\n   * @returns The container instance for chaining\n   */\n  instance: <T>(token: Token, instance: T) => Container;\n\n  /**\n   * Creates an alias for an existing token.\n   *\n   * @param aliasToken - The alias token (must be a string or symbol)\n   * @param originalToken - The original token to alias\n   * @returns The container instance for chaining\n   */\n  alias: (aliasToken: string | symbol, originalToken: Token) => Container;\n\n  /**\n   * Resolves a token to its registered instance.\n   *\n   * @param token - The token to resolve\n   * @returns The resolved instance\n   * @throws Error if no registration is found for the token\n   */\n  resolve: <T>(token: Token) => T;\n}\n\n/**\n * Creates a new dependency injection container.\n *\n * @returns A new Container instance\n *\n * @example\n * ```typescript\n * const container = createContainer();\n *\n * // Register a transient dependency\n * container.register('logger', () => new Logger());\n *\n * // Register a singleton\n * container.singleton('database', (c) => new Database(c.resolve('config')));\n *\n * // Register a pre-created instance\n * container.instance('config', { connectionString: 'mongodb://localhost:27017' });\n *\n * // Create an alias\n * container.alias('db', 'database');\n *\n * // Resolve dependencies\n * const db = container.resolve<Database>('db');\n * ```\n */\nexport const createContainer = (): Container => {\n  const instances = new Map<Token, any>();\n  const factories = new Map<Token, Factory<any>>();\n  const singletons = new Set<Token>();\n  const aliases = new Map<string | symbol, Token>();\n\n  /**\n   * Converts a token to a string representation for error messages.\n   */\n  const getTokenString = (token: Token): string => {\n    if (typeof token === \"string\") return token;\n    if (typeof token === \"symbol\") return token.toString();\n    if (typeof token === \"function\") {\n      return token.name || \"anonymous function\";\n    }\n    return \"unknown token\";\n  };\n\n  /**\n   * Resolves a token to its original token if it's an alias.\n   */\n  const resolveToken = (token: Token): Token => {\n    if (typeof token === \"string\" || typeof token === \"symbol\") {\n      return aliases.get(token) || token;\n    }\n    return token;\n  };\n\n  const container: Container = {\n    register: <T>(token: Token, factory: Factory<T>): Container => {\n      factories.set(token, factory);\n      instances.delete(token);\n      return container;\n    },\n\n    singleton: <T>(token: Token, factory: Factory<T>): Container => {\n      factories.set(token, factory);\n      singletons.add(token);\n      instances.delete(token);\n      return container;\n    },\n\n    instance: <T>(token: Token, value: T): Container => {\n      instances.set(token, value);\n      factories.delete(token);\n      singletons.delete(token);\n      return container;\n    },\n\n    alias: (aliasToken: string | symbol, originalToken: Token): Container => {\n      aliases.set(aliasToken, originalToken);\n      return container;\n    },\n\n    resolve: <T>(token: Token): T => {\n      const resolvedToken = resolveToken(token);\n\n      if (instances.has(resolvedToken)) {\n        return instances.get(resolvedToken);\n      }\n\n      const factory = factories.get(resolvedToken);\n      if (!factory) {\n        throw new Error(\n          `No registration found for ${getTokenString(resolvedToken)}`\n        );\n      }\n\n      if (singletons.has(resolvedToken)) {\n        if (!instances.has(resolvedToken)) {\n          instances.set(resolvedToken, factory(container));\n        }\n        return instances.get(resolvedToken);\n      }\n\n      return factory(container);\n    },\n  };\n\n  return container;\n};\n","import type { Container } from \"./container\";\n\ntype ServiceProvider = {\n  register?: (container: Container) => void;\n  boot?: (container: Container) => void | Promise<void>;\n};\n\ntype ServiceState = {\n  providers: ServiceProvider[];\n  booted: Set<ServiceProvider>;\n  registered: Set<ServiceProvider>;\n};\n\ntype ServiceManager = {\n  register: (provider: ServiceProvider) => void;\n  bootAll: () => Promise<void>;\n  isBooted: (provider: ServiceProvider) => boolean;\n  isRegistered: (provider: ServiceProvider) => boolean;\n};\n\nconst service = (config: ServiceProvider): ServiceProvider => config;\n\nconst createServiceManager = (container: Container): ServiceManager => {\n  const state: ServiceState = {\n    providers: [],\n    booted: new Set(),\n    registered: new Set(),\n  };\n\n  const registerProvider = (\n    container: Container,\n    provider: ServiceProvider\n  ): void => {\n    if (state.registered.has(provider)) return;\n    state.registered.add(provider);\n    if (provider.register) provider.register(container);\n  };\n\n  const bootProvider = async (\n    container: Container,\n    provider: ServiceProvider\n  ): Promise<void> => {\n    if (state.booted.has(provider)) return;\n    state.booted.add(provider);\n    if (provider.boot) await provider.boot(container);\n  };\n\n  return {\n    register: (provider: ServiceProvider): void => {\n      if (!state.providers.includes(provider)) {\n        state.providers.push(provider);\n        registerProvider(container, provider);\n      }\n    },\n\n    bootAll: async (): Promise<void> => {\n      // First register all providers\n      for (const provider of state.providers) {\n        registerProvider(container, provider);\n      }\n\n      // Then boot them\n      for (const provider of state.providers) {\n        await bootProvider(container, provider);\n      }\n    },\n\n    isBooted: (provider: ServiceProvider): boolean =>\n      state.booted.has(provider),\n\n    isRegistered: (provider: ServiceProvider): boolean =>\n      state.registered.has(provider),\n  };\n};\n\nexport {\n  createServiceManager,\n  service,\n  type ServiceProvider,\n  type ServiceManager,\n};\n","import { v7 as randomUUIDv7 } from \"uuid\";\nimport type { Debugger } from \"./types\";\n\n/**\n * Options for configuring a task.\n */\nexport type TaskOptions = {\n  limit?: number;\n  retry?:\n    | number\n    | boolean\n    | ((failureCount: number, error: unknown) => boolean);\n  debug?: Debugger;\n  priority?: number;\n  callId?: string;\n  abortSignal?: AbortSignal;\n};\n\n/**\n * Context provided to a task.\n */\nexport type TaskContext = {\n  callId: string;\n  debug: Debugger;\n};\n\n/**\n * A task function that takes parameters and options and returns a promise.\n */\nexport type Task<in Params, out Result> = (\n  params: Params,\n  options?: TaskOptions\n) => Promise<Result>;\n\ntype InferTaskParams<T extends Task<any, any>> =\n  T extends Task<infer Params, any> ? Params : unknown;\ntype InferTaskResult<T extends Task<any, any>> =\n  T extends Task<any, infer Result> ? Result : unknown;\n\n/**\n * Represents a task that is queued for execution.\n */\ninterface QueuedTask {\n  id: string;\n  execute: () => Promise<any>;\n  priority: number;\n  resolve: (value: any) => void;\n  reject: (reason: any) => void;\n}\n\n/**\n * Manages the execution of tasks with concurrency control.\n */\nexport class TaskRunner {\n  private queue: QueuedTask[] = [];\n  private running: Set<string> = new Set();\n  private concurrency: number;\n  private processing: boolean = false;\n\n  /**\n   * Creates a new TaskRunner instance.\n   * @param concurrency - The maximum number of tasks to run concurrently.\n   */\n  constructor(concurrency: number = 1) {\n    this.concurrency = concurrency;\n  }\n\n  /**\n   * Sets the concurrency level for the task runner.\n   * @param concurrency - The new concurrency level.\n   */\n  setConcurrency(concurrency: number) {\n    this.concurrency = concurrency;\n    this.processQueue();\n  }\n\n  /**\n   * Processes the task queue, running tasks up to the concurrency limit.\n   */\n  private async processQueue() {\n    if (this.processing) return;\n    this.processing = true;\n\n    try {\n      while (this.queue.length > 0 && this.running.size < this.concurrency) {\n        // Sort entire queue by priority\n        this.queue.sort((a, b) => b.priority - a.priority);\n\n        const task = this.queue.shift();\n        if (!task) break;\n\n        this.running.add(task.id);\n\n        // Execute task without awaiting to allow concurrent execution\n        task\n          .execute()\n          .then((result) => {\n            task.resolve(result);\n          })\n          .catch((error) => {\n            task.reject(error);\n          })\n          .finally(() => {\n            this.running.delete(task.id);\n            // Try to process more tasks after one completes\n            this.processQueue();\n          });\n      }\n    } finally {\n      this.processing = false;\n    }\n  }\n\n  /**\n   * Enqueues a task for execution.\n   * @param taskFn - The function to execute as a task.\n   * @param priority - The priority of the task.\n   * @returns A promise that resolves when the task is completed.\n   */\n  enqueue<T>(taskFn: () => Promise<T>, priority: number = 0): Promise<T> {\n    return new Promise((resolve, reject) => {\n      const queuedTask: QueuedTask = {\n        id: randomUUIDv7(),\n        execute: taskFn,\n        priority,\n        resolve,\n        reject,\n      };\n\n      this.queue.push(queuedTask);\n      // Use setTimeout to ensure proper task ordering\n      setTimeout(() => this.processQueue(), 0);\n    });\n  }\n\n  /**\n   * Gets the number of active tasks.\n   */\n  get activeTasksCount(): number {\n    return this.running.size;\n  }\n\n  /**\n   * Gets the number of tasks in the queue.\n   */\n  get queuedTasksCount(): number {\n    return this.queue.length;\n  }\n\n  /**\n   * Enqueues a task function for execution.\n   * @param taskFn - The task function to execute\n   * @param params - Parameters to pass to the task\n   * @param options - Task options including priority\n   * @returns A promise that resolves when the task is completed\n   */\n  enqueueTask<TTask extends Task<any, any>>(\n    taskFn: TTask,\n    params: InferTaskParams<TTask>,\n    options: TaskOptions = {}\n  ): Promise<InferTaskResult<TTask>> {\n    return this.enqueue(() => taskFn(params, options), options.priority ?? 0);\n  }\n}\n\n/**\n * Creates a task function that can be executed or enqueued.\n * @param key - A unique key for the task.\n * @param fn - The function to execute as the task.\n * @param defaultOptions - Default options for the task.\n * @returns A task function that can be executed directly or enqueued.\n */\nexport function task<Params, Result>(\n  key: string,\n  fn: (params: Params, ctx: TaskContext) => Promise<Result>,\n  defaultOptions?: Omit<TaskOptions, \"callId\">\n): (params: Params, options?: TaskOptions) => Promise<Result> {\n  async function execute(params: Params, options?: TaskOptions) {\n    const callId = options?.callId ?? randomUUIDv7();\n\n    const mergedOptions = {\n      ...defaultOptions,\n      ...options,\n    };\n\n    delete mergedOptions.callId;\n\n    try {\n      const res = await Promise.resolve(\n        fn(params, {\n          callId,\n          debug: mergedOptions?.debug ?? (() => {}),\n        })\n      );\n      return res;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  return execute;\n}\n","import { z, type ZodRawShape } from \"zod\";\nimport type {\n  AnyAction,\n  AnyAgent,\n  AnyContext,\n  AnyRef,\n  Context,\n  ContextConfig,\n  ContextSettings,\n  ContextState,\n  InferSchemaArguments,\n  Log,\n  WorkingMemory,\n} from \"./types\";\nimport { formatContextLog } from \"./formatters\";\nimport { memory } from \"./utils\";\n\n/**\n * Creates a context configuration\n * @template Memory - Type of working memory\n * @template Args - Zod schema type for context arguments\n * @template Ctx - Type of context data\n * @template Exports - Type of exported data\n * @param ctx - Context configuration object\n * @returns Typed context configuration\n */\n\nexport function context<\n  TMemory = any,\n  Args extends z.ZodTypeAny | ZodRawShape = any,\n  Ctx = any,\n  Actions extends AnyAction[] = AnyAction[],\n  Events extends Record<string, z.ZodTypeAny | z.ZodRawShape> = Record<\n    string,\n    z.ZodTypeAny | z.ZodRawShape\n  >,\n>(\n  config: ContextConfig<TMemory, Args, Ctx, Actions, Events>\n): Context<TMemory, Args, Ctx, Actions, Events> {\n  const ctx: Context<TMemory, Args, Ctx, Actions, Events> = {\n    ...config,\n    actions: (config.actions ?? []) as Actions,\n    inputs: config.inputs ?? {},\n    outputs: config.outputs ?? {},\n    events: (config.events ?? {}) as Events,\n    setActions(actions) {\n      return context<TMemory, Args, Ctx, any, Events>({\n        ...ctx,\n        actions,\n      });\n    },\n    setInputs(inputs) {\n      return context({\n        ...ctx,\n        inputs,\n      });\n    },\n    setOutputs(outputs) {\n      return context({\n        ...ctx,\n        outputs,\n      });\n    },\n  };\n\n  return ctx;\n}\n\n/**\n * Retrieves and sorts working memory logs\n * @param memory - Working memory object\n * @param includeThoughts - Whether to include thought logs (default: true)\n * @returns Sorted array of memory logs\n */\nexport function getWorkingMemoryLogs(\n  memory: Partial<WorkingMemory>,\n  includeThoughts = true\n): Log[] {\n  return [\n    ...(memory.inputs ?? []),\n    ...(memory.outputs ?? []),\n    ...(memory.calls ?? []),\n    ...((includeThoughts ? memory.thoughts : undefined) ?? []),\n    ...(memory.results ?? []),\n    ...(memory.events ?? []),\n  ].sort((a, b) => (a.timestamp > b.timestamp ? 1 : -1));\n}\n\nexport function getWorkingMemoryAllLogs(\n  memory: Partial<WorkingMemory>,\n  includeThoughts = true\n): AnyRef[] {\n  return [\n    ...(memory.inputs ?? []),\n    ...(memory.outputs ?? []),\n    ...(memory.calls ?? []),\n    ...((includeThoughts ? memory.thoughts : undefined) ?? []),\n    ...(memory.results ?? []),\n    ...(memory.events ?? []),\n    ...(memory.steps ?? []),\n    ...(memory.runs ?? []),\n  ].sort((a, b) => (a.timestamp > b.timestamp ? 1 : -1));\n}\n\nexport function formatWorkingMemory({\n  memory,\n  processed,\n  size,\n}: {\n  memory: Partial<WorkingMemory>;\n  processed: boolean;\n  size?: number;\n}) {\n  let logs = getWorkingMemoryLogs(memory, false).filter(\n    (i) => i.processed === processed\n  );\n\n  if (size) {\n    logs = logs.slice(-size);\n  }\n\n  return logs.map((i) => formatContextLog(i)).flat();\n}\n\n/**\n * Creates a default working memory object\n * @returns Empty working memory with initialized arrays\n */\nexport function createWorkingMemory(): WorkingMemory {\n  return {\n    inputs: [],\n    outputs: [],\n    thoughts: [],\n    calls: [],\n    results: [],\n    runs: [],\n    steps: [],\n    events: [],\n  };\n}\n\nexport function pushToWorkingMemory(workingMemory: WorkingMemory, ref: Log) {\n  switch (ref.ref) {\n    case \"action_call\":\n      workingMemory.calls.push(ref);\n      break;\n    case \"action_result\":\n      workingMemory.results.push(ref);\n      break;\n    case \"input\":\n      workingMemory.inputs.push(ref);\n      break;\n    case \"output\":\n      workingMemory.outputs.push(ref);\n      break;\n    case \"thought\":\n      workingMemory.thoughts.push(ref);\n      break;\n    case \"event\":\n      workingMemory.events.push(ref);\n      break;\n    default:\n      throw new Error(\"invalid ref\");\n  }\n}\n\n/**\n * Default working memory config\n * Provides a memory container with standard working memory structure\n */\nexport const defaultWorkingMemory = memory<WorkingMemory>({\n  key: \"working-memory\",\n  create: createWorkingMemory,\n});\n\nexport function getContextId<TContext extends AnyContext>(\n  context: TContext,\n  args: z.infer<TContext[\"schema\"]>\n) {\n  const key = context.key ? context.key(args) : context.type;\n  return context.key ? [context.type, key].join(\":\") : context.type;\n}\n\nexport async function createContextState<TContext extends AnyContext>({\n  agent,\n  context,\n  args,\n  contexts = [],\n  settings: initialSettings = {},\n}: {\n  agent: AnyAgent;\n  context: TContext;\n  args: InferSchemaArguments<TContext[\"schema\"]>;\n  contexts?: string[];\n  settings?: ContextSettings;\n}): Promise<ContextState<TContext>> {\n  const key = context.key ? context.key(args) : context.type;\n  const id = context.key ? [context.type, key].join(\":\") : context.type;\n\n  const settings: ContextSettings = {\n    model: context.model,\n    maxSteps: context.maxSteps,\n    maxWorkingMemorySize: context.maxWorkingMemorySize,\n    ...initialSettings,\n  };\n\n  const options = context.setup\n    ? await context.setup(args, settings, agent)\n    : {};\n\n  const memory =\n    (await agent.memory.store.get(`memory:${id}`)) ??\n    (context.create\n      ? await Promise.resolve(\n          context.create({ key, args, id, options, settings }, agent)\n        )\n      : {});\n\n  return {\n    id,\n    key,\n    args,\n    options,\n    context,\n    memory,\n    settings,\n    contexts,\n  };\n}\n\nexport async function getContextWorkingMemory(\n  agent: AnyAgent,\n  contextId: string\n) {\n  let workingMemory = await agent.memory.store.get<WorkingMemory>(\n    [\"working-memory\", contextId].join(\":\")\n  );\n\n  if (!workingMemory) {\n    workingMemory = await defaultWorkingMemory.create();\n    await agent.memory.store.set(\n      [\"working-memory\", contextId].join(\":\"),\n      workingMemory\n    );\n  }\n\n  return workingMemory;\n}\n\nexport async function saveContextWorkingMemory(\n  agent: AnyAgent,\n  contextId: string,\n  workingMemory: WorkingMemory\n) {\n  return await agent.memory.store.set(\n    [\"working-memory\", contextId].join(\":\"),\n    workingMemory\n  );\n}\n\ntype ContextStateSnapshot = {\n  id: string;\n  type: string;\n  args: any;\n  key: string;\n  settings: Omit<ContextSettings, \"model\"> & { model?: string };\n  contexts: string[];\n};\n\nexport async function saveContextState(agent: AnyAgent, state: ContextState) {\n  const { id, context, key, args, settings, contexts } = state;\n  await agent.memory.store.set<ContextStateSnapshot>(`context:${id}`, {\n    id,\n    type: context.type,\n    key,\n    args,\n    settings: {\n      ...settings,\n      model: settings.model?.modelId,\n    },\n    contexts,\n  });\n\n  if (state.context.save) {\n    await state.context.save(state);\n  } else {\n    await agent.memory.store.set<any>(`memory:${id}`, state.memory);\n  }\n}\nexport async function loadContextState(\n  agent: AnyAgent,\n  context: AnyContext,\n  contextId: string\n): Promise<Omit<ContextState, \"options\" | \"memory\"> | null> {\n  const state = await agent.memory.store.get<ContextStateSnapshot>(\n    `context:${contextId}`\n  );\n\n  if (!state) return null;\n\n  return {\n    ...state,\n    context,\n    settings: {\n      ...state?.settings,\n      // todo: agent resolve model?\n      model: undefined,\n    },\n  };\n}\n\nexport async function saveContextsIndex(\n  agent: AnyAgent,\n  contextIds: Set<string>\n) {\n  await agent.memory.store.set<string[]>(\n    \"contexts\",\n    Array.from(contextIds.values())\n  );\n}\n\nfunction getContextData(\n  contexts: Map<string, ContextState>,\n  contextId: string\n) {\n  // todo: verify type?\n\n  if (contexts.has(contextId)) {\n    const state = contexts.get(contextId)!;\n    return {\n      id: contextId,\n      type: state.context.type,\n      key: state.key,\n      args: state.args,\n      settings: state.settings,\n    };\n  }\n\n  const [type, key] = contextId.split(\":\");\n\n  return {\n    id: contextId,\n    type,\n    key,\n  };\n}\n\nexport function getContexts(\n  contextIds: Set<string>,\n  contexts: Map<string, ContextState>\n) {\n  return Array.from(contextIds.values()).map((id) =>\n    getContextData(contexts, id)\n  );\n}\n\nexport async function deleteContext(agent: AnyAgent, contextId: string) {\n  await agent.memory.store.delete(`context:${contextId}`);\n  await agent.memory.store.delete(`memory:${contextId}`);\n  await agent.memory.store.delete(`working-memory:${contextId}`);\n}\n","import zodToJsonSchema from \"zod-to-json-schema\";\nimport type {\n  AnyAction,\n  ContextState,\n  InputRef,\n  Log,\n  Output,\n  OutputRef,\n  TemplateVariables,\n  XMLElement,\n} from \"./types\";\nimport { z } from \"zod\";\nimport { type Schema } from \"@ai-sdk/ui-utils\";\n\nexport function xml(\n  tag: string,\n  params?: Record<string, any>,\n  children?: string | XMLElement[] | any\n): XMLElement {\n  const el: XMLElement = {\n    tag,\n  };\n\n  if (params) el.params = params;\n  if (children) el.children = children;\n\n  return el;\n}\n\n/**\n * Formats an XML element into a string representation\n * @param tag - The XML tag name\n * @param params - Optional parameters/attributes for the XML tag\n * @param content - The content of the XML element (string or nested elements)\n * @returns Formatted XML string\n */\nexport function formatXml(el: XMLElement): string {\n  const params = el.params\n    ? Object.entries(el.params)\n        .map(([k, v]) => ` ${k}=\"${v}\"`)\n        .join(\"\")\n    : \"\";\n\n  let children = Array.isArray(el.children)\n    ? el.children.filter((t) => !!t)\n    : el.children;\n\n  if (Array.isArray(children) && children.length === 0) {\n    children = \"\";\n  }\n\n  children =\n    typeof children === \"string\"\n      ? children\n      : Array.isArray(children) && children.length > 0\n        ? \"\\n\" +\n          children\n            .map((el) =>\n              typeof el === \"string\"\n                ? el\n                : \"tag\" in el\n                  ? formatXml(el)\n                  : formatValue(el)\n            )\n            .join(\"\\n\") +\n          \"\\n\"\n        : formatValue(children);\n\n  try {\n    if (children === \"\") return `<${el.tag}${params} />`;\n    return `<${el.tag}${params}>${children}</${el.tag}>`;\n  } catch (error) {\n    console.log(\"failed to format\", el);\n    throw error;\n  }\n}\n\n/**\n * Formats an input reference into XML format\n * @param input - The input reference to format\n * @returns XML string representation of the input\n */\nexport function formatInput(input: InputRef) {\n  return xml(\n    \"input\",\n    { name: input.type, timestamp: input.timestamp, ...input.params },\n    input.data\n  );\n}\n\n/**\n * Formats an output reference into XML format\n * @param output - The output reference to format\n * @returns XML string representation of the output\n */\nexport function formatOutput(output: OutputRef) {\n  return xml(\n    \"output\",\n    { name: output.type, timestamp: output.timestamp, ...output.params },\n    output.data\n  );\n}\n\nexport function formatSchema(schema: any, key: string = \"schema\") {\n  return \"_type\" in schema\n    ? (schema as Schema).jsonSchema\n    : zodToJsonSchema(\"parse\" in schema ? schema : z.object(schema), key)\n        .definitions![key];\n}\n\n/**\n * Formats an output interface definition into XML format\n * @param output - The output interface to format\n * @returns XML string representation of the output interface\n */\nexport function formatOutputInterface(output: Output<any>) {\n  const params: Record<string, string> = {\n    type: output.type,\n  };\n\n  if (output.required) {\n    params.required = \"true\";\n  }\n\n  return xml(\"output\", params, [\n    output.description\n      ? { tag: \"description\", children: output.description }\n      : null,\n    output.instructions\n      ? { tag: \"instructions\", children: output.instructions }\n      : null,\n    {\n      tag: \"attributes_schema\",\n      children: output.attributes\n        ? formatSchema(output.attributes, \"attributes\")\n        : {},\n    },\n    {\n      tag: \"content_schema\",\n      children: formatSchema(output.schema ?? z.string(), \"schema\"),\n    },\n    output.examples\n      ? {\n          tag: \"examples\",\n          children: output.examples,\n        }\n      : null,\n  ]);\n}\n\nexport function formatAction(action: AnyAction) {\n  return xml(\"action\", { name: action.name }, [\n    action.description\n      ? {\n          tag: \"description\",\n          children: action.description,\n        }\n      : null,\n    action.instructions\n      ? {\n          tag: \"instructions\",\n          children: action.instructions,\n        }\n      : null,\n    action.schema\n      ? {\n          tag: \"schema\",\n          children: formatSchema(action.schema, \"schema\"),\n        }\n      : null,\n    action.returns\n      ? {\n          tag: \"returns\",\n          children: formatSchema(action.returns, \"returns\"),\n        }\n      : null,\n  ]);\n}\n\nexport function formatContextState(state: ContextState) {\n  const { context, key } = state;\n  return xml(\n    \"context\",\n    { type: context.type, key: key },\n    [\n      context.description\n        ? {\n            tag: \"description\",\n            children:\n              typeof context.description === \"function\"\n                ? context.description(state)\n                : context.description,\n          }\n        : null,\n      context.instructions\n        ? {\n            tag: \"instructions\",\n            children:\n              typeof context.instructions === \"function\"\n                ? context.instructions(state)\n                : context.instructions,\n          }\n        : null,\n      {\n        tag: \"state\",\n        children: context.render ? context.render(state) : state.memory,\n      },\n    ].flat()\n  );\n}\n\nexport type Msg =\n  | {\n      role: \"user\";\n      user: string;\n      content: string;\n    }\n  | {\n      role: \"assistant\";\n      content: string;\n    };\n\nexport function formatMsg(msg: Msg): XMLElement {\n  return {\n    tag: \"msg\",\n    params:\n      msg.role === \"user\"\n        ? {\n            role: \"user\",\n            user: msg.user,\n          }\n        : { role: \"assistant\" },\n    children: msg.content,\n  };\n}\n\nexport function formatContextLog(i: Log) {\n  switch (i.ref) {\n    case \"input\":\n      return i.formatted ?? formatInput(i);\n    case \"output\":\n      return i.formatted ?? formatOutput(i);\n    case \"thought\":\n      return xml(\"reasoning\", {}, i.content);\n    case \"action_call\":\n      return xml(\n        \"action_call\",\n        { id: i.id, name: i.name, timestamp: i.timestamp },\n        i.data ?? i.content\n      );\n    case \"action_result\":\n      return xml(\n        \"action_result\",\n        { callId: i.callId, name: i.name, timestamp: i.timestamp },\n        i.formatted ?? i.data\n      );\n    case \"event\":\n      return xml(\"event\", { name: i.name, ...i.params }, i.formatted ?? i.data);\n    default:\n      throw new Error(\"invalid context\");\n  }\n}\nexport function formatContextLog2(i: Log) {\n  switch (i.ref) {\n    case \"input\":\n      return formatInput(i);\n    case \"output\":\n      return formatOutput(i);\n    case \"thought\":\n      return xml(\"reasoning\", {}, i.content);\n    case \"action_call\":\n      return xml(\n        \"action_call\",\n        { id: i.id, name: i.name, timestamp: i.timestamp },\n        i.data ?? i.content\n      );\n    case \"action_result\":\n      return xml(\n        \"action_result\",\n        { callId: i.callId, name: i.name, timestamp: i.timestamp },\n        i.formatted ?? i.data\n      );\n    case \"event\":\n      return xml(\"event\", { name: i.name, ...i.params }, i.formatted ?? i.data);\n    default:\n      throw new Error(\"invalid context\");\n  }\n}\n\n/**\n * Formats a value for template rendering\n * @param value - The value to format\n * @returns Formatted string representation of the value\n */\nexport function formatValue(value: any): string {\n  if (typeof value !== \"string\")\n    return JSON.stringify(value, (_, value) => {\n      if (typeof value === \"bigint\") return value.toString();\n      return value;\n    });\n  return value.trim();\n}\n\n/**\n * Renders a template string by replacing variables with provided values\n * @template Template - The template string type containing variables in {{var}} format\n * @param str - The template string to render\n * @param data - Object containing values for template variables\n * @returns The rendered string with variables replaced\n */\nexport function render<Template extends string>(\n  str: Template,\n  data: TemplateVariables<Template>\n) {\n  return str.trim().replace(/\\{\\{(\\w+)\\}\\}/g, (match, key: string) => {\n    const value: any = data[key as keyof typeof data] ?? \"\";\n\n    if (typeof value === \"object\") {\n      if (value && \"tag\" in value) return formatXml(value as XMLElement);\n      if (value) formatValue(value);\n    }\n\n    if (Array.isArray(value)) {\n      return value\n        .map((v) => {\n          if (typeof v === \"object\" && v && \"tag\" in v) {\n            return formatXml(v);\n          }\n          return formatValue(v);\n        })\n        .join(\"\\n\");\n    }\n\n    return value ?? \"\";\n  });\n}\n","import { z } from \"zod\";\nimport type {\n  Action,\n  ActionSchema,\n  AnyAgent,\n  AnyContext,\n  ExpertConfig,\n  Extension,\n  InputConfig,\n  Memory,\n  Optional,\n  OutputConfig,\n  OutputSchema,\n  WorkingMemory,\n} from \"./types\";\nexport { v7 as randomUUIDv7 } from \"uuid\";\n\n/**\n * Creates an input configuration\n * @template Schema - Zod schema type for input validation\n * @template Context - Context type for input handling\n * @param config - Input configuration object\n * @returns Typed input configuration\n */\nexport function input<\n  Schema extends z.AnyZodObject | z.ZodString | z.ZodRawShape = z.ZodString,\n  TContext extends AnyContext = AnyContext,\n  TAgent extends AnyAgent = AnyAgent,\n>(config: InputConfig<Schema, TContext, TAgent>) {\n  return config;\n}\n\n/**\n * Creates an action configuration\n * @template Schema - Zod schema type for action parameters\n * @template Result - Return type of the action\n * @template Context - Context type for action execution\n * @param action - Action configuration object\n * @returns Typed action configuration\n */\nexport function action<\n  TSchema extends ActionSchema = undefined,\n  Result = any,\n  TError = any,\n  TContext extends AnyContext = AnyContext,\n  TAgent extends AnyAgent = AnyAgent,\n  TMemory extends Memory<any> = Memory<any>,\n>(\n  action: Optional<\n    Action<TSchema, Result, TError, TContext, TAgent, TMemory>,\n    \"schema\"\n  >\n): Action<TSchema, Result, TError, TContext, TAgent, TMemory> {\n  return {\n    ...action,\n    schema: action.schema ?? (undefined as TSchema),\n  };\n}\n\n/**\n * Creates an output configuration\n * @template Schema - Zod schema type for output validation\n * @template Context - Context type for output handling\n * @param config - Output configuration object\n * @returns Typed output configuration\n */\nexport function output<\n  Schema extends OutputSchema = OutputSchema,\n  // TResponse extends OutputResponse = OutputResponse,\n  Context extends AnyContext = AnyContext,\n>(config: OutputConfig<Schema, Context>) {\n  return config;\n}\n\n/**\n * Creates an expert configuration\n * @template Context - Context type for expert execution\n * @param config - Expert configuration object\n * @returns Typed expert configuration\n */\nexport function expert(config: ExpertConfig) {\n  return config;\n}\n\n/**\n * Options for text chunking\n */\ntype ChunkOptions = {\n  maxChunkSize: number;\n};\n\n/**\n * Splits text into chunks based on maximum chunk size\n * @param text - The text to split into chunks\n * @param options - Chunking options including maximum chunk size\n * @returns Array of text chunks\n */\nexport function splitTextIntoChunks(\n  text: string,\n  options: ChunkOptions\n): string[] {\n  const { maxChunkSize } = options;\n  const lines = text.split(\"\\n\");\n  const chunks: string[] = [];\n  let currentChunk = \"\";\n\n  for (const line of lines) {\n    // If adding this line would exceed maxChunkSize, start a new chunk\n    if (currentChunk.length + line.length + 1 > maxChunkSize) {\n      if (currentChunk) {\n        chunks.push(currentChunk.trim());\n      }\n      currentChunk = line;\n    } else {\n      // Add line to current chunk with a newline\n      currentChunk = currentChunk ? currentChunk + \"\\n\" + line : line;\n    }\n  }\n\n  // Don't forget to add the last chunk\n  if (currentChunk) {\n    chunks.push(currentChunk.trim());\n  }\n\n  return chunks;\n}\n\n/**\n * Creates a memory configuration\n * @template Data - Type of data stored in memory\n * @param memory - Memory configuration object\n * @returns Typed memory configuration\n */\nexport function memory<Data = any>(memory: Memory<Data>) {\n  return memory;\n}\n\nexport function extension<\n  Contexts extends Record<string, AnyContext> = Record<string, AnyContext>,\n  Inputs extends Record<string, InputConfig<any, any>> = Record<\n    string,\n    InputConfig<any, any>\n  >,\n>(\n  config: Optional<Extension<AnyContext, Contexts, Inputs>, \"inputs\">\n): Extension<AnyContext, Contexts, Inputs> {\n  return {\n    ...config,\n    inputs: config.inputs ?? ({} as Inputs),\n  };\n}\n\n/**\n * Validates environment variables against a Zod schema\n * @param schema The Zod schema to validate against\n * @param env The environment object to validate (defaults to process.env)\n * @returns The validated environment variables\n */\nexport function validateEnv<T extends z.ZodTypeAny>(\n  schema: T,\n  env = process.env\n): z.infer<T> {\n  try {\n    return schema.parse(env);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      console.error(\"Environment validation failed:\");\n      error.errors.forEach((err) => {\n        console.error(`- ${err.message}`);\n      });\n      process.exit(1);\n    }\n    throw error;\n  }\n}\n\ntype TrimWorkingMemoryOptions = {\n  thoughts: number;\n  inputs: number;\n  outputs: number;\n  actions: number;\n};\n\nconst defaultTrimOptions: TrimWorkingMemoryOptions = {\n  thoughts: 6,\n  inputs: 20,\n  outputs: 20,\n  actions: 20,\n};\n\nexport function trimWorkingMemory(\n  workingMemory: WorkingMemory,\n  options: TrimWorkingMemoryOptions = defaultTrimOptions\n) {\n  workingMemory.thoughts = workingMemory.thoughts.slice(-options.thoughts);\n  workingMemory.inputs = workingMemory.inputs.slice(-options.inputs);\n  workingMemory.outputs = workingMemory.outputs.slice(-options.outputs);\n  workingMemory.calls = workingMemory.calls.slice(-options.actions);\n  workingMemory.results = workingMemory.results.slice(-options.actions);\n}\n\n/**\n * Utility function to safely execute a function asynchronously\n * This is an implementation of the Promise.try pattern which isn't available in standard JS\n * @param fn The function to execute\n * @param ...args The arguments to pass to the function\n * @returns A promise that resolves with the result of the function\n */\nexport async function tryAsync<T>(fn: Function, ...args: any[]): Promise<T> {\n  try {\n    return await fn(...args);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\n","import type { MemoryStore, VectorStore, WorkingMemory } from \"../types\";\nimport type { LanguageModelV1 } from \"ai\";\n/**\n * Base memory implementation providing storage and vector capabilities\n */\nexport type BaseMemory = {\n  /** Store for conversation memory data */\n  store: MemoryStore;\n  /** Store for vector embeddings and similarity search */\n  vector: VectorStore;\n  vectorModel?: LanguageModelV1;\n  generateMemories?: boolean;\n};\n\n/**\n * Creates a new BaseMemory instance\n * @param store - Memory store implementation for conversation data\n * @param vector - Vector store implementation for embeddings\n * @param vectorModel - Vector model implementation for embeddings\n * @returns A new BaseMemory instance\n */\nexport function createMemory(\n  store: MemoryStore,\n  vector: VectorStore,\n  vectorModel?: LanguageModelV1\n): BaseMemory {\n  return { store, vector, vectorModel };\n}\n\n/**\n * Creates a new in-memory store for conversation data\n * @returns A MemoryStore implementation using a Map for storage\n */\nexport function createMemoryStore(): MemoryStore {\n  const data = new Map<string, any>();\n  return {\n    /**\n     * Retrieves a value from the store\n     * @param key - Key to look up\n     * @returns The stored value or null if not found\n     */\n    async get(key: string) {\n      return data.get(key) ?? null;\n    },\n\n    /**\n     * Removes all entries from the store\n     */\n    async clear() {\n      data.clear();\n    },\n\n    /**\n     * Removes a specific entry from the store\n     * @param key - Key to remove\n     */\n    async delete(key: string) {\n      data.delete(key);\n    },\n\n    /**\n     * Stores a value in the store\n     * @param key - Key to store under\n     * @param value - Value to store\n     */\n    async set(key: string, value: any) {\n      data.set(key, value);\n    },\n  };\n}\n\n/**\n * Creates a no-op vector store implementation\n * @returns A VectorStore implementation that performs no operations\n */\nexport function createVectorStore(): VectorStore {\n  return {\n    /**\n     * No-op implementation of vector store upsert\n     * @param contextId - Context ID (unused)\n     * @param data - Data to store (unused)\n     */\n    upsert(contextId: string, data: any[]) {\n      return Promise.resolve();\n    },\n\n    /**\n     * No-op implementation of vector store query\n     * @param contextId - Context ID (unused)\n     * @param query - Query string (unused)\n     * @returns Empty array\n     */\n    query(contextId: string, query: string) {\n      return Promise.resolve([]);\n    },\n\n    /**\n     * No-op implementation of index creation\n     * @param indexName - Name of index to create (unused)\n     */\n    createIndex(indexName: string) {\n      return Promise.resolve();\n    },\n\n    /**\n     * No-op implementation of index deletion\n     * @param indexName - Name of index to delete (unused)\n     */\n    deleteIndex(indexName: string) {\n      return Promise.resolve();\n    },\n  };\n}\n","import {\n  smoothStream,\n  streamText,\n  type CoreMessage,\n  type LanguageModelV1,\n  type StreamTextResult,\n  type ToolSet,\n} from \"ai\";\nimport { task } from \"../task\";\nimport type {\n  Action,\n  ActionCallContext,\n  AnyAction,\n  AnyAgent,\n  AnyContext,\n  WorkingMemory,\n} from \"../types\";\nimport type { Logger } from \"../logger\";\nimport { wrapStream } from \"../streaming\";\n\ntype ModelConfig = {\n  assist?: boolean;\n  prefix?: string;\n  thinkTag?: string;\n};\n\n// TODO: move this\nexport const modelsResponseConfig: Record<string, ModelConfig> = {\n  \"o3-mini\": {\n    assist: false,\n    prefix: \"\",\n  },\n  \"claude-3-7-sonnet-20250219\": {\n    // assist: true,\n    // prefix: \"<thinking>\",\n    // thinkTag: \"<thinking>\",\n  },\n  \"qwen-qwq-32b\": {\n    prefix: \"\",\n  },\n  \"google/gemini-2.0-flash-001\": {\n    // prefix: \"\",\n  },\n  \"deepseek-r1-distill-llama-70b\": {\n    prefix: \"\",\n    assist: false,\n  },\n};\n\nexport const reasoningModels = [\n  \"claude-3-7-sonnet-20250219\",\n  \"qwen-qwq-32b\",\n  \"deepseek-r1-distill-llama-70b\",\n  \"o3-mini\",\n  \"google/gemini-2.0-flash-001\",\n  \"google/gemini-2.0-flash-lite-preview-02-05:free\",\n];\n\n/**\n * Prepares a stream response by handling the stream result and parsing it.\n *\n * @param options - Configuration options\n * @param options.contextId - The ID of the context\n * @param options.step - The current step in the process\n * @param options.stream - The stream result to process\n * @param options.logger - The logger instance\n * @param options.task - The task context containing callId and debug function\n * @returns An object containing the parsed response promise and wrapped text stream\n */\nfunction prepareStreamResponse({\n  model,\n  stream,\n  isReasoningModel,\n}: {\n  model: LanguageModelV1;\n  stream: StreamTextResult<ToolSet, never>;\n  isReasoningModel: boolean;\n}) {\n  const prefix =\n    modelsResponseConfig[model.modelId]?.prefix ??\n    (isReasoningModel\n      ? (modelsResponseConfig[model.modelId]?.thinkTag ?? \"<think>\")\n      : \"<response>\");\n  const suffix = \"</response>\";\n  return {\n    getTextResponse: async () => {\n      const result = await stream.text;\n      const text = prefix + result + suffix;\n      return text;\n    },\n    stream: wrapStream(stream.textStream, prefix, suffix),\n  };\n}\n\ntype GenerateOptions = {\n  prompt: string;\n  workingMemory: WorkingMemory;\n  logger: Logger;\n  model: LanguageModelV1;\n  onError: (error: unknown) => void;\n  abortSignal?: AbortSignal;\n};\n\nexport const runGenerate = task(\n  \"agent:run:generate\",\n  async (\n    { prompt, workingMemory, model, onError, abortSignal }: GenerateOptions,\n    { callId, debug }\n  ) => {\n    const isReasoningModel = reasoningModels.includes(model.modelId);\n\n    const messages: CoreMessage[] = [\n      {\n        role: \"user\",\n        content: [\n          {\n            type: \"text\",\n            text: prompt,\n          },\n        ],\n      },\n    ];\n\n    if (modelsResponseConfig[model.modelId]?.assist !== false)\n      messages.push({\n        role: \"assistant\",\n        content: isReasoningModel\n          ? (modelsResponseConfig[model.modelId]?.thinkTag ?? \"<think>\")\n          : \"<response>\",\n      });\n\n    if (workingMemory.currentImage) {\n      messages[0].content = [\n        ...messages[0].content,\n        {\n          type: \"image\",\n          image: workingMemory.currentImage,\n        },\n      ] as CoreMessage[\"content\"];\n    }\n\n    try {\n    const stream = streamText({\n      model,\n      messages,\n      stopSequences: [\"\\n</response>\"],\n      temperature: 0.6,\n      abortSignal,\n        // experimental_transform: smoothStream({\n        //   chunking: \"word\",\n        // }),\n      onError: (event) => {\n          console.log({ event });\n        onError(event.error);\n      },\n    });\n\n    return prepareStreamResponse({\n      model,\n      stream,\n      isReasoningModel,\n    });\n    } catch (error) {\n      console.log({ error });\n      throw error;\n    }\n  }\n);\n\n/**\n * Task that executes an action with the given context and parameters.\n *\n * @param options - Configuration options\n * @param options.ctx - The agent context with memory\n * @param options.action - The action to execute\n * @param options.call - The action call details\n * @param options.agent - The agent instance\n * @param options.logger - The logger instance\n * @returns The result of the action execution\n * @throws Will throw an error if the action execution fails\n */\nexport const runAction = task(\n  \"agent:run:action\",\n  async <TContext extends AnyContext>({\n    ctx,\n    action,\n    agent,\n    logger,\n  }: {\n    ctx: ActionCallContext<any, TContext>;\n    action: AnyAction;\n    agent: AnyAgent;\n    logger: Logger;\n  }) => {\n    logger.info(\n      \"agent:action_call:\" + ctx.call.id,\n      ctx.call.name,\n      JSON.stringify(ctx.call.data)\n    );\n\n    try {\n      const result =\n        action.schema === undefined\n          ? await Promise.try((action as Action<undefined>).handler, ctx, agent)\n          : await Promise.try(action.handler as any, ctx.call.data, ctx, agent);\n\n      logger.debug(\"agent:action_result:\" + ctx.call.id, ctx.call.name, result);\n      return result;\n    } catch (error) {\n      logger.error(\"agent:action\", \"ACTION_FAILED\", { error });\n\n      if (action.onError) {\n        await Promise.try(action.onError, error, ctx, agent);\n      } else {\n        throw error;\n      }\n    }\n  }\n);\n","import { z, type ZodSchema } from \"zod\";\nimport { saveContextWorkingMemory } from \"./context\";\nimport {\n  getPathSegments,\n  getValueByPath,\n  handleActionCall,\n  handleInput,\n  handleOutput,\n  NotFoundError,\n  ParsingError,\n  prepareActionCall,\n  prepareContext,\n  resolvePathSegments,\n  resolveTemplates,\n} from \"./handlers\";\nimport type { Logger } from \"./logger\";\nimport { generateEpisode } from \"./memory/utils\";\nimport type { StepConfig } from \"./prompts/main\";\nimport type { TaskRunner } from \"./task\";\nimport type {\n  ActionCall,\n  ActionCtxRef,\n  ActionResult,\n  AnyAction,\n  AnyAgent,\n  AnyRef,\n  ContextRef,\n  ContextState,\n  EventRef,\n  Handlers,\n  Input,\n  Log,\n  Output,\n  OutputRef,\n  RunRef,\n  StepRef,\n  WorkingMemory,\n} from \"./types\";\nimport { randomUUIDv7 } from \"./utils\";\nimport { xmlStreamParser } from \"./xml\";\nimport pDefer from \"p-defer\";\n\ntype PartialLog = Partial<Log> &\n  Pick<Log, \"ref\" | \"id\" | \"timestamp\" | \"processed\">;\n\ntype AsyncIterableStream<T> = AsyncIterable<T> & ReadableStream<T>;\n\nexport type StackElement = {\n  index: number;\n  tag: string;\n  attributes: Record<string, any>;\n  content: string;\n  done: boolean;\n  _depth: number;\n};\n\nexport async function handleStream<Ctx = any>(\n  textStream: AsyncGenerator<string>,\n  initialIndex: number,\n  tags: Set<string>,\n  fn: (el: StackElement, ctx?: Ctx) => void,\n  ctx?: Ctx\n) {\n  let current: StackElement | undefined = undefined;\n  let stack: StackElement[] = [];\n\n  let index = initialIndex;\n\n  const parser = xmlStreamParser(tags, (tag, isClosingTag) => {\n    if (current?.tag === tag && !isClosingTag && tag === \"think\") {\n      return false;\n    }\n\n    if (current?.tag === tag && !isClosingTag && tag === \"response\") {\n      return false;\n    }\n\n    if (current?.tag === tag && !isClosingTag && tag === \"reasoning\") {\n      return false;\n    }\n\n    if (current?.tag === tag && !isClosingTag) {\n      current._depth++;\n      return false;\n    }\n\n    if (current?.tag === tag && isClosingTag) {\n      if (current._depth > 0) {\n        current._depth--;\n        return false;\n      }\n\n      return true;\n    }\n\n    if (current === undefined || current?.tag === \"response\") return true;\n\n    if (isClosingTag && stack.length > 0) {\n      const stackIndex = stack.findIndex((el) => el.tag === tag);\n      if (stackIndex === -1) return false;\n\n      if (current) {\n        fn(\n          {\n            ...current,\n            done: true,\n          },\n          ctx\n        );\n\n        current = undefined;\n      }\n\n      const closed = stack.splice(stackIndex + 1).reverse();\n\n      for (const el of closed) {\n        fn(\n          {\n            ...el,\n            done: true,\n          },\n          ctx\n        );\n      }\n\n      current = stack.pop();\n\n      return true;\n    }\n\n    return false;\n  });\n\n  parser.next();\n\n  function handleChunk(chunk: string) {\n    let result = parser.next(chunk);\n    while (!result.done && result.value) {\n      if (result.value.type === \"start\") {\n        if (current) stack.push(current);\n        current = {\n          index: index++,\n          tag: result.value.name,\n          attributes: result.value.attributes,\n          content: \"\",\n          done: false,\n          _depth: 0,\n        };\n        fn(current, ctx);\n      }\n\n      if (result.value.type === \"end\") {\n        if (current)\n          fn(\n            {\n              ...current,\n              done: true,\n            },\n            ctx\n          );\n        current = stack.pop();\n      }\n\n      if (result.value.type === \"text\") {\n        if (current) {\n          current.content += result.value.content;\n          fn(current, ctx);\n        }\n\n        // todo: we need to handle text when !current to a default output?\n      }\n      result = parser.next();\n    }\n  }\n\n  for await (const chunk of textStream) {\n    handleChunk(chunk);\n  }\n\n  parser.return?.();\n}\n\nexport async function* wrapStream(\n  stream: AsyncIterable<string>,\n  prefix: string,\n  suffix: string\n) {\n  yield prefix;\n  for await (const value of stream) {\n    yield value;\n  }\n  yield suffix;\n}\n\nconst defaultTags = new Set([\n  \"think\",\n  \"thinking\",\n  \"response\",\n  \"output\",\n  \"action_call\",\n  \"reasoning\",\n]);\n\nexport function createContextStreamHandler({\n  agent,\n  ctxState,\n  agentCtxState,\n  logger,\n  handlers,\n  taskRunner,\n  workingMemory,\n  stepConfig,\n  abortSignal,\n  subscriptions,\n}: {\n  agent: AnyAgent;\n  taskRunner: TaskRunner;\n  ctxState: ContextState;\n  agentCtxState?: ContextState;\n  logger: Logger;\n  handlers?: Partial<Handlers>;\n  workingMemory: WorkingMemory;\n  stepConfig: StepConfig;\n  abortSignal?: AbortSignal;\n  subscriptions: Set<(log: AnyRef, done: boolean) => void>;\n}) {\n  const runRef: RunRef = {\n    id: randomUUIDv7(),\n    ref: \"run\",\n    type: ctxState.context.type,\n    data: {},\n    processed: false,\n    timestamp: Date.now(),\n  };\n\n  async function createStep() {\n    const newStep: StepRef = {\n      ref: \"step\",\n      id: randomUUIDv7(),\n      step: state.step,\n      type: stepConfig.name,\n      data: {},\n      processed: false,\n      timestamp: Date.now(),\n    };\n\n    state.steps.push(newStep);\n    workingMemory.steps.push(newStep);\n\n    await handlePushLog(newStep, true);\n\n    return newStep;\n  }\n\n  async function prepare() {\n    const { actions, contexts, outputs, inputs } = await prepareContext({\n      agent,\n      ctxState,\n      workingMemory,\n      agentCtxState,\n      params: state.params,\n    });\n\n    Object.assign(state, { actions, contexts, outputs, inputs });\n  }\n\n  const state = {\n    index: 0,\n    logsByIndex: new Map<number, PartialLog>(),\n    step: 0,\n    ctxState,\n    agentCtxState,\n    runRef,\n    controller: new AbortController(),\n    steps: [] as StepRef[],\n    chain: [] as AnyRef[],\n    actions: [] as ActionCtxRef[],\n    outputs: [] as Output[],\n    inputs: [] as Input[],\n    contexts: [] as ContextState[],\n    errors: [] as any[],\n    calls: [] as Promise<any>[],\n    promises: [] as Promise<any>[],\n    response: null as null | string,\n\n    defer: pDefer<AnyRef[]>(),\n\n    params: {} as {\n      actions?: AnyAction[];\n      outputs?: Record<string, Omit<Output, \"type\">>;\n      contexts?: ContextRef[];\n    },\n\n    async setParams(params: {\n      actions?: AnyAction[];\n      outputs?: Record<string, Omit<Output<any, any, any>, \"type\">>;\n      contexts?: ContextRef[];\n    }) {\n      state.params = params;\n    },\n\n    async start() {\n      await prepare();\n\n      await handlePushLog(runRef, true);\n      state.step = 1;\n      return createStep();\n    },\n\n    async nextStep() {\n      await prepare();\n\n      state.index++;\n      return createStep();\n    },\n\n    shouldContinue() {\n      if (state.errors.length > 0) {\n        logger.warn(\"agent:run\", \"Continuing despite error\", {\n          errors: state.errors,\n          step: state.step,\n        });\n      }\n\n      for (const ctx of state.contexts) {\n        if (!ctx.context.shouldContinue) continue;\n\n        if (\n          ctx.context.shouldContinue({\n            ...ctx,\n            workingMemory,\n          })\n        )\n          return true;\n      }\n\n      return stepConfig.shouldContinue({ chain: state.chain });\n    },\n  };\n\n  abortSignal?.addEventListener(\"abort\", () => {\n    state.controller.abort(abortSignal?.reason);\n  });\n\n  function createErrorEvent({\n    name,\n    data,\n    params,\n  }: Pick<EventRef, \"name\" | \"data\" | \"params\">): EventRef {\n    return {\n      ref: \"event\",\n      id: randomUUIDv7(),\n      name,\n      data,\n      params,\n      processed: false,\n      timestamp: Date.now(),\n    };\n  }\n\n  workingMemory.runs.push(runRef);\n\n  function getOrCreateRef<\n    TLog extends Omit<PartialLog, \"id\" | \"timestamp\" | \"processed\">,\n  >(\n    index: number,\n    ref: TLog\n  ): TLog & Pick<PartialLog, \"id\" | \"timestamp\" | \"processed\"> {\n    if (!state.logsByIndex.has(index)) {\n      state.logsByIndex.set(index, {\n        id: randomUUIDv7(),\n        timestamp: Date.now(),\n        processed: false,\n        ...ref,\n      });\n    }\n\n    state.index = Math.max(index, state.index);\n\n    return state.logsByIndex.get(index)! as TLog &\n      Pick<PartialLog, \"id\" | \"timestamp\" | \"processed\">;\n  }\n\n  async function pushLogStream(log: AnyRef, done: boolean) {\n    if (log.ref !== \"output\" && done) state.chain.push(log);\n\n    if (log.ref === \"thought\" && done) {\n      workingMemory.thoughts.push(log);\n      logger.debug(\"agent:think\", \"thought\", log.content);\n      handlers?.onThinking?.(log);\n    }\n\n    if (log.ref === \"input\" && done) {\n      await handleInput({\n        agent,\n        ctxState,\n        inputRef: log,\n        inputs: {\n          ...agent.inputs,\n          ...ctxState.context.inputs,\n        },\n        logger,\n        workingMemory,\n      });\n\n      state.chain.push(log);\n      workingMemory.inputs.push(log);\n    }\n\n    if (log.ref === \"output\" && done) {\n      await handleOutputStream(log);\n    }\n\n    if (log.ref === \"event\" && done) {\n      workingMemory.events.push(log);\n    }\n\n    if (log.ref === \"action_call\" && done) {\n      workingMemory.calls.push(log);\n      await handleActionCallStream(log);\n    }\n\n    if (log.ref === \"action_result\" && done) {\n      workingMemory.results.push(log);\n\n      // Find the most recent thought and action call\n      const lastThought =\n        workingMemory.thoughts[workingMemory.thoughts.length - 1];\n      const lastActionCall =\n        workingMemory.calls[workingMemory.calls.length - 1];\n\n      // If we have a complete thought-action-result cycle, generate an episode\n      if (lastThought && lastActionCall && agent.memory.generateMemories) {\n        // Generate episode with the last thought, action call, and result\n\n        await generateEpisode(\n          lastThought,\n          lastActionCall,\n          log,\n          agent,\n          ctxState.id,\n          state.actions\n        ).catch((error) => {\n          logger.error(\n            \"agent:generateEpisode\",\n            \"Failed to generate episode\",\n            error\n          );\n        });\n      }\n    }\n\n    if (done) await saveContextWorkingMemory(agent, ctxState.id, workingMemory);\n\n    try {\n      handlers?.onLogStream?.(log, done);\n    } catch (error) {}\n\n    for (const subscriber of subscriptions) {\n      try {\n        subscriber(log, done);\n      } catch (error) {}\n    }\n  }\n\n  async function handleActionCallStream(call: ActionCall) {\n    const { action, json, templates } = await prepareActionCall({\n      call,\n      actions: state.actions,\n      logger,\n    });\n\n    if (abortSignal?.aborted) return;\n\n    if (templates.length > 0)\n      await resolveTemplates(\n        json,\n        templates,\n        async function templateResolver(key, path) {\n          if (key === \"calls\") {\n            const [index, ...resultPath] = getPathSegments(path);\n            const call = resolvePathSegments<Promise<ActionResult>>(\n              state.calls,\n              [index]\n            );\n            if (!call) throw new Error(\"invalid callIndex\");\n            console.log(\"waiting for call to finish\");\n            const results = await call;\n            // todo: handle call error\n            console.log({ resultPath, results, calls: state.calls });\n            const value = resolvePathSegments(results.data, resultPath);\n            if (value === undefined) throw new Error(\"invalid resultPath\");\n            return value;\n          }\n\n          if (key === \"shortTermMemory\") {\n            const shortTermMemory = state.contexts.find(\n              (state) => state.context.type === \"shortTermMemory\"\n            );\n            if (!shortTermMemory)\n              throw new Error(\"short term memory not found\");\n            const value = getValueByPath(shortTermMemory.memory, path);\n            if (value === undefined)\n              throw new Error(\"invalid short term memory resultPath\");\n            return value;\n          }\n\n          throw new Error(\"not implemented\");\n        }\n      );\n\n    if (action.schema) {\n      const schema =\n        \"parse\" in action.schema || \"validate\" in action.schema\n          ? action.schema\n          : z.object(action.schema);\n\n      call.data =\n        \"parse\" in schema\n          ? (schema as ZodSchema).parse(json)\n          : schema.validate\n            ? schema.validate(json)\n            : json;\n    } else {\n      call.data = json;\n    }\n\n    state.calls.push(\n      handleActionCall({\n        call,\n        action,\n        agent,\n        logger,\n        state:\n          state.contexts.find(\n            (subCtxState) => subCtxState.id === action.ctxId\n          ) ?? ctxState,\n        taskRunner,\n        workingMemory,\n        agentState: agentCtxState,\n        abortSignal,\n        pushLog: (log) => handlePushLog(log, true),\n      })\n        .catch((err) => {\n          const result: ActionResult = {\n            ref: \"action_result\",\n            id: randomUUIDv7(),\n            callId: call.id,\n            data: { error: JSON.stringify(err) },\n            name: call.name,\n            timestamp: Date.now(),\n            processed: false,\n          };\n\n          return result;\n        })\n        .then((res) => {\n          handlePushLog(res, true);\n          return res;\n        })\n    );\n  }\n\n  async function handleOutputStream(outputRef: OutputRef) {\n    logger.debug(\"agent:output\", outputRef.type, outputRef.data);\n\n    const refs = await handleOutput({\n      agent,\n      logger,\n      state: ctxState,\n      workingMemory,\n      outputs: state.outputs,\n      outputRef,\n    });\n\n    for (const ref of Array.isArray(refs) ? refs : [refs]) {\n      logger.debug(\"agent:output\", \"Output processed status\", {\n        type: ref.type,\n        processed: ref.processed,\n      });\n      state.chain.push(ref);\n      workingMemory.outputs.push(ref);\n    }\n  }\n\n  async function handlePushLog(el: AnyRef, done: boolean) {\n    try {\n      await pushLogStream(el, done);\n    } catch (error) {\n      state.errors.push(error);\n      if (el.ref === \"input\") return;\n      // wip\n      if (error instanceof NotFoundError) {\n        if (error.ref.ref === \"input\") return;\n        if (error.ref.ref === \"output\") {\n          const outputRef = {\n            ...error.ref,\n            params: {\n              ...error.ref.params,\n              id: error.ref.id,\n              error: \"OutputTypeNotFound\",\n            },\n            processed: false,\n          };\n          state.chain.push(outputRef);\n          workingMemory.outputs.push(outputRef);\n        }\n\n        await pushLogStream(\n          createErrorEvent({\n            name: `error:${error.ref.ref}`,\n            data:\n              error.ref.ref === \"output\"\n                ? {\n                    error: \"OutputTypeNotFound\",\n                    type: error.ref.type ?? \"undefined\",\n                  }\n                : { error: \"ActionNameNotFound\", name: error.ref.name },\n            params:\n              error.ref.ref === \"output\"\n                ? { outputId: error.ref.id }\n                : { callId: error.ref.id },\n          }),\n          true\n        );\n      }\n\n      if (error instanceof ParsingError) {\n        if (error.ref.ref === \"output\")\n          pushLogStream(\n            {\n              ...error.ref,\n              params: {\n                id: error.ref.id,\n                error: \"parsingError\",\n              },\n            },\n            true\n          );\n        pushLogStream(\n          createErrorEvent({\n            name: `error:${error.ref.ref}:parsingError`,\n            data: error.parsingError,\n            params:\n              error.ref.ref === \"output\"\n                ? { outputId: error.ref.id }\n                : { callId: error.ref.id },\n          }),\n          true\n        );\n      }\n    }\n  }\n\n  function handler(el: StackElement, _: any) {\n    if (abortSignal?.aborted) return;\n\n    switch (el.tag) {\n      case \"think\":\n      case \"thinking\":\n      case \"reasoning\": {\n        const ref = getOrCreateRef(el.index, {\n          ref: \"thought\",\n        });\n\n        handlePushLog(\n          {\n            ...ref,\n            content: el.content,\n          },\n          el.done\n        );\n\n        break;\n      }\n\n      case \"action_call\": {\n        const ref = getOrCreateRef(el.index, {\n          ref: \"action_call\",\n        });\n\n        handlePushLog(\n          {\n            ...ref,\n            name: el.attributes.name,\n            content: el.content,\n            data: undefined,\n            processed: false,\n          },\n          el.done\n        );\n\n        break;\n      }\n\n      case \"output\": {\n        const ref = getOrCreateRef(el.index, {\n          ref: \"output\",\n        });\n\n        const { type, ...params } = el.attributes;\n\n        handlePushLog(\n          {\n            ...ref,\n            type,\n            params,\n            content: el.content,\n            data: undefined,\n          },\n          el.done\n        );\n\n        break;\n      }\n\n      default:\n        break;\n    }\n  }\n\n  return {\n    state,\n    handler,\n    push: handlePushLog,\n    tags: defaultTags,\n    stepConfig: stepConfig,\n  };\n}\n","import { z, ZodSchema } from \"zod\";\nimport type { Logger } from \"./logger\";\nimport type { TaskRunner } from \"./task\";\nimport { runAction } from \"./tasks\";\nimport type {\n  ActionCall,\n  ActionCallContext,\n  ActionCtxRef,\n  ActionResult,\n  AnyAction,\n  AnyAgent,\n  AnyContext,\n  Context,\n  ContextRef,\n  ContextState,\n  EventRef,\n  Input,\n  InputConfig,\n  InputRef,\n  Log,\n  Memory,\n  Output,\n  OutputRef,\n  WorkingMemory,\n} from \"./types\";\nimport { randomUUIDv7 } from \"./utils\";\nimport { pushToWorkingMemory } from \"./context\";\n\nexport class NotFoundError extends Error {\n  constructor(public ref: ActionCall | OutputRef | InputRef) {\n    super();\n  }\n}\n\nexport class ParsingError extends Error {\n  constructor(\n    public ref: ActionCall | OutputRef | InputRef,\n    public parsingError: unknown\n  ) {\n    super();\n  }\n}\n\nfunction parseJSONContent(content: string) {\n  if (content.startsWith(\"```json\")) {\n    content = content.slice(\"```json\".length, -3);\n  }\n\n  return JSON.parse(content);\n}\n\nexport interface TemplateInfo {\n  path: (string | number)[];\n  template_string: string;\n  expression: string;\n  primary_key: string | null;\n}\n\nfunction detectTemplates(obj: unknown): TemplateInfo[] {\n  const foundTemplates: TemplateInfo[] = [];\n  const templatePattern = /^\\{\\{(.*)\\}\\}$/; // Matches strings that *only* contain {{...}}\n  const primaryKeyPattern = /^([a-zA-Z_][a-zA-Z0-9_]*)/; // Extracts the first identifier (simple version)\n\n  function traverse(\n    currentObj: unknown,\n    currentPath: (string | number)[]\n  ): void {\n    if (typeof currentObj === \"object\" && currentObj !== null) {\n      if (Array.isArray(currentObj)) {\n        currentObj.forEach((item, index) => {\n          traverse(item, [...currentPath, index]);\n        });\n      } else {\n        // Handle non-array objects (assuming Record<string, unknown> or similar)\n        for (const key in currentObj) {\n          if (Object.prototype.hasOwnProperty.call(currentObj, key)) {\n            // Use type assertion if necessary, depending on your exact object types\n            traverse((currentObj as Record<string, unknown>)[key], [\n              ...currentPath,\n              key,\n            ]);\n          }\n        }\n      }\n    } else if (typeof currentObj === \"string\") {\n      const match = currentObj.match(templatePattern);\n      if (match) {\n        const expression = match[1].trim();\n        const primaryKeyMatch = expression.match(primaryKeyPattern);\n        const primaryKey = primaryKeyMatch ? primaryKeyMatch[1] : null;\n\n        foundTemplates.push({\n          path: currentPath,\n          template_string: currentObj,\n          expression: expression,\n          primary_key: primaryKey,\n        });\n      }\n    }\n  }\n\n  traverse(obj, []);\n  return foundTemplates;\n}\n\nexport function getPathSegments(pathString: string) {\n  const segments = pathString.split(/[.\\[\\]]+/).filter(Boolean);\n  return segments;\n}\n\nexport function resolvePathSegments<T = any>(\n  source: any,\n  segments: string[]\n): T | undefined {\n  let current: any = source;\n\n  for (const segment of segments) {\n    if (current === null || current === undefined) {\n      return undefined;\n    }\n\n    // Check if segment is an array index\n    const index = parseInt(segment, 10);\n    if (!isNaN(index) && Array.isArray(current)) {\n      current = current[index];\n    } else if (typeof current === \"object\") {\n      current = current[segment];\n    } else {\n      return undefined; // Cannot access property on non-object/non-array\n    }\n  }\n\n  return current;\n}\n\n/**\n * Native implementation to safely get a nested value from an object/array\n * using a string path like 'a.b[0].c'.\n */\nexport function getValueByPath(source: any, pathString: string): any {\n  if (!pathString) {\n    return source; // Return the source itself if path is empty\n  }\n\n  // Basic path segment splitting (handles dot notation and array indices)\n  // More robust parsing might be needed for complex cases (e.g., keys with dots/brackets)\n  const segments = getPathSegments(pathString);\n\n  return resolvePathSegments(source, segments);\n}\n\n/**\n * Native implementation to safely set a nested value in an object/array\n * using a path array (like the one from detectTemplates).\n * Creates nested structures if they don't exist.\n */\nfunction setValueByPath(\n  target: any,\n  path: (string | number)[],\n  value: any\n): void {\n  let current: any = target;\n  const lastIndex = path.length - 1;\n\n  for (let i = 0; i < lastIndex; i++) {\n    const key = path[i];\n    const nextKey = path[i + 1];\n\n    if (current[key] === null || current[key] === undefined) {\n      // If the next key looks like an array index, create an array, otherwise an object\n      current[key] = typeof nextKey === \"number\" ? [] : {};\n    }\n    current = current[key];\n\n    // Safety check: if current is not an object/array, we can't proceed\n    if (typeof current !== \"object\" || current === null) {\n      console.error(\n        `Cannot set path beyond non-object at segment ${i} ('${key}') for path ${path.join(\".\")}`\n      );\n      return;\n    }\n  }\n\n  // Set the final value\n  const finalKey = path[lastIndex];\n  if (typeof current === \"object\" && current !== null) {\n    current[finalKey] = value;\n  } else {\n    console.error(\n      `Cannot set final value, parent at path ${path.slice(0, -1).join(\".\")} is not an object.`\n    );\n  }\n}\n\n/**\n * Resolves detected templates in an arguments object using provided data sources.\n * Modifies the input object directly. Uses native helper functions.\n */\nexport async function resolveTemplates(\n  argsObject: any, // The object containing templates (will be mutated)\n  detectedTemplates: TemplateInfo[],\n  resolver: (primary_key: string, path: string) => Promise<any>\n): Promise<void> {\n  for (const templateInfo of detectedTemplates) {\n    let resolvedValue: any = undefined;\n\n    if (!templateInfo.primary_key) {\n      console.warn(\n        `Template at path ${templateInfo.path.join(\".\")} has no primary key: ${templateInfo.template_string}`\n      );\n      continue;\n    }\n\n    const valuePath = templateInfo.expression\n      .substring(templateInfo.primary_key.length)\n      .replace(/^\\./, \"\");\n\n    try {\n      resolvedValue = await resolver(templateInfo.primary_key, valuePath);\n    } catch (error) {\n      console.error(\n        `Error resolving template at path ${templateInfo.path.join(\".\")}: ${error}`\n      );\n    }\n\n    if (resolvedValue === undefined) {\n      console.warn(\n        `Could not resolve template \"${templateInfo.template_string}\" at path ${templateInfo.path.join(\".\")}. Path or source might be invalid.`\n      );\n      throw new Error(\n        `Could not resolve template \"${templateInfo.template_string}\" at path ${templateInfo.path.join(\".\")}. Path or source might be invalid.`\n      );\n    }\n\n    // Use the native setValueByPath function\n    setValueByPath(argsObject, templateInfo.path, resolvedValue);\n  }\n}\n\nexport async function prepareActionCall({\n  call,\n  actions,\n  logger,\n}: {\n  call: ActionCall;\n  actions: ActionCtxRef[];\n  logger: Logger;\n}) {\n  const action = actions.find((a) => a.name === call.name);\n\n  if (!action) {\n    logger.error(\"agent:action\", \"ACTION_MISMATCH\", {\n      name: call.name,\n      data: call.content,\n    });\n\n    throw new NotFoundError(call);\n  }\n\n  try {\n    const content = call.content.trim();\n    const json = content.length > 0 ? parseJSONContent(content) : {};\n\n    const templates = detectTemplates(json);\n\n    return { action, json, templates };\n  } catch (error) {\n    throw new ParsingError(call, error);\n  }\n}\n\nexport async function handleActionCall({\n  state,\n  workingMemory,\n  action,\n  logger,\n  call,\n  taskRunner,\n  agent,\n  agentState,\n  abortSignal,\n  pushLog,\n}: {\n  state: ContextState<AnyContext>;\n  workingMemory: WorkingMemory;\n  call: ActionCall;\n  action: AnyAction;\n  logger: Logger;\n  taskRunner: TaskRunner;\n  agent: AnyAgent;\n  agentState?: ContextState;\n  abortSignal?: AbortSignal;\n  pushLog?: (log: Log) => void;\n}) {\n  let actionMemory: Memory<any> | undefined = undefined;\n\n  if (action.memory) {\n    actionMemory =\n      (await agent.memory.store.get(action.memory.key)) ??\n      action.memory.create();\n  }\n\n  const callCtx: ActionCallContext = {\n    ...state,\n    workingMemory,\n    actionMemory,\n    agentMemory: agentState?.memory,\n    abortSignal,\n    call,\n    push(ref) {\n      if (pushLog) pushLog(ref);\n      else pushToWorkingMemory(workingMemory, ref);\n    },\n    emit(event, args, options) {\n      console.log(\"emitting\", { event, args });\n\n      const eventRef: EventRef = {\n        ref: \"event\",\n        id: randomUUIDv7(),\n        name: event as string,\n        data: args,\n        processed: options?.processed ?? true,\n        timestamp: Date.now(),\n      };\n\n      if (pushLog) pushLog(eventRef);\n      else workingMemory.events.push(eventRef);\n    },\n  };\n\n  call.processed = true;\n\n  const result: ActionResult = {\n    ref: \"action_result\",\n    id: randomUUIDv7(),\n    callId: call.id,\n    data: undefined,\n    name: call.name,\n    timestamp: Date.now(),\n    processed: false,\n  };\n\n  result.data = await taskRunner.enqueueTask(\n    runAction,\n    {\n      action,\n      agent,\n      logger,\n      ctx: callCtx,\n    },\n    {\n      debug: agent.debugger,\n      retry: action.retry,\n      abortSignal,\n    }\n  );\n\n  if (action.format) result.formatted = action.format(result);\n\n  if (action.memory) {\n    await agent.memory.store.set(action.memory.key, actionMemory);\n  }\n\n  if (action.onSuccess) {\n    await Promise.try(action.onSuccess, result, callCtx, agent);\n  }\n\n  return result;\n}\n\nexport async function handleOutput({\n  outputRef,\n  outputs,\n  logger,\n  state,\n  workingMemory,\n  agent,\n}: {\n  outputs: Output[];\n  outputRef: OutputRef;\n  logger: Logger;\n  workingMemory: WorkingMemory;\n  state: ContextState;\n  agent: AnyAgent;\n}): Promise<OutputRef | OutputRef[]> {\n  const output = outputs.find((output) => output.type === outputRef.type);\n\n  if (!output) {\n    throw new NotFoundError(outputRef);\n  }\n\n  logger.debug(\"agent:output\", outputRef.type, outputRef.data);\n\n  if (output.schema) {\n    const schema = (\n      \"parse\" in output.schema ? output.schema : z.object(output.schema)\n    ) as z.AnyZodObject | z.ZodString;\n\n    let parsedContent = outputRef.content;\n\n    try {\n      if (typeof parsedContent === \"string\") {\n        if (schema._def.typeName !== \"ZodString\") {\n          parsedContent = JSON.parse(parsedContent.trim());\n        }\n      }\n\n      outputRef.data = schema.parse(parsedContent);\n    } catch (error) {\n      throw new ParsingError(outputRef, error);\n    }\n  }\n\n  if (output.handler) {\n    const response = await Promise.try(\n      output.handler,\n      outputRef.data,\n      {\n        ...state,\n        workingMemory,\n        outputRef,\n      },\n      agent\n    );\n\n    if (Array.isArray(response)) {\n      const refs: OutputRef[] = [];\n      for (const res of response) {\n        const ref: OutputRef = {\n          ...outputRef,\n          id: randomUUIDv7(),\n          processed: res.processed ?? true,\n          ...res,\n        };\n\n        ref.formatted = output.format ? output.format(response) : undefined;\n        refs.push(ref);\n      }\n      return refs;\n    } else if (response) {\n      const ref: OutputRef = {\n        ...outputRef,\n        ...response,\n        processed: response.processed ?? true,\n      };\n\n      ref.formatted = output.format ? output.format(response) : undefined;\n\n      return ref;\n    }\n  }\n\n  return {\n    ...outputRef,\n    formatted: output.format ? output.format(outputRef.data) : undefined,\n    processed: true,\n  };\n}\n\nexport async function prepareContextActions(params: {\n  context: Context;\n  state: ContextState<AnyContext>;\n  workingMemory: WorkingMemory;\n  agent: AnyAgent;\n  agentCtxState: ContextState<AnyContext> | undefined;\n}): Promise<ActionCtxRef[]> {\n  const { context, state } = params;\n  const actions =\n    typeof context.actions === \"function\"\n      ? await Promise.try(context.actions, state)\n      : context.actions;\n\n  return Promise.all(\n    actions.map((action) =>\n      prepareAction({\n        action,\n        ...params,\n      })\n    )\n  ).then((t) => t.filter((t) => !!t));\n}\n\nexport async function prepareAction({\n  action,\n  context,\n  state,\n  workingMemory,\n  agent,\n  agentCtxState,\n}: {\n  action: AnyAction;\n  context: AnyContext;\n  state: ContextState<AnyContext>;\n  workingMemory: WorkingMemory;\n  agent: AnyAgent;\n  agentCtxState: ContextState<AnyContext> | undefined;\n}): Promise<ActionCtxRef | undefined> {\n  if (action.context && action.context.type !== context.type) return undefined;\n\n  let actionMemory: Memory | undefined = undefined;\n\n  if (action.memory) {\n    actionMemory =\n      (await agent.memory.store.get(action.memory.key)) ??\n      action.memory.create();\n  }\n\n  const enabled = action.enabled\n    ? action.enabled({\n        ...state,\n        context,\n        workingMemory,\n        actionMemory,\n        agentMemory: agentCtxState?.memory,\n      })\n    : true;\n\n  if (action.enabled && actionMemory) {\n    await agent.memory.store.set(actionMemory.key, actionMemory);\n  }\n\n  return enabled\n    ? {\n        ...action,\n        ctxId: state.id,\n      }\n    : undefined;\n}\n\nexport async function prepareContext({\n  agent,\n  ctxState,\n  agentCtxState,\n  workingMemory,\n  params,\n}: {\n  agent: AnyAgent;\n  ctxState: ContextState;\n  agentCtxState?: ContextState;\n  workingMemory: WorkingMemory;\n  params?: {\n    outputs?: Record<string, Omit<Output, \"type\">>;\n    inputs?: Record<string, InputConfig>;\n    actions?: AnyAction[];\n    contexts?: ContextRef[];\n  };\n}) {\n  await agentCtxState?.context.loader?.(agentCtxState, agent);\n\n  await ctxState?.context.loader?.(ctxState, agent);\n\n  const inputs: Input[] = Object.entries({\n    ...agent.inputs,\n    ...ctxState.context.inputs,\n    ...(params?.inputs ?? {}),\n  }).map(([type, input]) => ({\n    type,\n    ...input,\n  }));\n\n  const outputs: Output[] = Object.entries({\n    ...agent.outputs,\n    ...ctxState.context.outputs,\n    ...(params?.outputs ?? {}),\n  })\n    .filter(([_, output]) =>\n      output.enabled\n        ? output.enabled({\n            ...ctxState,\n            workingMemory,\n          })\n        : true\n    )\n    .map(([type, output]) => ({\n      type,\n      ...output,\n    }));\n\n  const actions = await Promise.all(\n    [agent.actions, params?.actions]\n      .filter((t) => !!t)\n      .flat()\n      .map((action: AnyAction) =>\n        prepareAction({\n          action,\n          agent,\n          agentCtxState,\n          context: ctxState.context,\n          state: ctxState,\n          workingMemory,\n        })\n      )\n  ).then((r) => r.filter((a) => !!a));\n\n  const ctxActions = await prepareContextActions({\n    agent,\n    agentCtxState,\n    context: ctxState.context,\n    state: ctxState,\n    workingMemory,\n  });\n\n  actions.push(...ctxActions);\n\n  const subCtxsStates = await Promise.all([\n    ...(ctxState?.contexts ?? []).map((ref) => agent.getContextById(ref)),\n    ...(params?.contexts ?? []).map((ref) => agent.getContext(ref)),\n  ]).then((res) => res.filter((r) => !!r));\n\n  await Promise.all(\n    subCtxsStates.map((state) => state.context.loader?.(state, agent))\n  );\n\n  const subCtxsStatesInputs: Input[] = subCtxsStates\n    .map((state) => Object.entries(state.context.inputs))\n    .flat()\n    .map(([type, input]) => ({\n      type,\n      ...input,\n    }));\n\n  inputs.push(...subCtxsStatesInputs);\n\n  const subCtxsStatesOutputs: Output[] = subCtxsStates\n    .map((state) => Object.entries(state.context.outputs))\n    .flat()\n    .map(([type, output]) => ({\n      type,\n      ...output,\n    }));\n\n  outputs.push(...subCtxsStatesOutputs);\n\n  const subCtxsActions = await Promise.all(\n    subCtxsStates.map((state) =>\n      prepareContextActions({\n        agent,\n        agentCtxState,\n        context: state.context,\n        state: state,\n        workingMemory,\n      })\n    )\n  );\n\n  actions.push(...subCtxsActions.flat());\n\n  const contexts = [agentCtxState, ctxState, ...subCtxsStates].filter(\n    (t) => !!t\n  );\n\n  return {\n    contexts,\n    outputs,\n    actions,\n    inputs,\n  };\n}\n\nexport async function handleInput({\n  inputs,\n  inputRef,\n  logger,\n  ctxState,\n  workingMemory,\n  agent,\n}: {\n  inputs: Record<string, InputConfig>;\n  inputRef: InputRef;\n  logger: Logger;\n  workingMemory: WorkingMemory;\n  ctxState: ContextState;\n  agent: AnyAgent;\n}) {\n  const input = inputs[inputRef.type];\n\n  if (!input) {\n    throw new NotFoundError(inputRef);\n  }\n\n  try {\n    if (input.schema) {\n      const schema = (\n        \"parse\" in input.schema ? input.schema : z.object(input.schema)\n      ) as z.AnyZodObject | z.ZodString;\n      inputRef.data = schema.parse(inputRef.content);\n    } else {\n      inputRef.data = z.string().parse(inputRef.content);\n    }\n  } catch (error) {\n    throw new ParsingError(inputRef, error);\n  }\n\n  logger.debug(\"agent:send\", \"Querying episodic memory\");\n\n  const episodicMemory = await agent.memory.vector.query(\n    `${ctxState.id}`,\n    JSON.stringify(inputRef.data)\n  );\n\n  logger.trace(\"agent:send\", \"Episodic memory retrieved\", {\n    episodesCount: episodicMemory.length,\n  });\n\n  workingMemory.episodicMemory = {\n    episodes: episodicMemory,\n  };\n\n  if (input.handler) {\n    logger.debug(\"agent:send\", \"Using custom input handler\", {\n      type: inputRef.type,\n    });\n\n    const { data, params } = await Promise.try(\n      input.handler,\n      inputRef.data,\n      {\n        ...ctxState,\n        workingMemory,\n      },\n      agent\n    );\n\n    inputRef.data = data;\n\n    if (params) {\n      inputRef.params = {\n        ...inputRef.params,\n        ...params,\n      };\n    }\n  }\n\n  inputRef.formatted = input.format ? input.format(inputRef) : undefined;\n}\n","import { generateObject } from \"ai\";\nimport { openai } from \"@ai-sdk/openai\";\nimport type {\n  AnyAgent,\n  Episode,\n  ActionResult,\n  Action,\n  Thought,\n  ActionCall,\n  AnyAction,\n} from \"../types\";\nimport { z } from \"zod\";\nimport { v7 as randomUUIDv7 } from \"uuid\";\n\n// Check if we're in a browser environment\nconst isBrowser =\n  typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\n// Conditionally import Node.js modules\nlet fs: any;\nlet path: any;\n\nif (!isBrowser) {\n  // Only import in Node.js environment\n  // Using dynamic import to avoid browser errors\n  try {\n    fs = require(\"fs\");\n    path = require(\"path\");\n  } catch (e) {\n    console.warn(\"File system modules not available in this environment\");\n  }\n}\n\nexport const generateEpisodicMemory = async (\n  agent: AnyAgent,\n  thoughts: Thought[],\n  actions: Action[],\n  results: ActionResult[]\n): Promise<{\n  observation: string;\n  thoughts: string;\n  result: string;\n}> => {\n  const extractEpisode = await generateObject({\n    model: agent.memory.vectorModel || openai(\"gpt-4-turbo\"),\n    schema: z.object({\n      observation: z.string().describe(\"The context and setup - what happened\"),\n      thoughts: z\n        .string()\n        .describe(\n          \"Internal reasoning process and observations of the agent in the episode that let it arrive at the correct action and result. 'I ...'\"\n        ),\n      result: z\n        .string()\n        .describe(\n          \"Outcome and retrospective. What did you do well? What could you do better next time? I ...\"\n        ),\n    }),\n    prompt: `\n    You are creating an episodic memory for an AI agent to help it recall and learn from past experiences.\n    \n    Your task is to analyze the agent's thoughts, actions, and the results of those actions to create a structured memory that can be used for future reference and learning.\n\n    ## Context\n    <thoughts>\n    ${JSON.stringify(thoughts)}\n    </thoughts>\n\n    ## Actions Taken\n    <actions>\n    ${JSON.stringify(actions)}\n    </actions>\n\n    ## Results & Outcomes\n    <results>\n    ${JSON.stringify(results)}\n    </results>\n    \n    ## Instructions\n    Create a comprehensive episodic memory with these components:\n    \n    1. OBSERVATION: Provide a clear, concise description of the situation, context, and key elements. Include:\n       - What was the environment or scenario?\n       - What was the agent trying to accomplish?\n       - What were the initial conditions or constraints?\n    \n    2. THOUGHTS: Capture the agent's internal reasoning process that led to its actions:\n       - What was the agent's understanding of the situation?\n       - What strategies or approaches did it consider?\n       - What key insights or realizations occurred during the process?\n       - Use first-person perspective (\"I realized...\", \"I considered...\")\n    \n    3. RESULT: Summarize the outcomes and provide a retrospective analysis:\n       - What was accomplished or not accomplished?\n       - What worked well and what didn't?\n       - What lessons can be learned for future similar situations?\n       - What would be done differently next time?\n       - Use first-person perspective (\"I succeeded in...\", \"Next time I would...\")\n    \n    Make the memory detailed enough to be useful for future recall, but concise enough to be quickly processed. Focus on capturing the essence of the experience, key decision points, and lessons learned.`,\n  });\n\n  return {\n    observation: extractEpisode.object.observation,\n    thoughts: extractEpisode.object.thoughts,\n    result: extractEpisode.object.result,\n  };\n};\n\n/**\n * Creates a training data pair from episodic memory\n * @param episodicMemory The episodic memory generated\n * @returns A prompt-completion pair for training data\n */\nexport function createTrainingDataPair(episodicMemory: {\n  observation: string;\n  thoughts: string;\n  result: string;\n}): {\n  prompt: string;\n  completion: string;\n} {\n  // Create a simple prompt with the observation\n  const prompt = episodicMemory.observation;\n\n  // Create a simple completion with thoughts and result\n  const completion = `${episodicMemory.thoughts}\\n\\n${episodicMemory.result}`;\n\n  return {\n    prompt,\n    completion,\n  };\n}\n\n/**\n * Saves training data to a JSON lines file\n * @param trainingData Array of prompt-completion pairs\n * @param filePath Path to save the file\n */\nexport async function saveTrainingData(\n  trainingData: Array<{ prompt: string; completion: string }>,\n  filePath: string\n): Promise<void> {\n  // Skip in browser environment\n  if (isBrowser) {\n    console.warn(\"saveTrainingData is not supported in browser environments\");\n    return;\n  }\n\n  try {\n    // Ensure fs is available\n    if (!fs) {\n      console.warn(\"File system module not available\");\n      return;\n    }\n\n    // Ensure directory exists\n    const dir = path.dirname(filePath);\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true });\n    }\n\n    // Convert each object to a JSON string and join with newlines\n    const jsonLines = trainingData\n      .map((item) => JSON.stringify(item))\n      .join(\"\\n\");\n\n    // Write to file\n    fs.writeFileSync(filePath, jsonLines, \"utf8\");\n  } catch (error) {\n    console.error(\"Error saving training data:\", error);\n    throw error;\n  }\n}\n\n/**\n * Creates an episode from working memory components\n * @param thoughts The thoughts that led to the actions\n * @param actions The actions taken\n * @param results The results of the actions\n * @param agent The agent that generated the episode\n * @param options Optional configuration for exporting training data\n * @param options.exportTrainingData Whether to export this episode as training data\n * @param options.trainingDataPath Path to save the training data\n * @returns A new Episode object\n */\nexport async function createEpisodeFromWorkingMemory(\n  thoughts: Thought[],\n  actions: Action[],\n  results: ActionResult[],\n  agent: AnyAgent,\n  options?: {\n    exportTrainingData?: boolean;\n    trainingDataPath?: string;\n  }\n): Promise<Episode> {\n  const episodicMemory = await generateEpisodicMemory(\n    agent,\n    thoughts,\n    actions,\n    results\n  );\n\n  // If exportTrainingData is true and not in browser, create and save training data\n  if (options?.exportTrainingData && !isBrowser && fs) {\n    const trainingDataPair = createTrainingDataPair(episodicMemory);\n\n    // Default path if not provided\n    const filePath = options.trainingDataPath || \"./training-data.jsonl\";\n\n    // Check if file exists to append or create new\n    let existingData: Array<{ prompt: string; completion: string }> = [];\n    if (fs.existsSync(filePath)) {\n      const fileContent = fs.readFileSync(filePath, \"utf8\");\n      existingData = fileContent\n        .split(\"\\n\")\n        .filter((line: string) => line.trim() !== \"\")\n        .map((line: string) => JSON.parse(line));\n    }\n\n    // Add new training data pair\n    existingData.push(trainingDataPair);\n\n    // Save updated training data\n    await saveTrainingData(existingData, filePath);\n  }\n\n  return {\n    id: randomUUIDv7(),\n    timestamp: Date.now(),\n    observation: episodicMemory.observation,\n    result: episodicMemory.result,\n    thoughts: episodicMemory.thoughts,\n  };\n}\n\n/**\n * Exports all episodes as training data\n * @param episodes Array of episodes to export\n * @param filePath Path to save the training data\n */\nexport async function exportEpisodesAsTrainingData(\n  episodes: Episode[],\n  filePath: string = \"./training-data.jsonl\"\n): Promise<void> {\n  // Skip in browser environment\n  if (isBrowser) {\n    console.warn(\n      \"exportEpisodesAsTrainingData is not supported in browser environments\"\n    );\n    return;\n  }\n\n  // Ensure fs is available\n  if (!fs) {\n    console.warn(\"File system module not available\");\n    return;\n  }\n\n  const trainingData = episodes.map((episode) => ({\n    prompt: episode.observation,\n    completion: `${episode.thoughts}\\n\\n${episode.result}`,\n  }));\n\n  await saveTrainingData(trainingData, filePath);\n}\n\nexport async function generateEpisode(\n  thought: Thought,\n  actionCall: ActionCall,\n  result: ActionResult,\n  agent: AnyAgent,\n  contextId: string,\n  actions: AnyAction[]\n) {\n  // Find the corresponding Action for the ActionCall\n  const action = actions.find((a) => a.name === actionCall.name);\n\n  if (!action) {\n    return;\n  }\n\n  const thoughts = [thought];\n  const actionsArray = [action];\n  const results = [result];\n\n  const episode = await createEpisodeFromWorkingMemory(\n    thoughts,\n    actionsArray,\n    results,\n    agent,\n    {\n      exportTrainingData: agent.exportTrainingData === true,\n      trainingDataPath: agent.trainingDataPath || \"./training-data.jsonl\",\n    }\n  );\n\n  await agent.memory.vector.upsert(`${contextId}`, [\n    {\n      id: episode.id,\n      text: episode.observation,\n      metadata: episode,\n    },\n  ]);\n}\n","export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n","/**\n * Converts an AsyncIterator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncIterator.\n * @param { <T>} iterator - The AsyncIterator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncIterator.\n */\nexport function convertAsyncIteratorToReadableStream<T>(\n  iterator: AsyncIterator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n","/**\n * Creates a Promise that resolves after a specified delay\n * @param delayInMs - The delay duration in milliseconds. If null or undefined, resolves immediately.\n * @returns A Promise that resolves after the specified delay\n */\nexport async function delay(delayInMs?: number | null): Promise<void> {\n  return delayInMs == null\n    ? Promise.resolve()\n    : new Promise(resolve => setTimeout(resolve, delayInMs));\n}\n","export type EventSourceChunk = {\n  event: string | undefined;\n  data: string;\n  id?: string;\n  retry?: number;\n};\n\nexport function createEventSourceParserStream() {\n  let buffer = '';\n  let event: string | undefined = undefined;\n  let data: string[] = [];\n  let lastEventId: string | undefined = undefined;\n  let retry: number | undefined = undefined;\n\n  function parseLine(\n    line: string,\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    // Empty line means dispatch the event\n    if (line === '') {\n      dispatchEvent(controller);\n      return;\n    }\n\n    // Comments start with colon\n    if (line.startsWith(':')) {\n      return;\n    }\n\n    // Field parsing\n    const colonIndex = line.indexOf(':');\n    if (colonIndex === -1) {\n      // field with no value\n      handleField(line, '');\n      return;\n    }\n\n    const field = line.slice(0, colonIndex);\n    // If there's a space after the colon, it should be ignored\n    const valueStart = colonIndex + 1;\n    const value =\n      valueStart < line.length && line[valueStart] === ' '\n        ? line.slice(valueStart + 1)\n        : line.slice(valueStart);\n\n    handleField(field, value);\n  }\n\n  function dispatchEvent(\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join('\\n'),\n        id: lastEventId,\n        retry,\n      });\n\n      // Reset data but keep lastEventId as per spec\n      data = [];\n      event = undefined;\n      retry = undefined;\n    }\n  }\n\n  function handleField(field: string, value: string) {\n    switch (field) {\n      case 'event':\n        event = value;\n        break;\n      case 'data':\n        data.push(value);\n        break;\n      case 'id':\n        lastEventId = value;\n        break;\n      case 'retry':\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n\n  return new TransformStream<string, EventSourceChunk>({\n    transform(chunk, controller) {\n      const { lines, incompleteLine } = splitLines(buffer, chunk);\n\n      buffer = incompleteLine;\n\n      // using for loop for performance\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    },\n  });\n}\n\n// performance: send in already scanned buffer separately, do not scan again\nfunction splitLines(buffer: string, chunk: string) {\n  const lines: Array<string> = [];\n  let currentLine = buffer;\n\n  // using for loop for performance\n  for (let i = 0; i < chunk.length; ) {\n    const char = chunk[i++];\n\n    // order is performance-optimized\n    if (char === '\\n') {\n      // Standalone LF\n      lines.push(currentLine);\n      currentLine = '';\n    } else if (char === '\\r') {\n      lines.push(currentLine);\n      currentLine = '';\n\n      if (chunk[i + 1] === '\\n') {\n        i++; // CRLF case: Skip the LF character\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n\n  return { lines, incompleteLine: currentLine };\n}\n","/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { customAlphabet } from 'nanoid/non-secure';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNon-secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Default: ''.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\n// TODO 5.0 breaking change: change the return type to IDGenerator\nexport const createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return size => `${prefix}${separator}${generator(size)}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IDGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs. Not secure.\n\n@param size - The size of the ID to generate. Default: 16.\n */\nexport const generateId = createIdGenerator();\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { FetchFunction } from './fetch-function';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\nimport { isAbortError } from './is-abort-error';\nimport { extractResponseHeaders } from './extract-response-headers';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const getFromApi = async <T>({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {},\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {},\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {},\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {},\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n      if (cause != null) {\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {},\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","/**\n * Removes entries from a record where the value is null or undefined.\n * @param record - The input object whose entries may be null or undefined.\n * @returns A new object containing only entries with non-null and non-undefined values.\n */\nexport function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n","export function isAbortError(error: unknown): error is Error {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n","import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n","/**\n * Loads an optional `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @returns The setting value.\n */\nexport function loadOptionalSetting({\n  settingValue,\n  environmentVariableName,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n}): string | undefined {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null || typeof process === 'undefined') {\n    return undefined;\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null || typeof settingValue !== 'string') {\n    return undefined;\n  }\n\n  return settingValue;\n}\n","import { LoadSettingError } from '@ai-sdk/provider';\n\n/**\n * Loads a `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @param settingName - The setting name.\n * @param description - The description of the setting.\n * @returns The setting value.\n */\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter. ` +\n        `Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter ` +\n        `or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting must be a string. ` +\n        `The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): ParseResult<T> {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    const validationResult = safeValidateTypes({ value, schema });\n\n    return validationResult.success\n      ? { ...validationResult, rawValue: value }\n      : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n","import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from './validate-types';\nimport { z } from 'zod';\n\nexport function parseProviderOptions<T>({\n  provider,\n  providerOptions,\n  schema,\n}: {\n  provider: string;\n  providerOptions: Record<string, unknown> | undefined;\n  schema: z.ZodSchema<T>;\n}): T | undefined {\n  if (providerOptions?.[provider] == null) {\n    return undefined;\n  }\n\n  const parsedProviderOptions = safeValidateTypes({\n    value: providerOptions[provider],\n    schema,\n  });\n\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError({\n      argument: 'providerOptions',\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error,\n    });\n  }\n\n  return parsedProviderOptions.value;\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { isAbortError } from './is-abort-error';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","export type Resolvable<T> =\n  | T // Raw value\n  | Promise<T> // Promise of value\n  | (() => T) // Function returning value\n  | (() => Promise<T>); // Function returning promise of value\n\n/**\n * Resolves a value that could be a raw value, a Promise, a function returning a value,\n * or a function returning a Promise.\n */\nexport async function resolve<T>(value: Resolvable<T>): Promise<T> {\n  // If it's a function, call it to get the value/promise\n  if (typeof value === 'function') {\n    value = (value as Function)();\n  }\n\n  // Otherwise just resolve whatever we got (value or promise)\n  return Promise.resolve(value as T);\n}\n","import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport { ZodSchema } from 'zod';\nimport {\n  createEventSourceParserStream,\n  EventSourceChunk,\n} from './event-source-parser-stream';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { parseJSON, ParseResult, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  rawValue?: unknown;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(createEventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<EventSourceChunk, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n      rawValue: parsedResult.rawValue,\n    };\n  };\n\nexport const createBinaryResponseHandler =\n  (): ResponseHandler<Uint8Array> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.body) {\n      throw new APICallError({\n        message: 'Response body is empty',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n      });\n    }\n\n    try {\n      const buffer = await response.arrayBuffer();\n      return {\n        responseHeaders,\n        value: new Uint8Array(buffer),\n      };\n    } catch (error) {\n      throw new APICallError({\n        message: 'Failed to read response as array buffer',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n        cause: error,\n      });\n    }\n  };\n\nexport const createStatusCodeErrorResponseHandler =\n  (): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n    const responseBody = await response.text();\n\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues: requestBodyValues as Record<string, unknown>,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n      }),\n    };\n  };\n","// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n","export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n","// This alphabet uses `A-Za-z0-9_-` symbols.\n// The order of characters is optimized for better gzip and brotli compression.\n// References to the same file (works both for gzip and brotli):\n// `'use`, `andom`, and `rict'`\n// References to the brotli default dictionary:\n// `-26T`, `1983`, `40px`, `75px`, `bush`, `jack`, `mind`, `very`, and `wolf`\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    // A compact alternative for `for (var i = 0; i < step; i++)`.\n    let i = size | 0\n    while (i--) {\n      // `| 0` is more compact and faster than `Math.floor()`.\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\n\nlet nanoid = (size = 21) => {\n  let id = ''\n  // A compact alternative for `for (var i = 0; i < step; i++)`.\n  let i = size | 0\n  while (i--) {\n    // `| 0` is more compact and faster than `Math.floor()`.\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n\nexport { nanoid, customAlphabet }\n","import {\n  EmbeddingModelV1,\n  ImageModelV1,\n  LanguageModelV1,\n  ProviderV1,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  loadApiKey,\n  withoutTrailingSlash,\n} from '@ai-sdk/provider-utils';\nimport { OpenAIChatLanguageModel } from './openai-chat-language-model';\nimport { OpenAIChatModelId, OpenAIChatSettings } from './openai-chat-settings';\nimport { OpenAICompletionLanguageModel } from './openai-completion-language-model';\nimport {\n  OpenAICompletionModelId,\n  OpenAICompletionSettings,\n} from './openai-completion-settings';\nimport { OpenAIEmbeddingModel } from './openai-embedding-model';\nimport {\n  OpenAIEmbeddingModelId,\n  OpenAIEmbeddingSettings,\n} from './openai-embedding-settings';\nimport { OpenAIImageModel } from './openai-image-model';\nimport {\n  OpenAIImageModelId,\n  OpenAIImageSettings,\n} from './openai-image-settings';\nimport { OpenAIResponsesLanguageModel } from './responses/openai-responses-language-model';\nimport { OpenAIResponsesModelId } from './responses/openai-responses-settings';\nimport { openaiTools } from './openai-tools';\n\nexport interface OpenAIProvider extends ProviderV1 {\n  (\n    modelId: 'gpt-3.5-turbo-instruct',\n    settings?: OpenAICompletionSettings,\n  ): OpenAICompletionLanguageModel;\n  (modelId: OpenAIChatModelId, settings?: OpenAIChatSettings): LanguageModelV1;\n\n  /**\nCreates an OpenAI model for text generation.\n   */\n  languageModel(\n    modelId: 'gpt-3.5-turbo-instruct',\n    settings?: OpenAICompletionSettings,\n  ): OpenAICompletionLanguageModel;\n  languageModel(\n    modelId: OpenAIChatModelId,\n    settings?: OpenAIChatSettings,\n  ): LanguageModelV1;\n\n  /**\nCreates an OpenAI chat model for text generation.\n   */\n  chat(\n    modelId: OpenAIChatModelId,\n    settings?: OpenAIChatSettings,\n  ): LanguageModelV1;\n\n  /**\nCreates an OpenAI responses API model for text generation.\n   */\n  responses(modelId: OpenAIResponsesModelId): LanguageModelV1;\n\n  /**\nCreates an OpenAI completion model for text generation.\n   */\n  completion(\n    modelId: OpenAICompletionModelId,\n    settings?: OpenAICompletionSettings,\n  ): LanguageModelV1;\n\n  /**\nCreates a model for text embeddings.\n   */\n  embedding(\n    modelId: OpenAIEmbeddingModelId,\n    settings?: OpenAIEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  /**\nCreates a model for text embeddings.\n\n@deprecated Use `textEmbeddingModel` instead.\n   */\n  textEmbedding(\n    modelId: OpenAIEmbeddingModelId,\n    settings?: OpenAIEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  /**\nCreates a model for text embeddings.\n   */\n  textEmbeddingModel(\n    modelId: OpenAIEmbeddingModelId,\n    settings?: OpenAIEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  /**\nCreates a model for image generation.\n   */\n  image(\n    modelId: OpenAIImageModelId,\n    settings?: OpenAIImageSettings,\n  ): ImageModelV1;\n\n  /**\nCreates a model for image generation.\n   */\n  imageModel(\n    modelId: OpenAIImageModelId,\n    settings?: OpenAIImageSettings,\n  ): ImageModelV1;\n\n  /**\nOpenAI-specific tools.\n   */\n  tools: typeof openaiTools;\n}\n\nexport interface OpenAIProviderSettings {\n  /**\nBase URL for the OpenAI API calls.\n     */\n  baseURL?: string;\n\n  /**\nAPI key for authenticating requests.\n     */\n  apiKey?: string;\n\n  /**\nOpenAI Organization.\n     */\n  organization?: string;\n\n  /**\nOpenAI project.\n     */\n  project?: string;\n\n  /**\nCustom headers to include in the requests.\n     */\n  headers?: Record<string, string>;\n\n  /**\nOpenAI compatibility mode. Should be set to `strict` when using the OpenAI API,\nand `compatible` when using 3rd party providers. In `compatible` mode, newer\ninformation such as streamOptions are not being sent. Defaults to 'compatible'.\n   */\n  compatibility?: 'strict' | 'compatible';\n\n  /**\nProvider name. Overrides the `openai` default name for 3rd party providers.\n   */\n  name?: string;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n    */\n  fetch?: FetchFunction;\n}\n\n/**\nCreate an OpenAI provider instance.\n */\nexport function createOpenAI(\n  options: OpenAIProviderSettings = {},\n): OpenAIProvider {\n  const baseURL =\n    withoutTrailingSlash(options.baseURL) ?? 'https://api.openai.com/v1';\n\n  // we default to compatible, because strict breaks providers like Groq:\n  const compatibility = options.compatibility ?? 'compatible';\n\n  const providerName = options.name ?? 'openai';\n\n  const getHeaders = () => ({\n    Authorization: `Bearer ${loadApiKey({\n      apiKey: options.apiKey,\n      environmentVariableName: 'OPENAI_API_KEY',\n      description: 'OpenAI',\n    })}`,\n    'OpenAI-Organization': options.organization,\n    'OpenAI-Project': options.project,\n    ...options.headers,\n  });\n\n  const createChatModel = (\n    modelId: OpenAIChatModelId,\n    settings: OpenAIChatSettings = {},\n  ) =>\n    new OpenAIChatLanguageModel(modelId, settings, {\n      provider: `${providerName}.chat`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      compatibility,\n      fetch: options.fetch,\n    });\n\n  const createCompletionModel = (\n    modelId: OpenAICompletionModelId,\n    settings: OpenAICompletionSettings = {},\n  ) =>\n    new OpenAICompletionLanguageModel(modelId, settings, {\n      provider: `${providerName}.completion`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      compatibility,\n      fetch: options.fetch,\n    });\n\n  const createEmbeddingModel = (\n    modelId: OpenAIEmbeddingModelId,\n    settings: OpenAIEmbeddingSettings = {},\n  ) =>\n    new OpenAIEmbeddingModel(modelId, settings, {\n      provider: `${providerName}.embedding`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const createImageModel = (\n    modelId: OpenAIImageModelId,\n    settings: OpenAIImageSettings = {},\n  ) =>\n    new OpenAIImageModel(modelId, settings, {\n      provider: `${providerName}.image`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const createLanguageModel = (\n    modelId: OpenAIChatModelId | OpenAICompletionModelId,\n    settings?: OpenAIChatSettings | OpenAICompletionSettings,\n  ) => {\n    if (new.target) {\n      throw new Error(\n        'The OpenAI model function cannot be called with the new keyword.',\n      );\n    }\n\n    if (modelId === 'gpt-3.5-turbo-instruct') {\n      return createCompletionModel(\n        modelId,\n        settings as OpenAICompletionSettings,\n      );\n    }\n\n    return createChatModel(modelId, settings as OpenAIChatSettings);\n  };\n\n  const createResponsesModel = (modelId: OpenAIResponsesModelId) => {\n    return new OpenAIResponsesLanguageModel(modelId, {\n      provider: `${providerName}.responses`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n  };\n\n  const provider = function (\n    modelId: OpenAIChatModelId | OpenAICompletionModelId,\n    settings?: OpenAIChatSettings | OpenAICompletionSettings,\n  ) {\n    return createLanguageModel(modelId, settings);\n  };\n\n  provider.languageModel = createLanguageModel;\n  provider.chat = createChatModel;\n  provider.completion = createCompletionModel;\n  provider.responses = createResponsesModel;\n  provider.embedding = createEmbeddingModel;\n  provider.textEmbedding = createEmbeddingModel;\n  provider.textEmbeddingModel = createEmbeddingModel;\n\n  provider.image = createImageModel;\n  provider.imageModel = createImageModel;\n\n  provider.tools = openaiTools;\n\n  return provider as OpenAIProvider;\n}\n\n/**\nDefault OpenAI provider instance. It uses 'strict' compatibility mode.\n */\nexport const openai = createOpenAI({\n  compatibility: 'strict', // strict for OpenAI API\n});\n","import {\n  InvalidResponseDataError,\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1LogProbs,\n  LanguageModelV1ProviderMetadata,\n  LanguageModelV1StreamPart,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  ParseResult,\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  generateId,\n  isParsableJson,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { convertToOpenAIChatMessages } from './convert-to-openai-chat-messages';\nimport { mapOpenAIChatLogProbsOutput } from './map-openai-chat-logprobs';\nimport { mapOpenAIFinishReason } from './map-openai-finish-reason';\nimport { OpenAIChatModelId, OpenAIChatSettings } from './openai-chat-settings';\nimport {\n  openaiErrorDataSchema,\n  openaiFailedResponseHandler,\n} from './openai-error';\nimport { getResponseMetadata } from './get-response-metadata';\nimport { prepareTools } from './openai-prepare-tools';\n\ntype OpenAIChatConfig = {\n  provider: string;\n  compatibility: 'strict' | 'compatible';\n  headers: () => Record<string, string | undefined>;\n  url: (options: { modelId: string; path: string }) => string;\n  fetch?: FetchFunction;\n};\n\nexport class OpenAIChatLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n\n  readonly modelId: OpenAIChatModelId;\n  readonly settings: OpenAIChatSettings;\n\n  private readonly config: OpenAIChatConfig;\n\n  constructor(\n    modelId: OpenAIChatModelId,\n    settings: OpenAIChatSettings,\n    config: OpenAIChatConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  get supportsStructuredOutputs(): boolean {\n    // enable structured outputs for reasoning models by default:\n    // TODO in the next major version, remove this and always use json mode for models\n    // that support structured outputs (blacklist other models)\n    return this.settings.structuredOutputs ?? isReasoningModel(this.modelId);\n  }\n\n  get defaultObjectGenerationMode() {\n    // audio models don't support structured outputs:\n    if (isAudioModel(this.modelId)) {\n      return 'tool';\n    }\n\n    return this.supportsStructuredOutputs ? 'json' : 'tool';\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  get supportsImageUrls(): boolean {\n    // image urls can be sent if downloadImages is disabled (default):\n    return !this.settings.downloadImages;\n  }\n\n  private getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    providerMetadata,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const type = mode.type;\n\n    const warnings: LanguageModelV1CallWarning[] = [];\n\n    if (topK != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'topK',\n      });\n    }\n\n    if (\n      responseFormat?.type === 'json' &&\n      responseFormat.schema != null &&\n      !this.supportsStructuredOutputs\n    ) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'responseFormat',\n        details:\n          'JSON response format schema is only supported with structuredOutputs',\n      });\n    }\n\n    const useLegacyFunctionCalling = this.settings.useLegacyFunctionCalling;\n\n    if (useLegacyFunctionCalling && this.settings.parallelToolCalls === true) {\n      throw new UnsupportedFunctionalityError({\n        functionality: 'useLegacyFunctionCalling with parallelToolCalls',\n      });\n    }\n\n    if (useLegacyFunctionCalling && this.supportsStructuredOutputs) {\n      throw new UnsupportedFunctionalityError({\n        functionality: 'structuredOutputs with useLegacyFunctionCalling',\n      });\n    }\n\n    const { messages, warnings: messageWarnings } = convertToOpenAIChatMessages(\n      {\n        prompt,\n        useLegacyFunctionCalling,\n        systemMessageMode: getSystemMessageMode(this.modelId),\n      },\n    );\n\n    warnings.push(...messageWarnings);\n\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n\n      // model specific settings:\n      logit_bias: this.settings.logitBias,\n      logprobs:\n        this.settings.logprobs === true ||\n        typeof this.settings.logprobs === 'number'\n          ? true\n          : undefined,\n      top_logprobs:\n        typeof this.settings.logprobs === 'number'\n          ? this.settings.logprobs\n          : typeof this.settings.logprobs === 'boolean'\n            ? this.settings.logprobs\n              ? 0\n              : undefined\n            : undefined,\n      user: this.settings.user,\n      parallel_tool_calls: this.settings.parallelToolCalls,\n\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      response_format:\n        responseFormat?.type === 'json'\n          ? this.supportsStructuredOutputs && responseFormat.schema != null\n            ? {\n                type: 'json_schema',\n                json_schema: {\n                  schema: responseFormat.schema,\n                  strict: true,\n                  name: responseFormat.name ?? 'response',\n                  description: responseFormat.description,\n                },\n              }\n            : { type: 'json_object' }\n          : undefined,\n      stop: stopSequences,\n      seed,\n\n      // openai specific settings:\n      // TODO remove in next major version; we auto-map maxTokens now\n      max_completion_tokens: providerMetadata?.openai?.maxCompletionTokens,\n      store: providerMetadata?.openai?.store,\n      metadata: providerMetadata?.openai?.metadata,\n      prediction: providerMetadata?.openai?.prediction,\n      reasoning_effort:\n        providerMetadata?.openai?.reasoningEffort ??\n        this.settings.reasoningEffort,\n\n      // messages:\n      messages,\n    };\n\n    if (isReasoningModel(this.modelId)) {\n      // remove unsupported settings for reasoning models\n      // see https://platform.openai.com/docs/guides/reasoning#limitations\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'temperature',\n          details: 'temperature is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.top_p != null) {\n        baseArgs.top_p = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'topP',\n          details: 'topP is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.frequency_penalty != null) {\n        baseArgs.frequency_penalty = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'frequencyPenalty',\n          details: 'frequencyPenalty is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.presence_penalty != null) {\n        baseArgs.presence_penalty = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'presencePenalty',\n          details: 'presencePenalty is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.logit_bias != null) {\n        baseArgs.logit_bias = undefined;\n        warnings.push({\n          type: 'other',\n          message: 'logitBias is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.logprobs != null) {\n        baseArgs.logprobs = undefined;\n        warnings.push({\n          type: 'other',\n          message: 'logprobs is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.top_logprobs != null) {\n        baseArgs.top_logprobs = undefined;\n        warnings.push({\n          type: 'other',\n          message: 'topLogprobs is not supported for reasoning models',\n        });\n      }\n\n      // reasoning models use max_completion_tokens instead of max_tokens:\n      if (baseArgs.max_tokens != null) {\n        if (baseArgs.max_completion_tokens == null) {\n          baseArgs.max_completion_tokens = baseArgs.max_tokens;\n        }\n        baseArgs.max_tokens = undefined;\n      }\n    }\n\n    switch (type) {\n      case 'regular': {\n        const { tools, tool_choice, functions, function_call, toolWarnings } =\n          prepareTools({\n            mode,\n            useLegacyFunctionCalling,\n            structuredOutputs: this.supportsStructuredOutputs,\n          });\n\n        return {\n          args: {\n            ...baseArgs,\n            tools,\n            tool_choice,\n            functions,\n            function_call,\n          },\n          warnings: [...warnings, ...toolWarnings],\n        };\n      }\n\n      case 'object-json': {\n        return {\n          args: {\n            ...baseArgs,\n            response_format:\n              this.supportsStructuredOutputs && mode.schema != null\n                ? {\n                    type: 'json_schema',\n                    json_schema: {\n                      schema: mode.schema,\n                      strict: true,\n                      name: mode.name ?? 'response',\n                      description: mode.description,\n                    },\n                  }\n                : { type: 'json_object' },\n          },\n          warnings,\n        };\n      }\n\n      case 'object-tool': {\n        return {\n          args: useLegacyFunctionCalling\n            ? {\n                ...baseArgs,\n                function_call: {\n                  name: mode.tool.name,\n                },\n                functions: [\n                  {\n                    name: mode.tool.name,\n                    description: mode.tool.description,\n                    parameters: mode.tool.parameters,\n                  },\n                ],\n              }\n            : {\n                ...baseArgs,\n                tool_choice: {\n                  type: 'function',\n                  function: { name: mode.tool.name },\n                },\n                tools: [\n                  {\n                    type: 'function',\n                    function: {\n                      name: mode.tool.name,\n                      description: mode.tool.description,\n                      parameters: mode.tool.parameters,\n                      strict: this.supportsStructuredOutputs ? true : undefined,\n                    },\n                  },\n                ],\n              },\n          warnings,\n        };\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { args: body, warnings } = this.getArgs(options);\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: this.config.url({\n        path: '/chat/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiChatResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages: rawPrompt, ...rawSettings } = body;\n    const choice = response.choices[0];\n\n    // provider metadata:\n    const completionTokenDetails = response.usage?.completion_tokens_details;\n    const promptTokenDetails = response.usage?.prompt_tokens_details;\n    const providerMetadata: LanguageModelV1ProviderMetadata = { openai: {} };\n    if (completionTokenDetails?.reasoning_tokens != null) {\n      providerMetadata.openai.reasoningTokens =\n        completionTokenDetails?.reasoning_tokens;\n    }\n    if (completionTokenDetails?.accepted_prediction_tokens != null) {\n      providerMetadata.openai.acceptedPredictionTokens =\n        completionTokenDetails?.accepted_prediction_tokens;\n    }\n    if (completionTokenDetails?.rejected_prediction_tokens != null) {\n      providerMetadata.openai.rejectedPredictionTokens =\n        completionTokenDetails?.rejected_prediction_tokens;\n    }\n    if (promptTokenDetails?.cached_tokens != null) {\n      providerMetadata.openai.cachedPromptTokens =\n        promptTokenDetails?.cached_tokens;\n    }\n\n    return {\n      text: choice.message.content ?? undefined,\n      toolCalls:\n        this.settings.useLegacyFunctionCalling && choice.message.function_call\n          ? [\n              {\n                toolCallType: 'function',\n                toolCallId: generateId(),\n                toolName: choice.message.function_call.name,\n                args: choice.message.function_call.arguments,\n              },\n            ]\n          : choice.message.tool_calls?.map(toolCall => ({\n              toolCallType: 'function',\n              toolCallId: toolCall.id ?? generateId(),\n              toolName: toolCall.function.name,\n              args: toolCall.function.arguments!,\n            })),\n      finishReason: mapOpenAIFinishReason(choice.finish_reason),\n      usage: {\n        promptTokens: response.usage?.prompt_tokens ?? NaN,\n        completionTokens: response.usage?.completion_tokens ?? NaN,\n      },\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders, body: rawResponse },\n      request: { body: JSON.stringify(body) },\n      response: getResponseMetadata(response),\n      warnings,\n      logprobs: mapOpenAIChatLogProbsOutput(choice.logprobs),\n      providerMetadata,\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    if (this.settings.simulateStreaming) {\n      const result = await this.doGenerate(options);\n\n      const simulatedStream = new ReadableStream<LanguageModelV1StreamPart>({\n        start(controller) {\n          controller.enqueue({ type: 'response-metadata', ...result.response });\n          if (result.text) {\n            controller.enqueue({\n              type: 'text-delta',\n              textDelta: result.text,\n            });\n          }\n          if (result.toolCalls) {\n            for (const toolCall of result.toolCalls) {\n              controller.enqueue({\n                type: 'tool-call-delta',\n                toolCallType: 'function',\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                argsTextDelta: toolCall.args,\n              });\n\n              controller.enqueue({\n                type: 'tool-call',\n                ...toolCall,\n              });\n            }\n          }\n          controller.enqueue({\n            type: 'finish',\n            finishReason: result.finishReason,\n            usage: result.usage,\n            logprobs: result.logprobs,\n            providerMetadata: result.providerMetadata,\n          });\n          controller.close();\n        },\n      });\n      return {\n        stream: simulatedStream,\n        rawCall: result.rawCall,\n        rawResponse: result.rawResponse,\n        warnings: result.warnings,\n      };\n    }\n\n    const { args, warnings } = this.getArgs(options);\n\n    const body = {\n      ...args,\n      stream: true,\n\n      // only include stream_options when in strict compatibility mode:\n      stream_options:\n        this.config.compatibility === 'strict'\n          ? { include_usage: true }\n          : undefined,\n    };\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/chat/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        openaiChatChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages: rawPrompt, ...rawSettings } = args;\n\n    const toolCalls: Array<{\n      id: string;\n      type: 'function';\n      function: {\n        name: string;\n        arguments: string;\n      };\n      hasFinished: boolean;\n    }> = [];\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let usage: {\n      promptTokens: number | undefined;\n      completionTokens: number | undefined;\n    } = {\n      promptTokens: undefined,\n      completionTokens: undefined,\n    };\n    let logprobs: LanguageModelV1LogProbs;\n    let isFirstChunk = true;\n\n    const { useLegacyFunctionCalling } = this.settings;\n\n    const providerMetadata: LanguageModelV1ProviderMetadata = { openai: {} };\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof openaiChatChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            // handle error chunks:\n            if ('error' in value) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: value.error });\n              return;\n            }\n\n            if (isFirstChunk) {\n              isFirstChunk = false;\n\n              controller.enqueue({\n                type: 'response-metadata',\n                ...getResponseMetadata(value),\n              });\n            }\n\n            if (value.usage != null) {\n              const {\n                prompt_tokens,\n                completion_tokens,\n                prompt_tokens_details,\n                completion_tokens_details,\n              } = value.usage;\n\n              usage = {\n                promptTokens: prompt_tokens ?? undefined,\n                completionTokens: completion_tokens ?? undefined,\n              };\n\n              if (completion_tokens_details?.reasoning_tokens != null) {\n                providerMetadata.openai.reasoningTokens =\n                  completion_tokens_details?.reasoning_tokens;\n              }\n              if (\n                completion_tokens_details?.accepted_prediction_tokens != null\n              ) {\n                providerMetadata.openai.acceptedPredictionTokens =\n                  completion_tokens_details?.accepted_prediction_tokens;\n              }\n              if (\n                completion_tokens_details?.rejected_prediction_tokens != null\n              ) {\n                providerMetadata.openai.rejectedPredictionTokens =\n                  completion_tokens_details?.rejected_prediction_tokens;\n              }\n              if (prompt_tokens_details?.cached_tokens != null) {\n                providerMetadata.openai.cachedPromptTokens =\n                  prompt_tokens_details?.cached_tokens;\n              }\n            }\n\n            const choice = value.choices[0];\n\n            if (choice?.finish_reason != null) {\n              finishReason = mapOpenAIFinishReason(choice.finish_reason);\n            }\n\n            if (choice?.delta == null) {\n              return;\n            }\n\n            const delta = choice.delta;\n\n            if (delta.content != null) {\n              controller.enqueue({\n                type: 'text-delta',\n                textDelta: delta.content,\n              });\n            }\n\n            const mappedLogprobs = mapOpenAIChatLogProbsOutput(\n              choice?.logprobs,\n            );\n            if (mappedLogprobs?.length) {\n              if (logprobs === undefined) logprobs = [];\n              logprobs.push(...mappedLogprobs);\n            }\n\n            const mappedToolCalls: typeof delta.tool_calls =\n              useLegacyFunctionCalling && delta.function_call != null\n                ? [\n                    {\n                      type: 'function',\n                      id: generateId(),\n                      function: delta.function_call,\n                      index: 0,\n                    },\n                  ]\n                : delta.tool_calls;\n\n            if (mappedToolCalls != null) {\n              for (const toolCallDelta of mappedToolCalls) {\n                const index = toolCallDelta.index;\n\n                // Tool call start. OpenAI returns all information except the arguments in the first chunk.\n                if (toolCalls[index] == null) {\n                  if (toolCallDelta.type !== 'function') {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function' type.`,\n                    });\n                  }\n\n                  if (toolCallDelta.id == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'id' to be a string.`,\n                    });\n                  }\n\n                  if (toolCallDelta.function?.name == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function.name' to be a string.`,\n                    });\n                  }\n\n                  toolCalls[index] = {\n                    id: toolCallDelta.id,\n                    type: 'function',\n                    function: {\n                      name: toolCallDelta.function.name,\n                      arguments: toolCallDelta.function.arguments ?? '',\n                    },\n                    hasFinished: false,\n                  };\n\n                  const toolCall = toolCalls[index];\n\n                  if (\n                    toolCall.function?.name != null &&\n                    toolCall.function?.arguments != null\n                  ) {\n                    // send delta if the argument text has already started:\n                    if (toolCall.function.arguments.length > 0) {\n                      controller.enqueue({\n                        type: 'tool-call-delta',\n                        toolCallType: 'function',\n                        toolCallId: toolCall.id,\n                        toolName: toolCall.function.name,\n                        argsTextDelta: toolCall.function.arguments,\n                      });\n                    }\n\n                    // check if tool call is complete\n                    // (some providers send the full tool call in one chunk):\n                    if (isParsableJson(toolCall.function.arguments)) {\n                      controller.enqueue({\n                        type: 'tool-call',\n                        toolCallType: 'function',\n                        toolCallId: toolCall.id ?? generateId(),\n                        toolName: toolCall.function.name,\n                        args: toolCall.function.arguments,\n                      });\n                      toolCall.hasFinished = true;\n                    }\n                  }\n\n                  continue;\n                }\n\n                // existing tool call, merge if not finished\n                const toolCall = toolCalls[index];\n\n                if (toolCall.hasFinished) {\n                  continue;\n                }\n\n                if (toolCallDelta.function?.arguments != null) {\n                  toolCall.function!.arguments +=\n                    toolCallDelta.function?.arguments ?? '';\n                }\n\n                // send delta\n                controller.enqueue({\n                  type: 'tool-call-delta',\n                  toolCallType: 'function',\n                  toolCallId: toolCall.id,\n                  toolName: toolCall.function.name,\n                  argsTextDelta: toolCallDelta.function.arguments ?? '',\n                });\n\n                // check if tool call is complete\n                if (\n                  toolCall.function?.name != null &&\n                  toolCall.function?.arguments != null &&\n                  isParsableJson(toolCall.function.arguments)\n                ) {\n                  controller.enqueue({\n                    type: 'tool-call',\n                    toolCallType: 'function',\n                    toolCallId: toolCall.id ?? generateId(),\n                    toolName: toolCall.function.name,\n                    args: toolCall.function.arguments,\n                  });\n                  toolCall.hasFinished = true;\n                }\n              }\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              logprobs,\n              usage: {\n                promptTokens: usage.promptTokens ?? NaN,\n                completionTokens: usage.completionTokens ?? NaN,\n              },\n              ...(providerMetadata != null ? { providerMetadata } : {}),\n            });\n          },\n        }),\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      request: { body: JSON.stringify(body) },\n      warnings,\n    };\n  }\n}\n\nconst openaiTokenUsageSchema = z\n  .object({\n    prompt_tokens: z.number().nullish(),\n    completion_tokens: z.number().nullish(),\n    prompt_tokens_details: z\n      .object({\n        cached_tokens: z.number().nullish(),\n      })\n      .nullish(),\n    completion_tokens_details: z\n      .object({\n        reasoning_tokens: z.number().nullish(),\n        accepted_prediction_tokens: z.number().nullish(),\n        rejected_prediction_tokens: z.number().nullish(),\n      })\n      .nullish(),\n  })\n  .nullish();\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiChatResponseSchema = z.object({\n  id: z.string().nullish(),\n  created: z.number().nullish(),\n  model: z.string().nullish(),\n  choices: z.array(\n    z.object({\n      message: z.object({\n        role: z.literal('assistant').nullish(),\n        content: z.string().nullish(),\n        function_call: z\n          .object({\n            arguments: z.string(),\n            name: z.string(),\n          })\n          .nullish(),\n        tool_calls: z\n          .array(\n            z.object({\n              id: z.string().nullish(),\n              type: z.literal('function'),\n              function: z.object({\n                name: z.string(),\n                arguments: z.string(),\n              }),\n            }),\n          )\n          .nullish(),\n      }),\n      index: z.number(),\n      logprobs: z\n        .object({\n          content: z\n            .array(\n              z.object({\n                token: z.string(),\n                logprob: z.number(),\n                top_logprobs: z.array(\n                  z.object({\n                    token: z.string(),\n                    logprob: z.number(),\n                  }),\n                ),\n              }),\n            )\n            .nullable(),\n        })\n        .nullish(),\n      finish_reason: z.string().nullish(),\n    }),\n  ),\n  usage: openaiTokenUsageSchema,\n});\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiChatChunkSchema = z.union([\n  z.object({\n    id: z.string().nullish(),\n    created: z.number().nullish(),\n    model: z.string().nullish(),\n    choices: z.array(\n      z.object({\n        delta: z\n          .object({\n            role: z.enum(['assistant']).nullish(),\n            content: z.string().nullish(),\n            function_call: z\n              .object({\n                name: z.string().optional(),\n                arguments: z.string().optional(),\n              })\n              .nullish(),\n            tool_calls: z\n              .array(\n                z.object({\n                  index: z.number(),\n                  id: z.string().nullish(),\n                  type: z.literal('function').optional(),\n                  function: z.object({\n                    name: z.string().nullish(),\n                    arguments: z.string().nullish(),\n                  }),\n                }),\n              )\n              .nullish(),\n          })\n          .nullish(),\n        logprobs: z\n          .object({\n            content: z\n              .array(\n                z.object({\n                  token: z.string(),\n                  logprob: z.number(),\n                  top_logprobs: z.array(\n                    z.object({\n                      token: z.string(),\n                      logprob: z.number(),\n                    }),\n                  ),\n                }),\n              )\n              .nullable(),\n          })\n          .nullish(),\n        finish_reason: z.string().nullable().optional(),\n        index: z.number(),\n      }),\n    ),\n    usage: openaiTokenUsageSchema,\n  }),\n  openaiErrorDataSchema,\n]);\n\nfunction isReasoningModel(modelId: string) {\n  return (\n    modelId === 'o1' ||\n    modelId.startsWith('o1-') ||\n    modelId === 'o3' ||\n    modelId.startsWith('o3-')\n  );\n}\n\nfunction isAudioModel(modelId: string) {\n  return modelId.startsWith('gpt-4o-audio-preview');\n}\n\nfunction getSystemMessageMode(modelId: string) {\n  if (!isReasoningModel(modelId)) {\n    return 'system';\n  }\n\n  return (\n    reasoningModels[modelId as keyof typeof reasoningModels]\n      ?.systemMessageMode ?? 'developer'\n  );\n}\n\nconst reasoningModels = {\n  'o1-mini': {\n    systemMessageMode: 'remove',\n  },\n  'o1-mini-2024-09-12': {\n    systemMessageMode: 'remove',\n  },\n  'o1-preview': {\n    systemMessageMode: 'remove',\n  },\n  'o1-preview-2024-09-12': {\n    systemMessageMode: 'remove',\n  },\n  'o3-mini': {\n    systemMessageMode: 'developer',\n  },\n  'o3-mini-2025-01-31': {\n    systemMessageMode: 'developer',\n  },\n} as const;\n","import {\n  LanguageModelV1CallWarning,\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { convertUint8ArrayToBase64 } from '@ai-sdk/provider-utils';\nimport { OpenAIChatPrompt } from './openai-chat-prompt';\n\nexport function convertToOpenAIChatMessages({\n  prompt,\n  useLegacyFunctionCalling = false,\n  systemMessageMode = 'system',\n}: {\n  prompt: LanguageModelV1Prompt;\n  useLegacyFunctionCalling?: boolean;\n  systemMessageMode?: 'system' | 'developer' | 'remove';\n}): {\n  messages: OpenAIChatPrompt;\n  warnings: Array<LanguageModelV1CallWarning>;\n} {\n  const messages: OpenAIChatPrompt = [];\n  const warnings: Array<LanguageModelV1CallWarning> = [];\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        switch (systemMessageMode) {\n          case 'system': {\n            messages.push({ role: 'system', content });\n            break;\n          }\n          case 'developer': {\n            messages.push({ role: 'developer', content });\n            break;\n          }\n          case 'remove': {\n            warnings.push({\n              type: 'other',\n              message: 'system messages are removed for this model',\n            });\n            break;\n          }\n          default: {\n            const _exhaustiveCheck: never = systemMessageMode;\n            throw new Error(\n              `Unsupported system message mode: ${_exhaustiveCheck}`,\n            );\n          }\n        }\n        break;\n      }\n\n      case 'user': {\n        if (content.length === 1 && content[0].type === 'text') {\n          messages.push({ role: 'user', content: content[0].text });\n          break;\n        }\n\n        messages.push({\n          role: 'user',\n          content: content.map((part, index) => {\n            switch (part.type) {\n              case 'text': {\n                return { type: 'text', text: part.text };\n              }\n              case 'image': {\n                return {\n                  type: 'image_url',\n                  image_url: {\n                    url:\n                      part.image instanceof URL\n                        ? part.image.toString()\n                        : `data:${\n                            part.mimeType ?? 'image/jpeg'\n                          };base64,${convertUint8ArrayToBase64(part.image)}`,\n\n                    // OpenAI specific extension: image detail\n                    detail: part.providerMetadata?.openai?.imageDetail,\n                  },\n                };\n              }\n              case 'file': {\n                if (part.data instanceof URL) {\n                  throw new UnsupportedFunctionalityError({\n                    functionality:\n                      \"'File content parts with URL data' functionality not supported.\",\n                  });\n                }\n\n                switch (part.mimeType) {\n                  case 'audio/wav': {\n                    return {\n                      type: 'input_audio',\n                      input_audio: { data: part.data, format: 'wav' },\n                    };\n                  }\n                  case 'audio/mp3':\n                  case 'audio/mpeg': {\n                    return {\n                      type: 'input_audio',\n                      input_audio: { data: part.data, format: 'mp3' },\n                    };\n                  }\n                  case 'application/pdf': {\n                    return {\n                      type: 'file',\n                      file: {\n                        filename: part.filename ?? `part-${index}.pdf`,\n                        file_data: `data:application/pdf;base64,${part.data}`,\n                      },\n                    };\n                  }\n                  default: {\n                    throw new UnsupportedFunctionalityError({\n                      functionality: `File content part type ${part.mimeType} in user messages`,\n                    });\n                  }\n                }\n              }\n            }\n          }),\n        });\n\n        break;\n      }\n\n      case 'assistant': {\n        let text = '';\n        const toolCalls: Array<{\n          id: string;\n          type: 'function';\n          function: { name: string; arguments: string };\n        }> = [];\n\n        for (const part of content) {\n          switch (part.type) {\n            case 'text': {\n              text += part.text;\n              break;\n            }\n            case 'tool-call': {\n              toolCalls.push({\n                id: part.toolCallId,\n                type: 'function',\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.args),\n                },\n              });\n              break;\n            }\n          }\n        }\n\n        if (useLegacyFunctionCalling) {\n          if (toolCalls.length > 1) {\n            throw new UnsupportedFunctionalityError({\n              functionality:\n                'useLegacyFunctionCalling with multiple tool calls in one message',\n            });\n          }\n\n          messages.push({\n            role: 'assistant',\n            content: text,\n            function_call:\n              toolCalls.length > 0 ? toolCalls[0].function : undefined,\n          });\n        } else {\n          messages.push({\n            role: 'assistant',\n            content: text,\n            tool_calls: toolCalls.length > 0 ? toolCalls : undefined,\n          });\n        }\n\n        break;\n      }\n\n      case 'tool': {\n        for (const toolResponse of content) {\n          if (useLegacyFunctionCalling) {\n            messages.push({\n              role: 'function',\n              name: toolResponse.toolName,\n              content: JSON.stringify(toolResponse.result),\n            });\n          } else {\n            messages.push({\n              role: 'tool',\n              tool_call_id: toolResponse.toolCallId,\n              content: JSON.stringify(toolResponse.result),\n            });\n          }\n        }\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return { messages, warnings };\n}\n","import { LanguageModelV1LogProbs } from '@ai-sdk/provider';\n\ntype OpenAIChatLogProbs = {\n  content:\n    | {\n        token: string;\n        logprob: number;\n        top_logprobs:\n          | {\n              token: string;\n              logprob: number;\n            }[]\n          | null;\n      }[]\n    | null;\n};\n\nexport function mapOpenAIChatLogProbsOutput(\n  logprobs: OpenAIChatLogProbs | null | undefined,\n): LanguageModelV1LogProbs | undefined {\n  return (\n    logprobs?.content?.map(({ token, logprob, top_logprobs }) => ({\n      token,\n      logprob,\n      topLogprobs: top_logprobs\n        ? top_logprobs.map(({ token, logprob }) => ({\n            token,\n            logprob,\n          }))\n        : [],\n    })) ?? undefined\n  );\n}\n","import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\n\nexport function mapOpenAIFinishReason(\n  finishReason: string | null | undefined,\n): LanguageModelV1FinishReason {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop';\n    case 'length':\n      return 'length';\n    case 'content_filter':\n      return 'content-filter';\n    case 'function_call':\n    case 'tool_calls':\n      return 'tool-calls';\n    default:\n      return 'unknown';\n  }\n}\n","import { z } from 'zod';\nimport { createJsonErrorResponseHandler } from '@ai-sdk/provider-utils';\n\nexport const openaiErrorDataSchema = z.object({\n  error: z.object({\n    message: z.string(),\n\n    // The additional information below is handled loosely to support\n    // OpenAI-compatible providers that have slightly different error\n    // responses:\n    type: z.string().nullish(),\n    param: z.any().nullish(),\n    code: z.union([z.string(), z.number()]).nullish(),\n  }),\n});\n\nexport type OpenAIErrorData = z.infer<typeof openaiErrorDataSchema>;\n\nexport const openaiFailedResponseHandler = createJsonErrorResponseHandler({\n  errorSchema: openaiErrorDataSchema,\n  errorToMessage: data => data.error.message,\n});\n","export function getResponseMetadata({\n  id,\n  model,\n  created,\n}: {\n  id?: string | undefined | null;\n  created?: number | undefined | null;\n  model?: string | undefined | null;\n}) {\n  return {\n    id: id ?? undefined,\n    modelId: model ?? undefined,\n    timestamp: created != null ? new Date(created * 1000) : undefined,\n  };\n}\n","import {\n  JSONSchema7,\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport function prepareTools({\n  mode,\n  useLegacyFunctionCalling = false,\n  structuredOutputs,\n}: {\n  mode: Parameters<LanguageModelV1['doGenerate']>[0]['mode'] & {\n    type: 'regular';\n  };\n  useLegacyFunctionCalling: boolean | undefined;\n  structuredOutputs: boolean;\n}): {\n  tools?: {\n    type: 'function';\n    function: {\n      name: string;\n      description: string | undefined;\n      parameters: JSONSchema7;\n      strict?: boolean;\n    };\n  }[];\n  tool_choice?:\n    | 'auto'\n    | 'none'\n    | 'required'\n    | { type: 'function'; function: { name: string } };\n\n  // legacy support\n  functions?: {\n    name: string;\n    description: string | undefined;\n    parameters: JSONSchema7;\n  }[];\n  function_call?: { name: string };\n  toolWarnings: Array<LanguageModelV1CallWarning>;\n} {\n  // when the tools array is empty, change it to undefined to prevent errors:\n  const tools = mode.tools?.length ? mode.tools : undefined;\n\n  const toolWarnings: LanguageModelV1CallWarning[] = [];\n\n  if (tools == null) {\n    return { tools: undefined, tool_choice: undefined, toolWarnings };\n  }\n\n  const toolChoice = mode.toolChoice;\n\n  if (useLegacyFunctionCalling) {\n    const openaiFunctions: Array<{\n      name: string;\n      description: string | undefined;\n      parameters: JSONSchema7;\n    }> = [];\n\n    for (const tool of tools) {\n      if (tool.type === 'provider-defined') {\n        toolWarnings.push({ type: 'unsupported-tool', tool });\n      } else {\n        openaiFunctions.push({\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n        });\n      }\n    }\n\n    if (toolChoice == null) {\n      return {\n        functions: openaiFunctions,\n        function_call: undefined,\n        toolWarnings,\n      };\n    }\n\n    const type = toolChoice.type;\n\n    switch (type) {\n      case 'auto':\n      case 'none':\n      case undefined:\n        return {\n          functions: openaiFunctions,\n          function_call: undefined,\n          toolWarnings,\n        };\n      case 'required':\n        throw new UnsupportedFunctionalityError({\n          functionality: 'useLegacyFunctionCalling and toolChoice: required',\n        });\n      default:\n        return {\n          functions: openaiFunctions,\n          function_call: { name: toolChoice.toolName },\n          toolWarnings,\n        };\n    }\n  }\n\n  const openaiTools: Array<{\n    type: 'function';\n    function: {\n      name: string;\n      description: string | undefined;\n      parameters: JSONSchema7;\n      strict: boolean | undefined;\n    };\n  }> = [];\n\n  for (const tool of tools) {\n    if (tool.type === 'provider-defined') {\n      toolWarnings.push({ type: 'unsupported-tool', tool });\n    } else {\n      openaiTools.push({\n        type: 'function',\n        function: {\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n          strict: structuredOutputs ? true : undefined,\n        },\n      });\n    }\n  }\n\n  if (toolChoice == null) {\n    return { tools: openaiTools, tool_choice: undefined, toolWarnings };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n    case 'none':\n    case 'required':\n      return { tools: openaiTools, tool_choice: type, toolWarnings };\n    case 'tool':\n      return {\n        tools: openaiTools,\n        tool_choice: {\n          type: 'function',\n          function: {\n            name: toolChoice.toolName,\n          },\n        },\n        toolWarnings,\n      };\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`,\n      });\n    }\n  }\n}\n","import {\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1LogProbs,\n  LanguageModelV1StreamPart,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  ParseResult,\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { convertToOpenAICompletionPrompt } from './convert-to-openai-completion-prompt';\nimport { mapOpenAICompletionLogProbs } from './map-openai-completion-logprobs';\nimport { mapOpenAIFinishReason } from './map-openai-finish-reason';\nimport {\n  OpenAICompletionModelId,\n  OpenAICompletionSettings,\n} from './openai-completion-settings';\nimport {\n  openaiErrorDataSchema,\n  openaiFailedResponseHandler,\n} from './openai-error';\nimport { getResponseMetadata } from './get-response-metadata';\n\ntype OpenAICompletionConfig = {\n  provider: string;\n  compatibility: 'strict' | 'compatible';\n  headers: () => Record<string, string | undefined>;\n  url: (options: { modelId: string; path: string }) => string;\n  fetch?: FetchFunction;\n};\n\nexport class OpenAICompletionLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n  readonly defaultObjectGenerationMode = undefined;\n\n  readonly modelId: OpenAICompletionModelId;\n  readonly settings: OpenAICompletionSettings;\n\n  private readonly config: OpenAICompletionConfig;\n\n  constructor(\n    modelId: OpenAICompletionModelId,\n    settings: OpenAICompletionSettings,\n    config: OpenAICompletionConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  private getArgs({\n    mode,\n    inputFormat,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences: userStopSequences,\n    responseFormat,\n    seed,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const type = mode.type;\n\n    const warnings: LanguageModelV1CallWarning[] = [];\n\n    if (topK != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'topK',\n      });\n    }\n\n    if (responseFormat != null && responseFormat.type !== 'text') {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'responseFormat',\n        details: 'JSON response format is not supported.',\n      });\n    }\n\n    const { prompt: completionPrompt, stopSequences } =\n      convertToOpenAICompletionPrompt({ prompt, inputFormat });\n\n    const stop = [...(stopSequences ?? []), ...(userStopSequences ?? [])];\n\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n\n      // model specific settings:\n      echo: this.settings.echo,\n      logit_bias: this.settings.logitBias,\n      logprobs:\n        typeof this.settings.logprobs === 'number'\n          ? this.settings.logprobs\n          : typeof this.settings.logprobs === 'boolean'\n            ? this.settings.logprobs\n              ? 0\n              : undefined\n            : undefined,\n      suffix: this.settings.suffix,\n      user: this.settings.user,\n\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      seed,\n\n      // prompt:\n      prompt: completionPrompt,\n\n      // stop sequences:\n      stop: stop.length > 0 ? stop : undefined,\n    };\n\n    switch (type) {\n      case 'regular': {\n        if (mode.tools?.length) {\n          throw new UnsupportedFunctionalityError({\n            functionality: 'tools',\n          });\n        }\n\n        if (mode.toolChoice) {\n          throw new UnsupportedFunctionalityError({\n            functionality: 'toolChoice',\n          });\n        }\n\n        return { args: baseArgs, warnings };\n      }\n\n      case 'object-json': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'object-json mode',\n        });\n      }\n\n      case 'object-tool': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'object-tool mode',\n        });\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { args, warnings } = this.getArgs(options);\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: this.config.url({\n        path: '/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiCompletionResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { prompt: rawPrompt, ...rawSettings } = args;\n    const choice = response.choices[0];\n\n    return {\n      text: choice.text,\n      usage: {\n        promptTokens: response.usage.prompt_tokens,\n        completionTokens: response.usage.completion_tokens,\n      },\n      finishReason: mapOpenAIFinishReason(choice.finish_reason),\n      logprobs: mapOpenAICompletionLogProbs(choice.logprobs),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders, body: rawResponse },\n      response: getResponseMetadata(response),\n      warnings,\n      request: { body: JSON.stringify(args) },\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    const { args, warnings } = this.getArgs(options);\n\n    const body = {\n      ...args,\n      stream: true,\n\n      // only include stream_options when in strict compatibility mode:\n      stream_options:\n        this.config.compatibility === 'strict'\n          ? { include_usage: true }\n          : undefined,\n    };\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        openaiCompletionChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { prompt: rawPrompt, ...rawSettings } = args;\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let usage: { promptTokens: number; completionTokens: number } = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN,\n    };\n    let logprobs: LanguageModelV1LogProbs;\n    let isFirstChunk = true;\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof openaiCompletionChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            // handle error chunks:\n            if ('error' in value) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: value.error });\n              return;\n            }\n\n            if (isFirstChunk) {\n              isFirstChunk = false;\n\n              controller.enqueue({\n                type: 'response-metadata',\n                ...getResponseMetadata(value),\n              });\n            }\n\n            if (value.usage != null) {\n              usage = {\n                promptTokens: value.usage.prompt_tokens,\n                completionTokens: value.usage.completion_tokens,\n              };\n            }\n\n            const choice = value.choices[0];\n\n            if (choice?.finish_reason != null) {\n              finishReason = mapOpenAIFinishReason(choice.finish_reason);\n            }\n\n            if (choice?.text != null) {\n              controller.enqueue({\n                type: 'text-delta',\n                textDelta: choice.text,\n              });\n            }\n\n            const mappedLogprobs = mapOpenAICompletionLogProbs(\n              choice?.logprobs,\n            );\n            if (mappedLogprobs?.length) {\n              if (logprobs === undefined) logprobs = [];\n              logprobs.push(...mappedLogprobs);\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              logprobs,\n              usage,\n            });\n          },\n        }),\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n      request: { body: JSON.stringify(body) },\n    };\n  }\n}\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiCompletionResponseSchema = z.object({\n  id: z.string().nullish(),\n  created: z.number().nullish(),\n  model: z.string().nullish(),\n  choices: z.array(\n    z.object({\n      text: z.string(),\n      finish_reason: z.string(),\n      logprobs: z\n        .object({\n          tokens: z.array(z.string()),\n          token_logprobs: z.array(z.number()),\n          top_logprobs: z.array(z.record(z.string(), z.number())).nullable(),\n        })\n        .nullish(),\n    }),\n  ),\n  usage: z.object({\n    prompt_tokens: z.number(),\n    completion_tokens: z.number(),\n  }),\n});\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiCompletionChunkSchema = z.union([\n  z.object({\n    id: z.string().nullish(),\n    created: z.number().nullish(),\n    model: z.string().nullish(),\n    choices: z.array(\n      z.object({\n        text: z.string(),\n        finish_reason: z.string().nullish(),\n        index: z.number(),\n        logprobs: z\n          .object({\n            tokens: z.array(z.string()),\n            token_logprobs: z.array(z.number()),\n            top_logprobs: z.array(z.record(z.string(), z.number())).nullable(),\n          })\n          .nullish(),\n      }),\n    ),\n    usage: z\n      .object({\n        prompt_tokens: z.number(),\n        completion_tokens: z.number(),\n      })\n      .nullish(),\n  }),\n  openaiErrorDataSchema,\n]);\n","import {\n  InvalidPromptError,\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport function convertToOpenAICompletionPrompt({\n  prompt,\n  inputFormat,\n  user = 'user',\n  assistant = 'assistant',\n}: {\n  prompt: LanguageModelV1Prompt;\n  inputFormat: 'prompt' | 'messages';\n  user?: string;\n  assistant?: string;\n}): {\n  prompt: string;\n  stopSequences?: string[];\n} {\n  // When the user supplied a prompt input, we don't transform it:\n  if (\n    inputFormat === 'prompt' &&\n    prompt.length === 1 &&\n    prompt[0].role === 'user' &&\n    prompt[0].content.length === 1 &&\n    prompt[0].content[0].type === 'text'\n  ) {\n    return { prompt: prompt[0].content[0].text };\n  }\n\n  // otherwise transform to a chat message format:\n  let text = '';\n\n  // if first message is a system message, add it to the text:\n  if (prompt[0].role === 'system') {\n    text += `${prompt[0].content}\\n\\n`;\n    prompt = prompt.slice(1);\n  }\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        throw new InvalidPromptError({\n          message: 'Unexpected system message in prompt: ${content}',\n          prompt,\n        });\n      }\n\n      case 'user': {\n        const userMessage = content\n          .map(part => {\n            switch (part.type) {\n              case 'text': {\n                return part.text;\n              }\n              case 'image': {\n                throw new UnsupportedFunctionalityError({\n                  functionality: 'images',\n                });\n              }\n            }\n          })\n          .join('');\n\n        text += `${user}:\\n${userMessage}\\n\\n`;\n        break;\n      }\n\n      case 'assistant': {\n        const assistantMessage = content\n          .map(part => {\n            switch (part.type) {\n              case 'text': {\n                return part.text;\n              }\n              case 'tool-call': {\n                throw new UnsupportedFunctionalityError({\n                  functionality: 'tool-call messages',\n                });\n              }\n            }\n          })\n          .join('');\n\n        text += `${assistant}:\\n${assistantMessage}\\n\\n`;\n        break;\n      }\n\n      case 'tool': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'tool messages',\n        });\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  // Assistant message prefix:\n  text += `${assistant}:\\n`;\n\n  return {\n    prompt: text,\n    stopSequences: [`\\n${user}:`],\n  };\n}\n","import { LanguageModelV1LogProbs } from '@ai-sdk/provider';\n\ntype OpenAICompletionLogProps = {\n  tokens: string[];\n  token_logprobs: number[];\n  top_logprobs: Record<string, number>[] | null;\n};\n\nexport function mapOpenAICompletionLogProbs(\n  logprobs: OpenAICompletionLogProps | null | undefined,\n): LanguageModelV1LogProbs | undefined {\n  return logprobs?.tokens.map((token, index) => ({\n    token,\n    logprob: logprobs.token_logprobs[index],\n    topLogprobs: logprobs.top_logprobs\n      ? Object.entries(logprobs.top_logprobs[index]).map(\n          ([token, logprob]) => ({\n            token,\n            logprob,\n          }),\n        )\n      : [],\n  }));\n}\n","import {\n  EmbeddingModelV1,\n  TooManyEmbeddingValuesForCallError,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from './openai-config';\nimport {\n  OpenAIEmbeddingModelId,\n  OpenAIEmbeddingSettings,\n} from './openai-embedding-settings';\nimport { openaiFailedResponseHandler } from './openai-error';\n\nexport class OpenAIEmbeddingModel implements EmbeddingModelV1<string> {\n  readonly specificationVersion = 'v1';\n  readonly modelId: OpenAIEmbeddingModelId;\n\n  private readonly config: OpenAIConfig;\n  private readonly settings: OpenAIEmbeddingSettings;\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  get maxEmbeddingsPerCall(): number {\n    return this.settings.maxEmbeddingsPerCall ?? 2048;\n  }\n\n  get supportsParallelCalls(): boolean {\n    return this.settings.supportsParallelCalls ?? true;\n  }\n\n  constructor(\n    modelId: OpenAIEmbeddingModelId,\n    settings: OpenAIEmbeddingSettings,\n    config: OpenAIConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  async doEmbed({\n    values,\n    headers,\n    abortSignal,\n  }: Parameters<EmbeddingModelV1<string>['doEmbed']>[0]): Promise<\n    Awaited<ReturnType<EmbeddingModelV1<string>['doEmbed']>>\n  > {\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new TooManyEmbeddingValuesForCallError({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values,\n      });\n    }\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/embeddings',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        input: values,\n        encoding_format: 'float',\n        dimensions: this.settings.dimensions,\n        user: this.settings.user,\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiTextEmbeddingResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      embeddings: response.data.map(item => item.embedding),\n      usage: response.usage\n        ? { tokens: response.usage.prompt_tokens }\n        : undefined,\n      rawResponse: { headers: responseHeaders },\n    };\n  }\n}\n\n// minimal version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiTextEmbeddingResponseSchema = z.object({\n  data: z.array(z.object({ embedding: z.array(z.number()) })),\n  usage: z.object({ prompt_tokens: z.number() }).nullish(),\n});\n","import { ImageModelV1, ImageModelV1CallWarning } from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from './openai-config';\nimport { openaiFailedResponseHandler } from './openai-error';\nimport {\n  OpenAIImageModelId,\n  OpenAIImageSettings,\n  modelMaxImagesPerCall,\n} from './openai-image-settings';\n\ninterface OpenAIImageModelConfig extends OpenAIConfig {\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}\n\nexport class OpenAIImageModel implements ImageModelV1 {\n  readonly specificationVersion = 'v1';\n\n  get maxImagesPerCall(): number {\n    return (\n      this.settings.maxImagesPerCall ?? modelMaxImagesPerCall[this.modelId] ?? 1\n    );\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  constructor(\n    readonly modelId: OpenAIImageModelId,\n    private readonly settings: OpenAIImageSettings,\n    private readonly config: OpenAIImageModelConfig,\n  ) {}\n\n  async doGenerate({\n    prompt,\n    n,\n    size,\n    aspectRatio,\n    seed,\n    providerOptions,\n    headers,\n    abortSignal,\n  }: Parameters<ImageModelV1['doGenerate']>[0]): Promise<\n    Awaited<ReturnType<ImageModelV1['doGenerate']>>\n  > {\n    const warnings: Array<ImageModelV1CallWarning> = [];\n\n    if (aspectRatio != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'aspectRatio',\n        details:\n          'This model does not support aspect ratio. Use `size` instead.',\n      });\n    }\n\n    if (seed != null) {\n      warnings.push({ type: 'unsupported-setting', setting: 'seed' });\n    }\n\n    const currentDate = this.config._internal?.currentDate?.() ?? new Date();\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: '/images/generations',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        prompt,\n        n,\n        size,\n        ...(providerOptions.openai ?? {}),\n        response_format: 'b64_json',\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiImageResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      images: response.data.map(item => item.b64_json),\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n      },\n    };\n  }\n}\n\n// minimal version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiImageResponseSchema = z.object({\n  data: z.array(z.object({ b64_json: z.string() })),\n});\n","export type OpenAIImageModelId = 'dall-e-3' | 'dall-e-2' | (string & {});\n\n// https://platform.openai.com/docs/guides/images\nexport const modelMaxImagesPerCall: Record<OpenAIImageModelId, number> = {\n  'dall-e-3': 1,\n  'dall-e-2': 10,\n};\n\nexport interface OpenAIImageSettings {\n  /**\nOverride the maximum number of images per call (default is dependent on the\nmodel, or 1 for an unknown model).\n   */\n  maxImagesPerCall?: number;\n}\n","import {\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1StreamPart,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  generateId,\n  parseProviderOptions,\n  ParseResult,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from '../openai-config';\nimport { openaiFailedResponseHandler } from '../openai-error';\nimport { convertToOpenAIResponsesMessages } from './convert-to-openai-responses-messages';\nimport { mapOpenAIResponseFinishReason } from './map-openai-responses-finish-reason';\nimport { prepareResponsesTools } from './openai-responses-prepare-tools';\nimport { OpenAIResponsesModelId } from './openai-responses-settings';\n\nexport class OpenAIResponsesLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n  readonly defaultObjectGenerationMode = 'json';\n\n  readonly modelId: OpenAIResponsesModelId;\n\n  private readonly config: OpenAIConfig;\n\n  constructor(modelId: OpenAIResponsesModelId, config: OpenAIConfig) {\n    this.modelId = modelId;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  private getArgs({\n    mode,\n    maxTokens,\n    temperature,\n    stopSequences,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    seed,\n    prompt,\n    providerMetadata,\n    responseFormat,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const warnings: LanguageModelV1CallWarning[] = [];\n    const modelConfig = getResponsesModelConfig(this.modelId);\n    const type = mode.type;\n\n    if (topK != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'topK',\n      });\n    }\n\n    if (seed != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'seed',\n      });\n    }\n\n    if (presencePenalty != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'presencePenalty',\n      });\n    }\n\n    if (frequencyPenalty != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'frequencyPenalty',\n      });\n    }\n\n    if (stopSequences != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'stopSequences',\n      });\n    }\n\n    const { messages, warnings: messageWarnings } =\n      convertToOpenAIResponsesMessages({\n        prompt,\n        systemMessageMode: modelConfig.systemMessageMode,\n      });\n\n    warnings.push(...messageWarnings);\n\n    const openaiOptions = parseProviderOptions({\n      provider: 'openai',\n      providerOptions: providerMetadata,\n      schema: openaiResponsesProviderOptionsSchema,\n    });\n\n    const isStrict = openaiOptions?.strictSchemas ?? true;\n\n    const baseArgs = {\n      model: this.modelId,\n      input: messages,\n      temperature,\n      top_p: topP,\n      max_output_tokens: maxTokens,\n\n      ...(responseFormat?.type === 'json' && {\n        text: {\n          format:\n            responseFormat.schema != null\n              ? {\n                  type: 'json_schema',\n                  strict: isStrict,\n                  name: responseFormat.name ?? 'response',\n                  description: responseFormat.description,\n                  schema: responseFormat.schema,\n                }\n              : { type: 'json_object' },\n        },\n      }),\n\n      // provider options:\n      metadata: openaiOptions?.metadata,\n      parallel_tool_calls: openaiOptions?.parallelToolCalls,\n      previous_response_id: openaiOptions?.previousResponseId,\n      store: openaiOptions?.store,\n      user: openaiOptions?.user,\n      instructions: openaiOptions?.instructions,\n\n      // model-specific settings:\n      ...(modelConfig.isReasoningModel &&\n        openaiOptions?.reasoningEffort != null && {\n          reasoning: { effort: openaiOptions?.reasoningEffort },\n        }),\n      ...(modelConfig.requiredAutoTruncation && {\n        truncation: 'auto',\n      }),\n    };\n\n    if (modelConfig.isReasoningModel) {\n      // remove unsupported settings for reasoning models\n      // see https://platform.openai.com/docs/guides/reasoning#limitations\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'temperature',\n          details: 'temperature is not supported for reasoning models',\n        });\n      }\n\n      if (baseArgs.top_p != null) {\n        baseArgs.top_p = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'topP',\n          details: 'topP is not supported for reasoning models',\n        });\n      }\n    }\n\n    switch (type) {\n      case 'regular': {\n        const { tools, tool_choice, toolWarnings } = prepareResponsesTools({\n          mode,\n          strict: isStrict, // TODO support provider options on tools\n        });\n\n        return {\n          args: {\n            ...baseArgs,\n            tools,\n            tool_choice,\n          },\n          warnings: [...warnings, ...toolWarnings],\n        };\n      }\n\n      case 'object-json': {\n        return {\n          args: {\n            ...baseArgs,\n            text: {\n              format:\n                mode.schema != null\n                  ? {\n                      type: 'json_schema',\n                      strict: isStrict,\n                      name: mode.name ?? 'response',\n                      description: mode.description,\n                      schema: mode.schema,\n                    }\n                  : { type: 'json_object' },\n            },\n          },\n          warnings,\n        };\n      }\n\n      case 'object-tool': {\n        return {\n          args: {\n            ...baseArgs,\n            tool_choice: { type: 'function', name: mode.tool.name },\n            tools: [\n              {\n                type: 'function',\n                name: mode.tool.name,\n                description: mode.tool.description,\n                parameters: mode.tool.parameters,\n                strict: isStrict,\n              },\n            ],\n          },\n          warnings,\n        };\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { args: body, warnings } = this.getArgs(options);\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: this.config.url({\n        path: '/responses',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        z.object({\n          id: z.string(),\n          created_at: z.number(),\n          model: z.string(),\n          output: z.array(\n            z.discriminatedUnion('type', [\n              z.object({\n                type: z.literal('message'),\n                role: z.literal('assistant'),\n                content: z.array(\n                  z.object({\n                    type: z.literal('output_text'),\n                    text: z.string(),\n                    annotations: z.array(\n                      z.object({\n                        type: z.literal('url_citation'),\n                        start_index: z.number(),\n                        end_index: z.number(),\n                        url: z.string(),\n                        title: z.string(),\n                      }),\n                    ),\n                  }),\n                ),\n              }),\n              z.object({\n                type: z.literal('function_call'),\n                call_id: z.string(),\n                name: z.string(),\n                arguments: z.string(),\n              }),\n              z.object({\n                type: z.literal('web_search_call'),\n              }),\n              z.object({\n                type: z.literal('computer_call'),\n              }),\n              z.object({\n                type: z.literal('reasoning'),\n              }),\n            ]),\n          ),\n          incomplete_details: z.object({ reason: z.string() }).nullable(),\n          usage: usageSchema,\n        }),\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const outputTextElements = response.output\n      .filter(output => output.type === 'message')\n      .flatMap(output => output.content)\n      .filter(content => content.type === 'output_text');\n\n    const toolCalls = response.output\n      .filter(output => output.type === 'function_call')\n      .map(output => ({\n        toolCallType: 'function' as const,\n        toolCallId: output.call_id,\n        toolName: output.name,\n        args: output.arguments,\n      }));\n\n    return {\n      text: outputTextElements.map(content => content.text).join('\\n'),\n      sources: outputTextElements.flatMap(content =>\n        content.annotations.map(annotation => ({\n          sourceType: 'url',\n          id: this.config.generateId?.() ?? generateId(),\n          url: annotation.url,\n          title: annotation.title,\n        })),\n      ),\n      finishReason: mapOpenAIResponseFinishReason({\n        finishReason: response.incomplete_details?.reason,\n        hasToolCalls: toolCalls.length > 0,\n      }),\n      toolCalls: toolCalls.length > 0 ? toolCalls : undefined,\n      usage: {\n        promptTokens: response.usage.input_tokens,\n        completionTokens: response.usage.output_tokens,\n      },\n      rawCall: {\n        rawPrompt: undefined,\n        rawSettings: {},\n      },\n      rawResponse: {\n        headers: responseHeaders,\n        body: rawResponse,\n      },\n      request: {\n        body: JSON.stringify(body),\n      },\n      response: {\n        id: response.id,\n        timestamp: new Date(response.created_at * 1000),\n        modelId: response.model,\n      },\n      providerMetadata: {\n        openai: {\n          responseId: response.id,\n          cachedPromptTokens:\n            response.usage.input_tokens_details?.cached_tokens ?? null,\n          reasoningTokens:\n            response.usage.output_tokens_details?.reasoning_tokens ?? null,\n        },\n      },\n      warnings,\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    const { args: body, warnings } = this.getArgs(options);\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/responses',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: {\n        ...body,\n        stream: true,\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        openaiResponsesChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const self = this;\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let promptTokens = NaN;\n    let completionTokens = NaN;\n    let cachedPromptTokens: number | null = null;\n    let reasoningTokens: number | null = null;\n    let responseId: string | null = null;\n    const ongoingToolCalls: Record<\n      number,\n      { toolName: string; toolCallId: string } | undefined\n    > = {};\n    let hasToolCalls = false;\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof openaiResponsesChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            if (isResponseOutputItemAddedChunk(value)) {\n              if (value.item.type === 'function_call') {\n                ongoingToolCalls[value.output_index] = {\n                  toolName: value.item.name,\n                  toolCallId: value.item.call_id,\n                };\n\n                controller.enqueue({\n                  type: 'tool-call-delta',\n                  toolCallType: 'function',\n                  toolCallId: value.item.call_id,\n                  toolName: value.item.name,\n                  argsTextDelta: value.item.arguments,\n                });\n              }\n            } else if (isResponseFunctionCallArgumentsDeltaChunk(value)) {\n              const toolCall = ongoingToolCalls[value.output_index];\n\n              if (toolCall != null) {\n                controller.enqueue({\n                  type: 'tool-call-delta',\n                  toolCallType: 'function',\n                  toolCallId: toolCall.toolCallId,\n                  toolName: toolCall.toolName,\n                  argsTextDelta: value.delta,\n                });\n              }\n            } else if (isResponseCreatedChunk(value)) {\n              responseId = value.response.id;\n              controller.enqueue({\n                type: 'response-metadata',\n                id: value.response.id,\n                timestamp: new Date(value.response.created_at * 1000),\n                modelId: value.response.model,\n              });\n            } else if (isTextDeltaChunk(value)) {\n              controller.enqueue({\n                type: 'text-delta',\n                textDelta: value.delta,\n              });\n            } else if (\n              isResponseOutputItemDoneChunk(value) &&\n              value.item.type === 'function_call'\n            ) {\n              ongoingToolCalls[value.output_index] = undefined;\n              hasToolCalls = true;\n              controller.enqueue({\n                type: 'tool-call',\n                toolCallType: 'function',\n                toolCallId: value.item.call_id,\n                toolName: value.item.name,\n                args: value.item.arguments,\n              });\n            } else if (isResponseFinishedChunk(value)) {\n              finishReason = mapOpenAIResponseFinishReason({\n                finishReason: value.response.incomplete_details?.reason,\n                hasToolCalls,\n              });\n              promptTokens = value.response.usage.input_tokens;\n              completionTokens = value.response.usage.output_tokens;\n              cachedPromptTokens =\n                value.response.usage.input_tokens_details?.cached_tokens ??\n                cachedPromptTokens;\n              reasoningTokens =\n                value.response.usage.output_tokens_details?.reasoning_tokens ??\n                reasoningTokens;\n            } else if (isResponseAnnotationAddedChunk(value)) {\n              controller.enqueue({\n                type: 'source',\n                source: {\n                  sourceType: 'url',\n                  id: self.config.generateId?.() ?? generateId(),\n                  url: value.annotation.url,\n                  title: value.annotation.title,\n                },\n              });\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              usage: { promptTokens, completionTokens },\n              ...((cachedPromptTokens != null || reasoningTokens != null) && {\n                providerMetadata: {\n                  openai: {\n                    responseId,\n                    cachedPromptTokens,\n                    reasoningTokens,\n                  },\n                },\n              }),\n            });\n          },\n        }),\n      ),\n      rawCall: {\n        rawPrompt: undefined,\n        rawSettings: {},\n      },\n      rawResponse: { headers: responseHeaders },\n      request: { body: JSON.stringify(body) },\n      warnings,\n    };\n  }\n}\n\nconst usageSchema = z.object({\n  input_tokens: z.number(),\n  input_tokens_details: z\n    .object({ cached_tokens: z.number().nullish() })\n    .nullish(),\n  output_tokens: z.number(),\n  output_tokens_details: z\n    .object({ reasoning_tokens: z.number().nullish() })\n    .nullish(),\n});\n\nconst textDeltaChunkSchema = z.object({\n  type: z.literal('response.output_text.delta'),\n  delta: z.string(),\n});\n\nconst responseFinishedChunkSchema = z.object({\n  type: z.enum(['response.completed', 'response.incomplete']),\n  response: z.object({\n    incomplete_details: z.object({ reason: z.string() }).nullish(),\n    usage: usageSchema,\n  }),\n});\n\nconst responseCreatedChunkSchema = z.object({\n  type: z.literal('response.created'),\n  response: z.object({\n    id: z.string(),\n    created_at: z.number(),\n    model: z.string(),\n  }),\n});\n\nconst responseOutputItemDoneSchema = z.object({\n  type: z.literal('response.output_item.done'),\n  output_index: z.number(),\n  item: z.discriminatedUnion('type', [\n    z.object({\n      type: z.literal('message'),\n    }),\n    z.object({\n      type: z.literal('function_call'),\n      id: z.string(),\n      call_id: z.string(),\n      name: z.string(),\n      arguments: z.string(),\n      status: z.literal('completed'),\n    }),\n  ]),\n});\n\nconst responseFunctionCallArgumentsDeltaSchema = z.object({\n  type: z.literal('response.function_call_arguments.delta'),\n  item_id: z.string(),\n  output_index: z.number(),\n  delta: z.string(),\n});\n\nconst responseOutputItemAddedSchema = z.object({\n  type: z.literal('response.output_item.added'),\n  output_index: z.number(),\n  item: z.discriminatedUnion('type', [\n    z.object({\n      type: z.literal('message'),\n    }),\n    z.object({\n      type: z.literal('function_call'),\n      id: z.string(),\n      call_id: z.string(),\n      name: z.string(),\n      arguments: z.string(),\n    }),\n  ]),\n});\n\nconst responseAnnotationAddedSchema = z.object({\n  type: z.literal('response.output_text.annotation.added'),\n  annotation: z.object({\n    type: z.literal('url_citation'),\n    url: z.string(),\n    title: z.string(),\n  }),\n});\n\nconst openaiResponsesChunkSchema = z.union([\n  textDeltaChunkSchema,\n  responseFinishedChunkSchema,\n  responseCreatedChunkSchema,\n  responseOutputItemDoneSchema,\n  responseFunctionCallArgumentsDeltaSchema,\n  responseOutputItemAddedSchema,\n  responseAnnotationAddedSchema,\n  z.object({ type: z.string() }).passthrough(), // fallback for unknown chunks\n]);\n\nfunction isTextDeltaChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof textDeltaChunkSchema> {\n  return chunk.type === 'response.output_text.delta';\n}\n\nfunction isResponseOutputItemDoneChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseOutputItemDoneSchema> {\n  return chunk.type === 'response.output_item.done';\n}\n\nfunction isResponseFinishedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseFinishedChunkSchema> {\n  return (\n    chunk.type === 'response.completed' || chunk.type === 'response.incomplete'\n  );\n}\n\nfunction isResponseCreatedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseCreatedChunkSchema> {\n  return chunk.type === 'response.created';\n}\n\nfunction isResponseFunctionCallArgumentsDeltaChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseFunctionCallArgumentsDeltaSchema> {\n  return chunk.type === 'response.function_call_arguments.delta';\n}\n\nfunction isResponseOutputItemAddedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseOutputItemAddedSchema> {\n  return chunk.type === 'response.output_item.added';\n}\n\nfunction isResponseAnnotationAddedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseAnnotationAddedSchema> {\n  return chunk.type === 'response.output_text.annotation.added';\n}\n\ntype ResponsesModelConfig = {\n  isReasoningModel: boolean;\n  systemMessageMode: 'remove' | 'system' | 'developer';\n  requiredAutoTruncation: boolean;\n};\n\nfunction getResponsesModelConfig(modelId: string): ResponsesModelConfig {\n  // o series reasoning models:\n  if (modelId.startsWith('o')) {\n    if (modelId.startsWith('o1-mini') || modelId.startsWith('o1-preview')) {\n      return {\n        isReasoningModel: true,\n        systemMessageMode: 'remove',\n        requiredAutoTruncation: false,\n      };\n    }\n\n    return {\n      isReasoningModel: true,\n      systemMessageMode: 'developer',\n      requiredAutoTruncation: false,\n    };\n  }\n\n  // gpt models:\n  return {\n    isReasoningModel: false,\n    systemMessageMode: 'system',\n    requiredAutoTruncation: false,\n  };\n}\n\nconst openaiResponsesProviderOptionsSchema = z.object({\n  metadata: z.any().nullish(),\n  parallelToolCalls: z.boolean().nullish(),\n  previousResponseId: z.string().nullish(),\n  store: z.boolean().nullish(),\n  user: z.string().nullish(),\n  reasoningEffort: z.string().nullish(),\n  strictSchemas: z.boolean().nullish(),\n  instructions: z.string().nullish(),\n});\n\nexport type OpenAIResponsesProviderOptions = z.infer<\n  typeof openaiResponsesProviderOptionsSchema\n>;\n","import {\n  LanguageModelV1CallWarning,\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { convertUint8ArrayToBase64 } from '@ai-sdk/provider-utils';\nimport { OpenAIResponsesPrompt } from './openai-responses-api-types';\n\nexport function convertToOpenAIResponsesMessages({\n  prompt,\n  systemMessageMode,\n}: {\n  prompt: LanguageModelV1Prompt;\n  systemMessageMode: 'system' | 'developer' | 'remove';\n}): {\n  messages: OpenAIResponsesPrompt;\n  warnings: Array<LanguageModelV1CallWarning>;\n} {\n  const messages: OpenAIResponsesPrompt = [];\n  const warnings: Array<LanguageModelV1CallWarning> = [];\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        switch (systemMessageMode) {\n          case 'system': {\n            messages.push({ role: 'system', content });\n            break;\n          }\n          case 'developer': {\n            messages.push({ role: 'developer', content });\n            break;\n          }\n          case 'remove': {\n            warnings.push({\n              type: 'other',\n              message: 'system messages are removed for this model',\n            });\n            break;\n          }\n          default: {\n            const _exhaustiveCheck: never = systemMessageMode;\n            throw new Error(\n              `Unsupported system message mode: ${_exhaustiveCheck}`,\n            );\n          }\n        }\n        break;\n      }\n\n      case 'user': {\n        messages.push({\n          role: 'user',\n          content: content.map((part, index) => {\n            switch (part.type) {\n              case 'text': {\n                return { type: 'input_text', text: part.text };\n              }\n              case 'image': {\n                return {\n                  type: 'input_image',\n                  image_url:\n                    part.image instanceof URL\n                      ? part.image.toString()\n                      : `data:${\n                          part.mimeType ?? 'image/jpeg'\n                        };base64,${convertUint8ArrayToBase64(part.image)}`,\n\n                  // OpenAI specific extension: image detail\n                  detail: part.providerMetadata?.openai?.imageDetail,\n                };\n              }\n              case 'file': {\n                if (part.data instanceof URL) {\n                  // The AI SDK automatically downloads files for user file parts with URLs\n                  throw new UnsupportedFunctionalityError({\n                    functionality: 'File URLs in user messages',\n                  });\n                }\n\n                switch (part.mimeType) {\n                  case 'application/pdf': {\n                    return {\n                      type: 'input_file',\n                      filename: part.filename ?? `part-${index}.pdf`,\n                      file_data: `data:application/pdf;base64,${part.data}`,\n                    };\n                  }\n                  default: {\n                    throw new UnsupportedFunctionalityError({\n                      functionality:\n                        'Only PDF files are supported in user messages',\n                    });\n                  }\n                }\n              }\n            }\n          }),\n        });\n\n        break;\n      }\n\n      case 'assistant': {\n        for (const part of content) {\n          switch (part.type) {\n            case 'text': {\n              messages.push({\n                role: 'assistant',\n                content: [{ type: 'output_text', text: part.text }],\n              });\n              break;\n            }\n            case 'tool-call': {\n              messages.push({\n                type: 'function_call',\n                call_id: part.toolCallId,\n                name: part.toolName,\n                arguments: JSON.stringify(part.args),\n              });\n              break;\n            }\n          }\n        }\n\n        break;\n      }\n\n      case 'tool': {\n        for (const part of content) {\n          messages.push({\n            type: 'function_call_output',\n            call_id: part.toolCallId,\n            output: JSON.stringify(part.result),\n          });\n        }\n\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return { messages, warnings };\n}\n","import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\n\nexport function mapOpenAIResponseFinishReason({\n  finishReason,\n  hasToolCalls,\n}: {\n  finishReason: string | null | undefined;\n  hasToolCalls: boolean;\n}): LanguageModelV1FinishReason {\n  switch (finishReason) {\n    case undefined:\n    case null:\n      return hasToolCalls ? 'tool-calls' : 'stop';\n    case 'max_output_tokens':\n      return 'length';\n    case 'content_filter':\n      return 'content-filter';\n    default:\n      return hasToolCalls ? 'tool-calls' : 'unknown';\n  }\n}\n","import {\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { OpenAIResponsesTool } from './openai-responses-api-types';\n\nexport function prepareResponsesTools({\n  mode,\n  strict,\n}: {\n  mode: Parameters<LanguageModelV1['doGenerate']>[0]['mode'] & {\n    type: 'regular';\n  };\n  strict: boolean;\n}): {\n  tools?: Array<OpenAIResponsesTool>;\n  tool_choice?:\n    | 'auto'\n    | 'none'\n    | 'required'\n    | { type: 'web_search_preview' }\n    | { type: 'function'; name: string };\n  toolWarnings: LanguageModelV1CallWarning[];\n} {\n  // when the tools array is empty, change it to undefined to prevent errors:\n  const tools = mode.tools?.length ? mode.tools : undefined;\n\n  const toolWarnings: LanguageModelV1CallWarning[] = [];\n\n  if (tools == null) {\n    return { tools: undefined, tool_choice: undefined, toolWarnings };\n  }\n\n  const toolChoice = mode.toolChoice;\n\n  const openaiTools: Array<OpenAIResponsesTool> = [];\n\n  for (const tool of tools) {\n    switch (tool.type) {\n      case 'function':\n        openaiTools.push({\n          type: 'function',\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n          strict: strict ? true : undefined,\n        });\n        break;\n      case 'provider-defined':\n        switch (tool.id) {\n          case 'openai.web_search_preview':\n            openaiTools.push({\n              type: 'web_search_preview',\n              search_context_size: tool.args.searchContextSize as\n                | 'low'\n                | 'medium'\n                | 'high',\n              user_location: tool.args.userLocation as {\n                type: 'approximate';\n                city: string;\n                region: string;\n              },\n            });\n            break;\n          default:\n            toolWarnings.push({ type: 'unsupported-tool', tool });\n            break;\n        }\n        break;\n      default:\n        toolWarnings.push({ type: 'unsupported-tool', tool });\n        break;\n    }\n  }\n\n  if (toolChoice == null) {\n    return { tools: openaiTools, tool_choice: undefined, toolWarnings };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n    case 'none':\n    case 'required':\n      return { tools: openaiTools, tool_choice: type, toolWarnings };\n    case 'tool': {\n      if (toolChoice.toolName === 'web_search_preview') {\n        return {\n          tools: openaiTools,\n          tool_choice: {\n            type: 'web_search_preview',\n          },\n          toolWarnings,\n        };\n      }\n      return {\n        tools: openaiTools,\n        tool_choice: {\n          type: 'function',\n          name: toolChoice.toolName,\n        },\n        toolWarnings,\n      };\n    }\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`,\n      });\n    }\n  }\n}\n","import { z } from 'zod';\n\nconst WebSearchPreviewParameters = z.object({});\n\nfunction webSearchPreviewTool({\n  searchContextSize,\n  userLocation,\n}: {\n  searchContextSize?: 'low' | 'medium' | 'high';\n  userLocation?: {\n    type?: 'approximate';\n    city?: string;\n    region?: string;\n    country?: string;\n    timezone?: string;\n  };\n} = {}): {\n  type: 'provider-defined';\n  id: 'openai.web_search_preview';\n  args: {};\n  parameters: typeof WebSearchPreviewParameters;\n} {\n  return {\n    type: 'provider-defined',\n    id: 'openai.web_search_preview',\n    args: {\n      searchContextSize,\n      userLocation,\n    },\n    parameters: WebSearchPreviewParameters,\n  };\n}\n\nexport const openaiTools = {\n  webSearchPreview: webSearchPreviewTool,\n};\n","/**\n * Creates a regular expression to match XML tags with a specific name\n * @param tagName - The name of the XML tag to match\n * @returns RegExp that matches the specified XML tag and captures its attributes and content\n */\nexport function createTagRegex(tagName: string) {\n  return new RegExp(\n    `(<${tagName}(?:\\\\s+[^>]*)?>)([\\\\s\\\\S]*?)<\\/${tagName}>`,\n    \"gs\"\n  );\n}\n\nexport function createTagParser<T = string>(\n  tagName: string,\n  contentParser?: (content: any) => T\n) {\n  const regex = createTagRegex(tagName);\n\n  return (content: string) => {\n    const matches = Array.from(content.matchAll(regex));\n    try {\n      return matches.map((t) => ({\n        tag: tagName,\n        params: t[1] ? parseAttributes(t[1]) : {},\n        content: (contentParser\n          ? contentParser(t[2]?.trim())\n          : t[2]?.trim()) as T extends string ? string : T,\n      }));\n    } catch (error) {\n      throw error;\n    }\n  };\n}\n\n// new parser\nexport type TextNode = {\n  type: \"text\";\n  content: string;\n  parent?: Node;\n  children?: never;\n};\n\nexport type ElementNode<\n  Attributes extends Record<string, string> = Record<string, any>,\n> = {\n  type: \"element\";\n  name: string;\n  attributes: Attributes;\n  content: string;\n  parent?: Node;\n  children?: Node[];\n  closed?: true;\n};\n\nexport type Node = TextNode | ElementNode;\n\nexport type NodeVisitor = (node: Node, parse: () => Node[]) => Node;\n\nexport function parseAttributes(text: string): Record<string, string> {\n  const attrs: Record<string, string> = {};\n  if (text.length === 0) return attrs;\n  const matches = text.matchAll(/(\\w+)=\"([^\"]*)\"/g);\n  for (const match of matches) {\n    attrs[match[1]] = match[2];\n  }\n  return attrs;\n}\n\nexport function parse(\n  text: string,\n  visitor: NodeVisitor,\n  depth = 0,\n  parent: Node | undefined = undefined\n): Node[] {\n  const nodes: Node[] = [];\n\n  let workingText = text.trim();\n\n  while (workingText.length > 0) {\n    // Find first opening tag\n    const tagStart = workingText.indexOf(\"<\");\n    if (tagStart === -1) {\n      const textNode: TextNode = {\n        type: \"text\",\n        content: workingText.trim(),\n      };\n      nodes.push(visitor(textNode, () => []));\n      break;\n    }\n\n    const tagEnd = workingText.indexOf(\">\", tagStart);\n\n    if (tagStart > 0 || tagEnd === -1) {\n      const textNode: TextNode = {\n        type: \"text\",\n        content: workingText.slice(0, tagEnd === -1 ? -1 : tagStart).trim(),\n      };\n      nodes.push(visitor(textNode, () => []));\n    }\n\n    // Find end of opening tag\n    if (tagEnd === -1) break;\n\n    // Parse tag and attributes\n    let tagContent = workingText.slice(tagStart + 1, tagEnd);\n    let closed = false;\n    if (tagContent.at(-1) === \"/\") {\n      closed = true;\n      tagContent = tagContent.slice(0, -1);\n    }\n\n    const [name, ...attrParts] = tagContent.split(\" \");\n    const attributes = parseAttributes(attrParts.join(\" \").trim());\n\n    // Skip if it's a closing tag\n    if (closed) {\n      workingText = workingText.slice(tagEnd + 1).trim();\n      nodes.push(\n        visitor(\n          {\n            type: \"element\",\n            name,\n            attributes,\n            content: \"\",\n            closed,\n          },\n          () => []\n        )\n      );\n      continue;\n    }\n\n    // Find last matching close tag\n    const closeTag = `</${name}>`;\n    const closePos = workingText.indexOf(closeTag);\n    if (closePos === -1) break;\n\n    // Extract content between tags\n    const content = workingText.slice(tagEnd + 1, closePos).trim();\n\n    const node: ElementNode = {\n      type: \"element\",\n      name,\n      attributes,\n      content,\n    };\n\n    if (parent) node.parent = parent;\n\n    nodes.push(visitor(node, () => parse(content, visitor, depth + 1, node)));\n    // Continue with remaining text before this tag\n    workingText = workingText.slice(closePos + closeTag.length).trim();\n  }\n  return nodes;\n}\n\nexport function isElement(node: Node): node is ElementNode {\n  return node.type === \"element\";\n}\n\nexport function isText(node: Node): node is TextNode {\n  return node.type === \"text\";\n}\n\ntype StartTag = {\n  type: \"start\";\n  name: string;\n  attributes: Record<string, string>;\n};\n\ntype EndTag = {\n  type: \"end\";\n  name: string;\n};\n\ntype TextContent = {\n  type: \"text\";\n  content: string;\n};\n\ntype SelfClosingTag = {\n  type: \"self-closing\";\n  name: string;\n  attributes: Record<string, string>;\n};\n\ntype XMLToken = StartTag | EndTag | TextContent | SelfClosingTag;\n\nconst alphaSlashRegex = /[a-zA-Z\\/]/;\n\nconst wrappers = [\"'\", \"`\", '\"', \"(\", \")\"];\n\n// todo: maybe only allow new tags in new lines or immediatly after closing one\nexport function* xmlStreamParser(\n  parseTags: Set<string>,\n  shouldParse: (tagName: string, isClosingTag: boolean) => boolean\n): Generator<XMLToken | void, void, string> {\n  let buffer = \"\";\n  let textContent = \"\";\n  let cachedLastContent = \"\";\n\n  while (true) {\n    const chunk = yield;\n    if (!chunk) continue;\n\n    buffer += chunk;\n\n    while (buffer.length > 0) {\n      const tagStart = buffer.indexOf(\"<\");\n      // detect wrapped tags ex:'<tag> and skip it\n      if (\n        tagStart === 0 &&\n        cachedLastContent &&\n        wrappers.includes(cachedLastContent.at(-1)!)\n      ) {\n        textContent += buffer[0];\n        buffer = buffer.slice(1);\n        continue;\n      }\n\n      if (tagStart > 0) {\n        if (wrappers.includes(buffer[tagStart - 1])) {\n          textContent += buffer.slice(0, tagStart + 1);\n          buffer = buffer.slice(tagStart + 1);\n        } else {\n          textContent += buffer.slice(0, tagStart);\n          buffer = buffer.slice(tagStart);\n        }\n\n        if (textContent.length > 0) {\n          yield { type: \"text\", content: textContent };\n          cachedLastContent = textContent;\n          textContent = \"\";\n        }\n\n        continue;\n      }\n\n      // todo: regex performance\n      if (\n        tagStart === -1 ||\n        (buffer.length > 1 && !alphaSlashRegex.test(buffer[tagStart + 1]))\n      ) {\n        textContent += buffer;\n        buffer = \"\";\n        break;\n      }\n\n      const tagEnd = buffer.indexOf(\">\", tagStart);\n      if (tagEnd === -1) {\n        break;\n      }\n\n      // wait for more content to detect wrapper\n      if (buffer.length === tagEnd) break;\n\n      if (wrappers.includes(buffer[tagEnd + 1])) {\n        textContent += buffer.slice(0, tagEnd + 1);\n        buffer = buffer.slice(tagEnd + 1);\n        if (textContent.length > 0) {\n          yield { type: \"text\", content: textContent };\n          cachedLastContent = textContent;\n          textContent = \"\";\n        }\n        break;\n      }\n\n      let tagContent = buffer.slice(tagStart + 1, tagEnd);\n      const isClosingTag = tagContent.startsWith(\"/\");\n      const tagName = isClosingTag\n        ? tagContent.slice(1).trim().split(\" \")[0]\n        : tagContent.trim().split(\" \")[0];\n\n      if (parseTags.has(tagName) && shouldParse(tagName, isClosingTag)) {\n        // Emit accumulated text if any\n        if (textContent.length > 0) {\n          yield { type: \"text\", content: textContent };\n          cachedLastContent = textContent;\n          textContent = \"\";\n        }\n\n        if (isClosingTag) {\n          yield { type: \"end\", name: tagName };\n        } else {\n          const attributes = parseAttributes(tagContent.slice(tagName.length));\n          yield { type: \"start\", name: tagName, attributes };\n        }\n      } else {\n        // Not a tag we care about, treat as text\n        textContent += buffer.slice(0, tagEnd + 1);\n      }\n\n      buffer = buffer.slice(tagEnd + 1);\n    }\n\n    if (textContent.length > 0) {\n      yield { type: \"text\", content: textContent };\n      cachedLastContent = textContent;\n      textContent = \"\";\n    }\n  }\n}\n","import { formatWorkingMemory } from \"../context\";\nimport {\n  formatAction,\n  formatContextLog,\n  formatContextState,\n  formatOutputInterface,\n  render,\n  xml,\n} from \"../formatters\";\nimport type {\n  AnyAction,\n  AnyContext,\n  AnyRef,\n  ContextState,\n  Log,\n  Output,\n  WorkingMemory,\n} from \"../types\";\n/*\n\n## Instructions\n- If asked for something - never do a summary unless you are asked to do a summary. Always respond with the exact information requested.\n- You must use the available actions and outputs to respond to the context.\n- You must reason about the context, think, and planned actions.\n- IMPORTANT: If you state that you will perform an action, you MUST issue the corresponding action call. Do not say you will do something without actually issuing the action call.\n- IMPORTANT: Never end your response with a plan to do something without actually doing it. Always follow through with action calls.\n- When you determine that no further actions or outputs are needed and the flow should end, use the <finalize/> tag to indicate completion.\n*/\n\nexport const templateSections = {\n  intro: `\\\n  You are tasked with analyzing inputs, formulating outputs, and initiating actions based on the given contexts. \n  You will be provided with a set of available actions, outputs, and contexts. \n  Your instructions are to analyze the situation and respond appropriately.`,\n  instructions: `\\\nFollow these steps to process the updates:\n\n1. Analyze the updates and available data:\n   Wrap your reasoning process in <reasoning> tags. Consider:\n\n   - Check the available data to avoid redundant action calls\n   - The availabe contexts and their state\n   - The available actions and their asynchronous nature\n   - The content of the new updates\n   - Potential dependencies between actions\n\n   Response determination guidelines:\n\n   a) First check if required state exists in the available contexts\n   b) Respond to direct questions or requests for information\n\n2. Plan actions:\n   Before formulating a response, consider:\n\n   - What data is already available\n   - Which actions need to be initiated\n   - The order of dependencies between actions\n   - How to handle potential action failures\n   - What information to provide while actions are processing\n\n3. Formulate a output (if needed):\n   If you decide to respond to the message, use <output> tags to enclose your output.\n   Consider:\n\n   - Using available data when possible\n   - Acknowledging that certain information may not be immediately available\n   - Setting appropriate expectations about action processing time\n   - Indicating what will happen after actions complete\n   - You can only use outputs listed in the <available_outputs> section\n   - Follow the schemas provided for each output\n  \n4. Initiate actions (if needed):\n   Use <action_call> tags to initiate actions. Remember:\n\n   - Actions are processed asynchronously after your response\n   - Results will not be immediately available\n   - You can only use actions listed in the <available_actions> section\n   - Follow the schemas provided for each action\n   - Actions should be used when necessary to fulfill requests or provide information that cannot be conveyed through a simple response\n\n5. No output or action:\n   If you determine that no output or action is necessary, don't respond to that message.`,\n  /*\n   */\n  /*\n\nConfiguration: Access pre-defined configuration values using {{config.key.name}} (e.g., {{config.default_user_id}}). (Assumption: Configuration is structured)\n\n (e.g., {{shortTermMemory.current_project_file}}).\n\n*/\n  content: `\\\nHere are the available actions you can initiate:\n{{actions}}\n\nHere are the available outputs you can use:\n{{outputs}}\n\nHere is the current contexts:\n{{contexts}}\n\n<template-engine>\nPurpose: Utilize the template engine ({{...}} syntax) primarily to streamline workflows by transferring data between different components within the same turn. This includes passing outputs from actions into subsequent action arguments, or embedding data from various sources directly into response outputs. This enhances efficiency and reduces interaction latency.\n\nData Referencing: You can reference data from:\nAction Results: Use {{calls[index].path.to.value}} to access outputs from preceding actions in the current turn (e.g., {{calls[0].sandboxId}}). Ensure the index correctly points to the intended action call.\nShort-Term Memory: Retrieve values stored in short-term memory using {{shortTermMemory.key}}\n\nWhen to Use:\nData Injection: Apply templating when an action argument or a response output requires specific data (like an ID, filename, status, or content) from an action result, configuration, or short-term memory available within the current turn.\nDirect Dependencies: Particularly useful when an action requires a specific result from an action called immediately before it in the same turn.\n</template-engine>\n\nHere is the current working memory:\n{{workingMemory}}\n\nNow, analyze the following updates:\n{{updates}}`,\n  response: `\\\nHere's how you structure your response:\n<response>\n<reasoning>\n[Your reasoning of the context, think, messages, and planned actions]\n</reasoning>\n\n[List of async action calls to be initiated, if applicable]\n<action_call name=\"[Action name]\">[action arguments using the schema as JSON]</action_call>\n\n[List of outputs, if applicable]\n<output type=\"[Output type]\" {...output attributes using the schema}>\n[output content using the content_schema]\n</output>\n</response>`,\n\n  footer: `\\\nRemember:\n- Always correlate results with their original actions using callId\n- Never repeat your outputs\n- Consider the complete chain of events when formulating responses\n- Address any failures or unexpected results explicitly\n- Initiate follow-up actions only when necessary\n- Provide clear, actionable insights based on the combined results\n- Maintain context awareness between original request and final results\n\nIMPORTANT: \nAlways include the 'type' attribute in the output tag and ensure it matches one of the available output types listed above.\nRemember to include the other attribute in the output tag and ensure it matches the output attributes schema.\nIf you say you will perform an action, you MUST issue the corresponding action call here`,\n} as const;\n\nexport const promptTemplate = `\\\n{{intro}}\n\n{{instructions}}\n\n{{content}}\n\n{{response}}\n\n{{footer}}\n`;\n\nexport function formatPromptSections({\n  contexts,\n  outputs,\n  actions,\n  workingMemory,\n  maxWorkingMemorySize,\n  chainOfThoughtSize,\n}: {\n  contexts: ContextState<AnyContext>[];\n  outputs: Output[];\n  actions: AnyAction[];\n  workingMemory: WorkingMemory;\n  maxWorkingMemorySize?: number;\n  chainOfThoughtSize?: number;\n}) {\n  return {\n    actions: xml(\"available-actions\", undefined, actions.map(formatAction)),\n    outputs: xml(\n      \"available-outputs\",\n      undefined,\n      outputs.map(formatOutputInterface)\n    ),\n    contexts: xml(\"contexts\", undefined, contexts.map(formatContextState)),\n    workingMemory: xml(\n      \"working-memory\",\n      undefined,\n      formatWorkingMemory({\n        memory: workingMemory,\n        size: maxWorkingMemorySize,\n        processed: true,\n      })\n    ),\n    thoughts: xml(\n      \"thoughts\",\n      undefined,\n      workingMemory.thoughts\n        .map((log) => formatContextLog(log))\n        .slice(-(chainOfThoughtSize ?? 5))\n    ),\n    updates: xml(\n      \"updates\",\n      undefined,\n      formatWorkingMemory({\n        memory: workingMemory,\n        processed: false,\n      })\n    ),\n  };\n}\n\n// WIP\nexport const mainStep = {\n  name: \"main\",\n  template: promptTemplate,\n  sections: templateSections,\n  render: (data: ReturnType<typeof formatPromptSections>) => {\n    const sections = Object.fromEntries(\n      Object.entries(mainStep.sections).map(([key, templateSection]) => [\n        key,\n        render(templateSection, data as any),\n      ])\n    ) as Record<keyof typeof templateSections, string>;\n\n    const prompt = render(mainStep.template, sections);\n\n    return prompt;\n  },\n\n  formatter: formatPromptSections,\n\n  shouldContinue: (state: { chain: AnyRef[] }) => {\n    const pendingResults = state.chain.filter(\n      (i) => i.ref !== \"thought\" && i.processed === false\n    );\n    return pendingResults.length > 0;\n  },\n} as const;\n\nexport type StepConfig = typeof mainStep;\n","import { ZodType } from \"zod\";\nimport zodToJsonSchema from \"zod-to-json-schema\";\nimport type { Node, ElementNode } from \"./xml\";\nimport { parse as parseXML } from \"./xml\";\nimport type { TemplateVariables } from \"./types\";\nimport { render } from \"./formatters\";\n\nexport type Formatter<\n  Variables extends Record<string, any> = Record<string, any>,\n  Data = any,\n> = (data: Data) => Record<keyof Variables, any>;\n\nexport type InferFormatter<TPrompt extends AnyPrompt> =\n  TPrompt extends Prompt<infer Data, infer Variables>\n    ? Formatter<Variables, Data>\n    : never;\n\nexport type PromptVisitor<\n  Output = any,\n  Attributes extends Record<string, any> = Record<string, any>,\n> = (\n  output: Output,\n  node: ElementNode<Attributes>,\n  parse: () => Node[]\n) => void;\n\nexport type GetVisitors<\n  Output = any,\n  T extends Record<string, Record<string, any>> = Record<\n    string,\n    Record<string, any>\n  >,\n> = {\n  [K in keyof T]?: PromptVisitor<Output, T[K]>;\n} & {\n  [key: string]: PromptVisitor<Output, any>;\n};\n\nexport type Prompt<\n  Data = any,\n  Variables extends Record<string, any> = Record<string, any>,\n> = <TData extends Data>(\n  data: TData,\n  formatter?: Formatter<Variables, TData>\n) => string;\n\nexport type AnyPrompt = Prompt<any, any>;\n\nexport type InferPromptVariables<TPrompt extends AnyPrompt> =\n  TPrompt extends Prompt<any, infer Vars> ? Vars : never;\n\nexport type InferPromptData<TPrompt extends AnyPrompt> =\n  TPrompt extends Prompt<infer Data> ? Data : never;\n\nexport type GeneratePromptConfig<\n  TPrompt extends AnyPrompt | string = any,\n  Variables extends Record<string, any> = any,\n  Data = Record<string, any>,\n  TFormatter extends Formatter<Variables, Data> = Formatter<Variables, Data>,\n> = {\n  template: TPrompt;\n  variables: Variables;\n  data: Data;\n  formatter?: TFormatter;\n};\n\nexport type InferGeneratePromptConfig<TPrompt extends AnyPrompt | string> =\n  | (TPrompt extends Prompt<infer Data, infer Variables>\n      ? GeneratePromptConfig<TPrompt, Variables, Data>\n      : never)\n  | (TPrompt extends string\n      ? GeneratePromptConfig<TPrompt, TemplateVariables<TPrompt>>\n      : never);\n\nexport type InferPromptComponents<TPrompt extends AnyPrompt | string> =\n  TPrompt extends Prompt<any, infer Components> ? Components : never;\n\nexport function getZodJsonSchema(schema: ZodType<any>) {\n  return zodToJsonSchema(schema, \"schema\").definitions!.schema;\n}\n\nexport function createPrompt<\n  Template extends string = string,\n  Variables extends TemplateVariables<Template> = TemplateVariables<Template>,\n  Data extends Record<string, any> = Record<string, any>,\n>(\n  prompt: Template,\n  formatter?: Formatter<Variables, Data>\n): Prompt<Data, Variables> {\n  return (data, customFormatter) => {\n    return render(\n      prompt,\n      customFormatter\n        ? customFormatter(data)\n        : formatter\n          ? formatter(data)\n          : data\n    );\n  };\n}\n\nexport type Parser<Output> = (content: string) => Output;\n\nexport function createParser<\n  Output = any,\n  Components extends Record<string, Record<string, any>> = Record<\n    string,\n    Record<string, any>\n  >,\n  Visitors extends GetVisitors<Output, Components> = GetVisitors<\n    Output,\n    Components\n  >,\n>(getOutput: () => Output, visitors: Visitors): Parser<Output> {\n  return (content) => {\n    const validTags = new Set(Object.keys(visitors));\n\n    // fix for bad outputs;\n\n    content = content\n      .split(\"\\n\")\n      .map((line) => {\n        // Check if line starts with '/'\n        if (line.startsWith(\"/\")) {\n          // Extract the tag name using regex\n          const match = line.match(/^\\/([^ >]+)/);\n\n          if (match && match[1]) {\n            const tagName = match[1];\n\n            // Check if this is a valid tag\n            if (validTags.has(tagName)) {\n              console.log(\"fixing line:\\n\" + line);\n              // Replace the leading '/' with '<'\n              return line.replace(\"/\", \"<\");\n            }\n          }\n        }\n\n        // Return original line if no fix needed\n        return line;\n      })\n      .join(\"\\n\");\n\n    const state = getOutput();\n\n    parseXML(content, (node, parse) => {\n      if (node.type === \"element\" && node.name in visitors) {\n        visitors[node.name](state, node as ElementNode<any>, parse);\n      }\n      return node;\n    });\n\n    return state;\n  };\n}\n","/**\n * A generic response shape for GraphQL queries.\n */\ninterface GraphQLResponse<T> {\n  data?: T;\n  errors?: Array<{\n    message: string;\n    locations?: Array<{\n      line: number;\n      column: number;\n    }>;\n    path?: string[];\n  }>;\n}\n\n/**\n * A generalized error type for convenience.\n */\nclass ApiError extends Error {\n  constructor(\n    public message: string,\n    public details?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * A helper function to perform generic REST requests.\n * - `url`: full endpoint (including protocol, domain, path)\n * - `options`: standard `fetch` options such as method, headers, body, etc.\n */\nexport async function fetchRest<ResponseType = unknown>(\n  url: string,\n  options: RequestInit = {}\n): Promise<ResponseType> {\n  try {\n    const res = await fetch(url, options);\n    if (!res.ok) {\n      throw new ApiError(`HTTP Error: ${res.status} ${res.statusText}`, {\n        status: res.status,\n        statusText: res.statusText,\n      });\n    }\n    return (await res.json()) as ResponseType;\n  } catch (error) {\n    throw error instanceof ApiError\n      ? error\n      : new ApiError(\"Unknown error during REST fetch\", error);\n  }\n}\n\n/**\n * A helper function to perform GraphQL queries.\n * - `endpoint`: the GraphQL endpoint URL.\n * - `query`: the GraphQL query string.\n * - `variables`: an optional variables object for the query.\n */\nexport async function fetchGraphQL<DataType = unknown>(\n  endpoint: string,\n  query: string,\n  variables?: Record<string, unknown>\n): Promise<DataType | Error> {\n  try {\n    const res = await fetch(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        query,\n        variables,\n      }),\n    });\n\n    if (!res.ok) {\n      throw new ApiError(`HTTP Error: ${res.status} ${res.statusText}`, {\n        status: res.status,\n        statusText: res.statusText,\n      });\n    }\n\n    const result = (await res.json()) as GraphQLResponse<DataType>;\n\n    if (result.errors && result.errors.length > 0) {\n      return new ApiError(result.errors[0].message, result.errors);\n    }\n\n    if (!result.data) {\n      return new ApiError(\"No data returned from GraphQL query\");\n    }\n\n    return result.data;\n  } catch (error) {\n    return error instanceof ApiError\n      ? error\n      : new ApiError(\"Unknown error during GraphQL fetch\", error);\n  }\n}\n","let nextRpcRequestId = 1;\n\ntype QueryParams =\n  | Record<string, string | number | boolean | null | undefined>\n  | URLSearchParams;\n\ninterface RetryOptions {\n  maxRetries?: number;\n  initialDelay?: number;\n  maxDelay?: number;\n  backoffFactor?: number;\n  retryableStatuses?: number[];\n}\n\ninterface RequestOptions extends RequestInit {\n  retryOptions?: RetryOptions;\n  params?: QueryParams;\n}\n\nconst DEFAULT_RETRY_OPTIONS: Required<RetryOptions> = {\n  maxRetries: 3,\n  initialDelay: 1000,\n  maxDelay: 30000,\n  backoffFactor: 2,\n  retryableStatuses: [408, 429, 500, 502, 503, 504],\n};\n\nclass RequestError extends Error {\n  constructor(\n    message: string,\n    public response?: Response\n  ) {\n    super(message);\n    this.name = \"RequestError\";\n  }\n}\n\nconst sleep = (ms: number): Promise<void> =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n\nconst calculateDelay = (\n  attempt: number,\n  options: Required<RetryOptions>\n): number => {\n  const delay =\n    options.initialDelay * Math.pow(options.backoffFactor, attempt - 1);\n  return Math.min(delay, options.maxDelay);\n};\n\nconst isRetryableError = (error: any): boolean =>\n  error.name === \"TypeError\" ||\n  error.name === \"AbortError\" ||\n  error instanceof RequestError;\n\nconst buildUrl = (url: string, params?: QueryParams): string => {\n  if (!params) return url;\n\n  const searchParams =\n    params instanceof URLSearchParams\n      ? params\n      : new URLSearchParams(\n          Object.entries(params)\n            .filter(([_, value]) => value != null)\n            .map(([key, value]) => [key, String(value)])\n        );\n\n  const separator = url.includes(\"?\") ? \"&\" : \"?\";\n  const queryString = searchParams.toString();\n\n  return queryString ? `${url}${separator}${queryString}` : url;\n};\n\nexport const http = {\n  async request(url: string, options?: RequestOptions): Promise<Response> {\n    const { params, ...fetchOptions } = options || {};\n    const fullUrl = buildUrl(url, params);\n\n    const retryOptions: Required<RetryOptions> = {\n      ...DEFAULT_RETRY_OPTIONS,\n      ...options?.retryOptions,\n    };\n\n    let attempt = 1;\n\n    while (true) {\n      try {\n        const res = await fetch(fullUrl, fetchOptions);\n\n        if (!res.ok) {\n          const errorText = await res.text();\n          throw new RequestError(\n            `Request failed with status ${res.status}: ${errorText}`,\n            res\n          );\n        }\n\n        return res;\n      } catch (error: any) {\n        if (isRetryableError(error) && attempt < retryOptions.maxRetries) {\n          const delay = calculateDelay(attempt, retryOptions);\n          console.warn(\n            `Request failed with error: ${error.message}. ` +\n              `Retrying in ${delay}ms (attempt ${attempt}/${retryOptions.maxRetries})`\n          );\n          await sleep(delay);\n          attempt++;\n          continue;\n        }\n\n        throw error;\n      }\n    }\n  },\n\n  async json<T = any>(url: string, options?: RequestOptions) {\n    const res = await this.request(url, {\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers,\n      },\n    });\n    return (await res.json()) as T;\n  },\n\n  get: {\n    async request(url: string, params?: QueryParams, options?: RequestInit) {\n      return http.request(url, {\n        ...options,\n        method: \"GET\",\n        params,\n      });\n    },\n    async json<T = any>(\n      url: string,\n      params?: QueryParams,\n      options?: RequestInit\n    ) {\n      return http.json<T>(url, {\n        ...options,\n        method: \"GET\",\n        params,\n      });\n    },\n  },\n\n  post: {\n    async request(url: string, body: object, options?: RequestOptions) {\n      return http.request(url, {\n        ...options,\n        method: \"POST\",\n        body: JSON.stringify(body),\n      });\n    },\n\n    async json<ReturnType = any, Body extends object = object>(\n      url: string,\n      body: Body,\n      options?: RequestOptions\n    ) {\n      return http.json<ReturnType>(url, {\n        ...options,\n        method: \"POST\",\n        body: JSON.stringify(body),\n      });\n    },\n  },\n\n  async jsonrpc<ReturnType = any, Params extends object = object>(\n    url: string,\n    method: string,\n    params: Params,\n    headers?: HeadersInit\n  ) {\n    return http.post.json<ReturnType>(\n      url,\n      {\n        jsonrpc: \"2.0\",\n        id: nextRpcRequestId++,\n        method,\n        params,\n      },\n      { headers }\n    );\n  },\n\n  async graphql<ReturnType = any, Variables extends object = object>(\n    url: string,\n    query: string,\n    variables: Variables,\n    headers?: HeadersInit\n  ) {\n    return http.post.json<ReturnType>(\n      url,\n      {\n        query,\n        variables,\n      },\n      { headers }\n    );\n  },\n};\n"],"mappings":"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","names":["require_secure_json_parse","__commonJSMin","exports","module","hasBuffer","suspectProtoRx","suspectConstructorRx","_parse","text","reviver","options","obj","protoAction","constructorAction","filter","safe","next","nodes","node","key","value","parse","stackTraceLimit","safeParse","z","LogLevel","Logger","config","context","message","data","level","entry","formatted","parts","LogLevel","logLine","createContainer","instances","factories","singletons","aliases","getTokenString","token","resolveToken","container","factory","value","aliasToken","originalToken","resolvedToken","service","config","createServiceManager","container","state","registerProvider","provider","bootProvider","randomUUIDv7","TaskRunner","concurrency","a","b","task","result","error","taskFn","priority","resolve","reject","queuedTask","params","options","key","fn","defaultOptions","execute","callId","mergedOptions","zodToJsonSchema","z","xml","tag","params","children","el","formatXml","k","v","t","formatValue","error","formatInput","input","formatOutput","output","formatSchema","schema","key","formatOutputInterface","formatAction","action","formatContextState","state","context","formatMsg","msg","formatContextLog","i","formatContextLog2","value","_","render","str","data","match","z","v7","input","config","action","output","expert","splitTextIntoChunks","text","options","maxChunkSize","lines","chunks","currentChunk","line","memory","extension","validateEnv","schema","env","error","err","defaultTrimOptions","trimWorkingMemory","workingMemory","tryAsync","fn","args","context","config","ctx","actions","inputs","outputs","getWorkingMemoryLogs","memory","includeThoughts","a","b","getWorkingMemoryAllLogs","formatWorkingMemory","processed","size","logs","i","formatContextLog","createWorkingMemory","pushToWorkingMemory","workingMemory","ref","defaultWorkingMemory","getContextId","args","key","createContextState","agent","contexts","initialSettings","id","settings","options","getContextWorkingMemory","contextId","saveContextWorkingMemory","saveContextState","state","loadContextState","saveContextsIndex","contextIds","getContextData","type","getContexts","deleteContext","createMemory","store","vector","vectorModel","createMemoryStore","data","key","value","createVectorStore","contextId","query","indexName","streamText","z","z","NotFoundError","ref","ParsingError","parsingError","parseJSONContent","content","detectTemplates","obj","foundTemplates","templatePattern","primaryKeyPattern","traverse","currentObj","currentPath","item","index","key","match","expression","primaryKeyMatch","primaryKey","getPathSegments","pathString","resolvePathSegments","source","segments","current","segment","getValueByPath","setValueByPath","target","path","value","lastIndex","i","nextKey","finalKey","resolveTemplates","argsObject","detectedTemplates","resolver","templateInfo","resolvedValue","valuePath","error","prepareActionCall","call","actions","logger","action","a","json","templates","handleActionCall","state","workingMemory","taskRunner","agent","agentState","abortSignal","pushLog","actionMemory","callCtx","pushToWorkingMemory","event","args","options","eventRef","v7","result","runAction","handleOutput","outputRef","outputs","output","schema","z","parsedContent","response","refs","res","prepareContextActions","params","context","prepareAction","t","agentCtxState","enabled","prepareContext","ctxState","inputs","type","input","_","r","ctxActions","subCtxsStates","subCtxsStatesInputs","subCtxsStatesOutputs","subCtxsActions","handleInput","inputRef","episodicMemory","data","generateObject","InvalidArgumentError","customAlphabet","alphabet","defaultSize","size","id","i","import_secure_json_parse","APICallError","LoadAPIKeyError","LoadSettingError","JSONParseError","TypeValidationError","InvalidArgumentError","EmptyResponseBodyError","combineHeaders","headers","combinedHeaders","currentHeaders","createEventSourceParserStream","buffer","event","data","lastEventId","retry","parseLine","line","controller","dispatchEvent","colonIndex","handleField","field","valueStart","value","parsedRetry","chunk","lines","incompleteLine","splitLines","i","currentLine","char","extractResponseHeaders","response","headers","key","createIdGenerator","prefix","defaultSize","alphabet","separator","generator","customAlphabet","InvalidArgumentError","size","generateId","removeUndefinedEntries","record","_key","value","isAbortError","error","loadApiKey","apiKey","environmentVariableName","apiKeyParameterName","description","LoadAPIKeyError","validatorSymbol","validator","validate","isValidator","value","asValidator","zodValidator","zodSchema","result","validateTypes","inputSchema","safeValidateTypes","TypeValidationError","schema","error","parseJSON","text","SecureJSON","JSONParseError","safeParseJSON","validationResult","isParsableJson","input","parseProviderOptions","provider","providerOptions","parsedProviderOptions","InvalidArgumentError","getOriginalFetch","postJsonToApi","url","headers","body","failedResponseHandler","successfulResponseHandler","abortSignal","fetch","postToApi","response","removeUndefinedEntries","responseHeaders","extractResponseHeaders","errorInformation","isAbortError","APICallError","cause","createJsonErrorResponseHandler","errorSchema","errorToMessage","isRetryable","response","url","requestBodyValues","responseBody","responseHeaders","extractResponseHeaders","APICallError","parsedError","parseJSON","createEventSourceResponseHandler","chunkSchema","EmptyResponseBodyError","createEventSourceParserStream","data","controller","safeParseJSON","createJsonResponseHandler","responseSchema","response","url","requestBodyValues","responseBody","parsedResult","safeParseJSON","responseHeaders","extractResponseHeaders","APICallError","btoa","atob","convertUint8ArrayToBase64","array","latin1string","i","btoa","withoutTrailingSlash","url","InvalidResponseDataError","UnsupportedFunctionalityError","z","UnsupportedFunctionalityError","z","UnsupportedFunctionalityError","z","InvalidPromptError","UnsupportedFunctionalityError","TooManyEmbeddingValuesForCallError","z","z","z","UnsupportedFunctionalityError","UnsupportedFunctionalityError","z","convertToOpenAIChatMessages","prompt","useLegacyFunctionCalling","systemMessageMode","messages","warnings","role","content","_exhaustiveCheck","part","index","_a","_b","_c","_d","convertUint8ArrayToBase64","text","toolCalls","toolResponse","mapOpenAIChatLogProbsOutput","logprobs","token","logprob","top_logprobs","mapOpenAIFinishReason","finishReason","openaiErrorDataSchema","openaiFailedResponseHandler","createJsonErrorResponseHandler","data","getResponseMetadata","id","model","created","prepareTools","mode","structuredOutputs","tools","toolWarnings","toolChoice","openaiFunctions","tool","openaiTools","type","OpenAIChatLanguageModel","modelId","settings","config","isReasoningModel","isAudioModel","maxTokens","temperature","topP","topK","frequencyPenalty","presencePenalty","stopSequences","responseFormat","seed","providerMetadata","_e","_f","_g","_h","messageWarnings","getSystemMessageMode","baseArgs","tool_choice","functions","function_call","options","body","responseHeaders","response","rawResponse","postJsonToApi","combineHeaders","createJsonResponseHandler","openaiChatResponseSchema","rawPrompt","rawSettings","choice","completionTokenDetails","promptTokenDetails","generateId","toolCall","result","controller","args","createEventSourceResponseHandler","openaiChatChunkSchema","usage","isFirstChunk","chunk","_i","_j","_k","_l","value","prompt_tokens","completion_tokens","prompt_tokens_details","completion_tokens_details","delta","mappedLogprobs","mappedToolCalls","toolCallDelta","InvalidResponseDataError","isParsableJson","openaiTokenUsageSchema","reasoningModels","convertToOpenAICompletionPrompt","inputFormat","user","assistant","InvalidPromptError","userMessage","assistantMessage","mapOpenAICompletionLogProbs","OpenAICompletionLanguageModel","userStopSequences","completionPrompt","stop","openaiCompletionResponseSchema","openaiCompletionChunkSchema","OpenAIEmbeddingModel","values","headers","abortSignal","TooManyEmbeddingValuesForCallError","openaiTextEmbeddingResponseSchema","item","modelMaxImagesPerCall","OpenAIImageModel","n","size","aspectRatio","providerOptions","currentDate","openaiImageResponseSchema","convertToOpenAIResponsesMessages","mapOpenAIResponseFinishReason","hasToolCalls","prepareResponsesTools","strict","OpenAIResponsesLanguageModel","modelConfig","getResponsesModelConfig","openaiOptions","parseProviderOptions","openaiResponsesProviderOptionsSchema","isStrict","usageSchema","outputTextElements","output","annotation","openaiResponsesChunkSchema","self","promptTokens","completionTokens","cachedPromptTokens","reasoningTokens","responseId","ongoingToolCalls","isResponseOutputItemAddedChunk","isResponseFunctionCallArgumentsDeltaChunk","isResponseCreatedChunk","isTextDeltaChunk","isResponseOutputItemDoneChunk","isResponseFinishedChunk","isResponseAnnotationAddedChunk","textDeltaChunkSchema","responseFinishedChunkSchema","responseCreatedChunkSchema","responseOutputItemDoneSchema","responseFunctionCallArgumentsDeltaSchema","responseOutputItemAddedSchema","responseAnnotationAddedSchema","WebSearchPreviewParameters","webSearchPreviewTool","searchContextSize","userLocation","createOpenAI","baseURL","withoutTrailingSlash","compatibility","providerName","getHeaders","loadApiKey","createChatModel","path","createCompletionModel","createEmbeddingModel","createImageModel","createLanguageModel","createResponsesModel","provider","openai","z","randomUUIDv7","isBrowser","fs","path","generateEpisodicMemory","agent","thoughts","actions","results","extractEpisode","generateObject","openai","createTrainingDataPair","episodicMemory","prompt","completion","saveTrainingData","trainingData","filePath","dir","jsonLines","item","error","createEpisodeFromWorkingMemory","options","trainingDataPair","existingData","line","exportEpisodesAsTrainingData","episodes","episode","generateEpisode","thought","actionCall","result","contextId","action","a","createTagRegex","tagName","createTagParser","contentParser","regex","content","matches","t","parseAttributes","error","text","attrs","match","parse","visitor","depth","parent","nodes","workingText","tagStart","textNode","tagEnd","tagContent","closed","name","attrParts","attributes","closeTag","closePos","node","isElement","isText","alphaSlashRegex","wrappers","xmlStreamParser","parseTags","shouldParse","buffer","textContent","cachedLastContent","chunk","isClosingTag","pDefer","handleStream","textStream","initialIndex","tags","fn","ctx","current","stack","index","parser","xmlStreamParser","tag","isClosingTag","stackIndex","el","closed","handleChunk","chunk","result","wrapStream","stream","prefix","suffix","value","defaultTags","createContextStreamHandler","agent","ctxState","agentCtxState","logger","handlers","taskRunner","workingMemory","stepConfig","abortSignal","subscriptions","runRef","v7","createStep","newStep","state","handlePushLog","prepare","actions","contexts","outputs","inputs","prepareContext","params","createErrorEvent","name","data","getOrCreateRef","ref","pushLogStream","log","done","handleInput","handleOutputStream","handleActionCallStream","lastThought","lastActionCall","generateEpisode","error","saveContextWorkingMemory","subscriber","call","action","json","templates","prepareActionCall","resolveTemplates","key","path","resultPath","getPathSegments","resolvePathSegments","results","shortTermMemory","getValueByPath","schema","z","handleActionCall","subCtxState","err","res","outputRef","refs","handleOutput","NotFoundError","ParsingError","handler","_","type","modelsResponseConfig","reasoningModels","prepareStreamResponse","model","stream","isReasoningModel","prefix","suffix","result","wrapStream","runGenerate","task","prompt","workingMemory","onError","abortSignal","callId","debug","messages","streamText","event","error","runAction","ctx","action","agent","logger","templateSections","promptTemplate","formatPromptSections","contexts","outputs","actions","workingMemory","maxWorkingMemorySize","chainOfThoughtSize","xml","formatAction","formatOutputInterface","formatContextState","formatWorkingMemory","log","formatContextLog","mainStep","data","sections","key","templateSection","render","state","i","createDreams","config","booted","inputSubscriptions","contextIds","contexts","contextsRunning","workingMemories","ctxSubscriptions","registry","promptTemplate","inputs","outputs","events","actions","experts","services","extensions","model","reasoningModel","exportTrainingData","trainingDataPath","container","createContainer","taskRunner","TaskRunner","logger","Logger","debug","args","serviceManager","createServiceManager","service","ctx","extension","context","agent","createMemory","createMemoryStore","createVectorStore","event","data","contextId","handler","subs","getContexts","id","type","stateSnapshot","loadContextState","state","createContextState","params","z","getContextId","ctxState","workingMemory","saveContextState","saveContextWorkingMemory","saveContextsIndex","getContextWorkingMemory","deleteContext","tryAsync","input","subscription","err","output","action","savedContexts","agentState","handlers","abortSignal","ctxId","agentContextEntry","agentCtxState","push","el","tags","stepConfig","createContextStreamHandler","mainStep","maxSteps","getMaxSteps","log","stepRef","promptData","prompt","streamError","unprocessed","i","stream","getTextResponse","runGenerate","error","handleStream","response","inputRef","v7","memory","filePath","allEpisodes","episodes","exportEpisodesAsTrainingData","zodToJsonSchema","getZodJsonSchema","schema","zodToJsonSchema","createPrompt","prompt","formatter","data","customFormatter","render","createParser","getOutput","visitors","content","validTags","line","match","tagName","state","parse","node","ApiError","message","details","fetchGraphQL","endpoint","query","variables","res","ApiError","result","error","nextRpcRequestId","DEFAULT_RETRY_OPTIONS","RequestError","message","response","sleep","ms","resolve","calculateDelay","attempt","options","delay","isRetryableError","error","buildUrl","url","params","searchParams","_","value","key","separator","queryString","http","fetchOptions","fullUrl","retryOptions","res","errorText","body","method","headers","query","variables"]}