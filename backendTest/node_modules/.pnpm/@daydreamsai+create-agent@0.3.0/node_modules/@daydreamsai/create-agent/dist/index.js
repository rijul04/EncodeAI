#!/usr/bin/env node

// src/index.ts
import path from "path";
import fs from "fs-extra";
import { Command } from "commander";
import chalk from "chalk";
import ora from "ora";
import { execa } from "execa";
import prompts from "prompts";
import { fileURLToPath } from "url";

// src/utils.ts
function generateTemplateContent(templateContent, modelConfig, extensionImports = [], extensionsList = []) {
  let processedContent = templateContent;
  Object.entries(modelConfig).forEach(([key, value]) => {
    const placeholder = new RegExp(`{{${key}}}`, "g");
    processedContent = processedContent.replace(placeholder, value);
  });
  if (extensionImports.length > 0) {
    processedContent = processedContent.replace(
      `import { cli } from "@daydreamsai/core/extensions";`,
      extensionImports.join("\n")
    );
  }
  if (extensionsList.length > 0) {
    processedContent = processedContent.replace(
      "extensions: [cli]",
      `extensions: [${extensionsList.join(", ")}]`
    );
  }
  const headerComment = `/**
 * Daydreams agent with ${extensionsList.join(", ")} extension(s)
 * Using ${modelConfig.MODEL_NAME} as the model provider
 */`;
  processedContent = processedContent.replace(
    /\/\*\*[\s\S]*?\*\//,
    headerComment
  );
  return processedContent;
}
function createEnvVariables(selectedModel, selectedExtensions) {
  const envVariables = ["# Daydreams Environment Variables\n"];
  envVariables.push("# Model Configurations");
  if (selectedModel === "groq") {
    envVariables.push("GROQ_API_KEY=your_groq_api_key");
  } else if (selectedModel === "openai") {
    envVariables.push("OPENAI_API_KEY=your_openai_api_key");
  } else if (selectedModel === "anthropic") {
    envVariables.push("ANTHROPIC_API_KEY=your_anthropic_api_key");
  } else if (selectedModel === "google") {
    envVariables.push("GOOGLE_API_KEY=your_google_api_key");
  }
  envVariables.push("OPENROUTER_API_KEY=your_openrouter_api_key\n");
  if (selectedExtensions.includes("twitter")) {
    envVariables.push("# Twitter Configuration");
    envVariables.push("# Method 1: Username/Password");
    envVariables.push("TWITTER_USERNAME=your_twitter_username");
    envVariables.push("TWITTER_PASSWORD=your_twitter_password");
    envVariables.push("TWITTER_EMAIL=your_twitter_email");
    envVariables.push("# Method 2: API Keys");
    envVariables.push("TWITTER_CONSUMER_KEY=your_consumer_key");
    envVariables.push("TWITTER_CONSUMER_SECRET=your_consumer_secret");
    envVariables.push("TWITTER_ACCESS_TOKEN=your_access_token");
    envVariables.push("TWITTER_ACCESS_TOKEN_SECRET=your_access_token_secret\n");
  }
  if (selectedExtensions.includes("discord")) {
    envVariables.push("# Discord Configuration");
    envVariables.push(
      "# Discord Bot Token (https://discord.com/developers/applications)"
    );
    envVariables.push(
      "# Required Gateway Intents: Server Members, Message Content, Presence"
    );
    envVariables.push("DISCORD_TOKEN=your_discord_token");
    envVariables.push("DISCORD_BOT_NAME=your_bot_name\n");
  }
  if (selectedExtensions.includes("telegram")) {
    envVariables.push("# Telegram Configuration");
    envVariables.push(
      "# TELEGRAM_STARTUP_CHAT_ID: Chat ID where startup notifications will be sent"
    );
    envVariables.push("TELEGRAM_STARTUP_CHAT_ID=your_startup_chat_id");
    envVariables.push(
      "# GramJS Configuration (required for both bot and user clients)"
    );
    envVariables.push(
      "# TELEGRAM_TOKEN: Bot token from @BotFather (required for bot mode)"
    );
    envVariables.push("TELEGRAM_TOKEN=your_telegram_token");
    envVariables.push("# Get these from https://my.telegram.org/apps");
    envVariables.push("TELEGRAM_API_ID=your_api_id");
    envVariables.push("TELEGRAM_API_HASH=your_api_hash");
    envVariables.push("# Optional: Session string for user authentication");
    envVariables.push(
      "# After first successful interactive login, the app will provide a session string"
    );
    envVariables.push(
      "# Save it here to avoid interactive login in subsequent runs"
    );
    envVariables.push("TELEGRAM_USER_SESSION=your_session_string\n");
  }
  envVariables.push("# General Configuration");
  envVariables.push("DRY_RUN=1");
  envVariables.push(
    "GRAPHQL_URL=https://api.cartridge.gg/x/sepolia-rc-18/torii\n"
  );
  envVariables.push("# Blockchain Configurations");
  envVariables.push("# Starknet Configuration");
  envVariables.push("STARKNET_RPC_URL=your_starknet_rpc_url");
  envVariables.push("STARKNET_ADDRESS=your_starknet_address");
  envVariables.push("STARKNET_PRIVATE_KEY=your_starknet_private_key\n");
  envVariables.push("# Hyperliquid Trading Configuration");
  envVariables.push(
    "# HYPERLIQUID_MAIN_ADDRESS: Your main Hyperliquid address (format: 0x...)"
  );
  envVariables.push(
    "# HYPERLIQUID_WALLET_ADDRESS: Your wallet address for trading (format: 0x...)"
  );
  envVariables.push(
    "# HYPERLIQUID_PRIVATE_KEY: Your private key (Keep this secure!)"
  );
  envVariables.push("HYPERLIQUID_MAIN_ADDRESS=your_main_address");
  envVariables.push("HYPERLIQUID_WALLET_ADDRESS=your_wallet_address");
  envVariables.push("HYPERLIQUID_PRIVATE_KEY=your_private_key\n");
  envVariables.push("# Sui Configuration");
  envVariables.push(
    "# Sui Mnemonic Seed Phrase (`sui keytool generate ed25519`), Also support `suiprivatekeyxxxx` (sui keytool export --key-identity 0x63)"
  );
  envVariables.push("SUI_PRIVATE_KEY=your_sui_private_key");
  envVariables.push(
    "SUI_NETWORK=mainnet   # must be one of mainnet, testnet, devnet, localnet\n"
  );
  return envVariables.join("\n");
}
function createReadme(projectName, selectedExtensions, selectedModel) {
  return `# ${projectName}

A Daydreams agent with the following extensions:
${selectedExtensions.map((ext) => `- ${ext}`).join("\n")}

## Features

- Uses ${selectedModel} as the model provider
- Includes context for managing goals and tasks
- Provides actions for adding and completing tasks

## Getting Started

1. Copy \`.env.example\` to \`.env\` and fill in the required values.
2. Install dependencies:

\`\`\`
bun install
\`\`\`

3. Run the agent:

\`\`\`
bun start
\`\`\`

## Customizing Your Agent

You can modify the \`index.ts\` file to add more contexts, actions, or change the model configuration.
`;
}

// src/index.ts
var __filename = fileURLToPath(import.meta.url);
var __dirname = path.dirname(__filename);
var program = new Command().name("create-agent").description("Bootstrap a new Daydreams agent").version("0.1.0").argument("[directory]", "Directory to create the agent in").option("--twitter", "Include Twitter extension").option("--discord", "Include Discord extension").option("--cli", "Include CLI extension").option("--telegram", "Include Telegram extension").option("--all", "Include all extensions").option(
  "--model <model>",
  "Specify the model to use (openai, groq, anthropic, google)",
  "groq"
);
async function main(testArgs, testOpts, testTemplateContent) {
  if (!testArgs && !testOpts) {
    program.parse(process.argv);
  }
  const options = testOpts || program.opts();
  const targetDir = testArgs && testArgs[0] || program.args[0] || ".";
  const cwd = process.cwd();
  const targetPath = path.resolve(cwd, targetDir);
  if (fs.existsSync(targetPath)) {
    const files = await fs.readdir(targetPath);
    if (files.length > 0) {
      const { proceed } = await prompts({
        type: "confirm",
        name: "proceed",
        message: `Directory ${chalk.cyan(targetPath)} is not empty. Continue?`,
        initial: false
      });
      if (!proceed) {
        console.log(chalk.red("Aborted."));
        return;
      }
    }
  } else {
    await fs.mkdir(targetPath, { recursive: true });
  }
  console.log();
  console.log(chalk.bold("Creating a new Daydreams agent..."));
  console.log();
  const availableExtensions = ["cli", "twitter", "discord", "telegram"];
  let selectedExtensions = [];
  if (options.all) {
    selectedExtensions = [...availableExtensions];
  } else {
    selectedExtensions = availableExtensions.filter((ext) => options[ext]);
    if (selectedExtensions.length === 0) {
      const { extensions } = await prompts({
        type: "multiselect",
        name: "extensions",
        message: "Select extensions to include",
        choices: [
          { title: "CLI", value: "cli" },
          { title: "Twitter", value: "twitter" },
          { title: "Discord", value: "discord" },
          { title: "Telegram", value: "telegram" }
        ]
      });
      if (!extensions || extensions.length === 0) {
        console.log(
          chalk.yellow(
            "No extensions selected. Including CLI extension by default."
          )
        );
        selectedExtensions = ["cli"];
      } else {
        selectedExtensions = extensions;
      }
    }
  }
  const validModels = ["openai", "groq", "anthropic", "google"];
  let selectedModel = options.model || "groq";
  if (!validModels.includes(selectedModel)) {
    const { model } = await prompts({
      type: "select",
      name: "model",
      message: "Select the model provider to use",
      choices: [
        { title: "Groq", value: "groq" },
        { title: "OpenAI", value: "openai" },
        { title: "Anthropic", value: "anthropic" },
        { title: "Google", value: "google" }
      ],
      initial: 0
    });
    selectedModel = model;
  }
  const spinner = ora("Creating package.json").start();
  const packageJson = {
    name: path.basename(targetPath),
    version: "0.1.0",
    type: "module",
    scripts: {
      start: "bun run index.ts",
      build: "tsc"
    },
    dependencies: {
      "@daydreamsai/core": "^0.2.13",
      "@ai-sdk/anthropic": "^1.1.6",
      "@ai-sdk/google": "^1.1.16",
      "@ai-sdk/groq": "^1.1.7",
      "@ai-sdk/openai": "^1.1.14",
      "@openrouter/ai-sdk-provider": "^0.2.1",
      ai: "^4.1.25",
      chalk: "^5.4.1",
      "discord.js": "^14.17.3",
      telegraf: "^4.16.3",
      typescript: "^5.3.3",
      zod: "^3.24.1"
    }
  };
  if (selectedExtensions.includes("discord")) {
    packageJson.dependencies["discord.js"] = "^14.14.1";
  }
  await fs.writeFile(
    path.join(targetPath, "package.json"),
    JSON.stringify(packageJson, null, 2)
  );
  spinner.succeed("Created package.json");
  spinner.start("Creating tsconfig.json");
  const tsconfigJson = {
    compilerOptions: {
      target: "ES2020",
      module: "NodeNext",
      moduleResolution: "NodeNext",
      esModuleInterop: true,
      strict: true,
      skipLibCheck: true,
      outDir: "dist"
    },
    include: ["*.ts"],
    exclude: ["node_modules"]
  };
  await fs.writeFile(
    path.join(targetPath, "tsconfig.json"),
    JSON.stringify(tsconfigJson, null, 2)
  );
  spinner.succeed("Created tsconfig.json");
  spinner.start(
    `Creating agent with ${selectedModel} model and selected extensions`
  );
  let templateContent;
  if (testTemplateContent) {
    templateContent = testTemplateContent;
  } else {
    const templateFile = path.join(
      __dirname,
      "..",
      "templates",
      "basic",
      "template.ts"
    );
    if (!fs.existsSync(templateFile)) {
      spinner.fail(`Template file not found: ${templateFile}`);
      console.error(
        chalk.red(
          `Error: Template file not found. Please check your installation.`
        )
      );
      return;
    }
    templateContent = await fs.readFile(templateFile, "utf-8");
  }
  const modelConfig = {
    groq: {
      MODEL_NAME: "Groq",
      MODEL_IMPORT_FUNCTION: "createGroq",
      MODEL_IMPORT_PATH: "@ai-sdk/groq",
      ENV_VAR_KEY: "GROQ_API_KEY",
      MODEL_VARIABLE: "groq",
      MODEL_VERSION: "deepseek-r1-distill-llama-70b"
    },
    openai: {
      MODEL_NAME: "OpenAI",
      MODEL_IMPORT_FUNCTION: "createOpenAI",
      MODEL_IMPORT_PATH: "@ai-sdk/openai",
      ENV_VAR_KEY: "OPENAI_API_KEY",
      MODEL_VARIABLE: "openai",
      MODEL_VERSION: "gpt-4o"
    },
    anthropic: {
      MODEL_NAME: "Anthropic",
      MODEL_IMPORT_FUNCTION: "createAnthropic",
      MODEL_IMPORT_PATH: "@ai-sdk/anthropic",
      ENV_VAR_KEY: "ANTHROPIC_API_KEY",
      MODEL_VARIABLE: "anthropic",
      MODEL_VERSION: "claude-3-opus-20240229"
    },
    google: {
      MODEL_NAME: "Google",
      MODEL_IMPORT_FUNCTION: "createGoogle",
      MODEL_IMPORT_PATH: "@ai-sdk/google",
      ENV_VAR_KEY: "GOOGLE_API_KEY",
      MODEL_VARIABLE: "google",
      MODEL_VERSION: "gemini-1.5-pro"
    }
  };
  const config = modelConfig[selectedModel];
  const extensionImports = [];
  const extensionsList = [];
  for (const ext of selectedExtensions) {
    if (ext === "cli") {
      extensionImports.push(
        `import { cli } from "@daydreamsai/core/extensions";`
      );
      extensionsList.push("cli");
    } else if (ext === "twitter") {
      extensionImports.push(
        `import { twitter } from "@daydreamsai/core/extensions";`
      );
      extensionsList.push("twitter");
    } else if (ext === "discord") {
      extensionImports.push(
        `import { discord } from "@daydreamsai/core/extensions";`
      );
      extensionsList.push("discord");
    } else if (ext === "telegram") {
      extensionImports.push(
        `import { telegram } from "@daydreamsai/core/extensions";`
      );
      extensionsList.push("telegram");
    }
  }
  const processedContent = generateTemplateContent(
    templateContent,
    config,
    extensionImports,
    extensionsList
  );
  await fs.writeFile(path.join(targetPath, "index.ts"), processedContent);
  spinner.succeed(
    `Created agent with ${selectedModel} model and extensions: ${selectedExtensions.join(", ")}`
  );
  spinner.start("Creating .env file");
  const envContent = createEnvVariables(selectedModel, selectedExtensions);
  await fs.writeFile(path.join(targetPath, ".env.example"), envContent);
  spinner.succeed("Created .env.example file");
  spinner.start("Creating README");
  const readmeContent = createReadme(
    path.basename(targetPath),
    selectedExtensions,
    selectedModel
  );
  await fs.writeFile(path.join(targetPath, "README.md"), readmeContent);
  spinner.succeed("Created README");
  spinner.start("Installing dependencies with pnpm");
  try {
    await execa("pnpm", ["install"], { cwd: targetPath });
    const nodeModulesPath = path.join(targetPath, "node_modules");
    const nodeModulesExists = await fs.pathExists(nodeModulesPath);
    if (nodeModulesExists) {
      spinner.succeed("Installed dependencies using pnpm");
    } else {
      spinner.fail(
        "Dependencies installed but node_modules directory wasn't found"
      );
      console.log(
        chalk.yellow(
          "You can install dependencies manually by running 'pnpm install' in the project directory."
        )
      );
    }
  } catch (error) {
    spinner.fail("Failed to install dependencies");
    console.error(
      chalk.red(
        `Error: ${error instanceof Error ? error.message : String(error)}`
      )
    );
    console.log(
      chalk.yellow(
        "You can install dependencies manually by running 'pnpm install' in the project directory."
      )
    );
  }
  console.log();
  console.log(
    chalk.green("\u2705 Your Daydreams agent has been created successfully!")
  );
  console.log();
  console.log(`To get started, run the following commands:`);
  if (targetDir !== ".") {
    console.log(`  cd ${targetDir}`);
  }
  console.log(`  cp .env.example .env`);
  console.log(`  # Fill in the required environment variables in .env`);
  console.log(`  npm start`);
  console.log();
}
if (import.meta.url && process.argv[1] && (import.meta.url.endsWith(process.argv[1]) || process.argv[1].endsWith("index.js") || process.argv[1].endsWith("create-agent"))) {
  main().catch((error) => {
    console.error(
      chalk.red(
        `Error: ${error instanceof Error ? error.message : String(error)}`
      )
    );
    process.exit(1);
  });
}
export {
  main
};
