import{A as Ae,B as ve,C as B,D as Z,E as K,F as ke,G as X,H as tt,I as Ce,J as j,K as et,L as Se,M as Pe,N as Oe,O as mt,P as W,Q as U,R as nt,a as ut,b as Ht,c as oe,d as ct,e as ae,f as pt,g as se,h as ie,i as ue,j as ce,k as lt,l as pe,m as le,n as gt,o as dt,p as ge,q as de,r as me,s as ye,t as fe,u as he,v as xe,w as be,x as Te,y as we,z as L}from"./chunk-3S76ZAL5.js";var Jt=()=>{let t=new Map,e=new Map,r=new Set,o=new Map,a=i=>typeof i=="string"?i:typeof i=="symbol"?i.toString():typeof i=="function"?i.name||"anonymous function":"unknown token",u=i=>(typeof i=="string"||typeof i=="symbol")&&o.get(i)||i,c={register:(i,l)=>(e.set(i,l),t.delete(i),c),singleton:(i,l)=>(e.set(i,l),r.add(i),t.delete(i),c),instance:(i,l)=>(t.set(i,l),e.delete(i),r.delete(i),c),alias:(i,l)=>(o.set(i,l),c),resolve:i=>{let l=u(i);if(t.has(l))return t.get(l);let d=e.get(l);if(!d)throw new Error(`No registration found for ${a(l)}`);return r.has(l)?(t.has(l)||t.set(l,d(c)),t.get(l)):d(c)}};return c},yt=Jt;import{v7 as ft}from"uuid";var G=class{queue=[];running=new Set;concurrency;processing=!1;constructor(e=1){this.concurrency=e}setConcurrency(e){this.concurrency=e,this.processQueue()}async processQueue(){if(!this.processing){this.processing=!0;try{for(;this.queue.length>0&&this.running.size<this.concurrency;){this.queue.sort((r,o)=>o.priority-r.priority);let e=this.queue.shift();if(!e)break;this.running.add(e.id),e.execute().then(r=>{e.resolve(r)}).catch(r=>{e.reject(r)}).finally(()=>{this.running.delete(e.id),this.processQueue()})}}finally{this.processing=!1}}}enqueue(e,r=0){return new Promise((o,a)=>{let u={id:ft(),execute:e,priority:r,resolve:o,reject:a};this.queue.push(u),setTimeout(()=>this.processQueue(),0)})}get activeTasksCount(){return this.running.size}get queuedTasksCount(){return this.queue.length}enqueueTask(e,r,o={}){return this.enqueue(()=>e(r,o),o.priority??0)}};function H(t,e,r){async function o(a,u){let c=u?.callId??ft(),i={...r,...u};delete i.callId;try{return await Promise.resolve(e(a,{callId:c,debug:i?.debug??(()=>{})}))}catch(l){throw l}}return o}function ht(t,e,r){return{store:t,vector:e,vectorModel:r}}async function De(t,e){let r=await t.get(e);return r||{inputs:[],outputs:[],thoughts:[],calls:[],results:[]}}var J=new Map;function xt(){return{async get(t){return J.get(t)??null},async clear(){J.clear()},async delete(t){J.delete(t)},async set(t,e){J.set(t,e)}}}function bt(){return{upsert(t,e){return Promise.resolve()},query(t,e){return Promise.resolve([])},createIndex(t){return Promise.resolve()},deleteIndex(t){return Promise.resolve()}}}import{smoothStream as Et,streamText as Vt}from"ai";import"zod";import $t from"zod-to-json-schema";function je(t){return $t(t,"schema").definitions.schema}function rt(t,e){return(r,o)=>dt(t,o?o(r):e?e(r):r)}function Tt(t,e){return r=>{let o=new Set(Object.keys(e));r=r.split(`
`).map(u=>{if(u.startsWith("/")){let c=u.match(/^\/([^ >]+)/);if(c&&c[1]){let i=c[1];if(o.has(i))return console.log(`fixing line:
`+u),u.replace("/","<")}}return u}).join(`
`);let a=t();return lt(r,(u,c)=>(u.type==="element"&&u.name in e&&e[u.name](a,u,c),u)),a}}var zt=`
You are tasked with analyzing messages, formulating responses, and initiating actions based on a given context. 
You will be provided with a set of available actions, outputs, and a current context. 
Your instructions is to analyze the situation and respond appropriately.

Follow these steps to process the updates:

1. Analyze the updates and available data:
   Wrap your reasoning process in <reasoning> tags. Consider:

   - Check the available data to avoid redundant action calls
   - The availabe contexts and their state
   - The available actions and their asynchronous nature
   - The content of the new updates
   - Potential dependencies between actions

   Response determination guidelines:

   a) First check if required state exists in the available contexts
   b) Respond to direct questions or requests for information

2. Plan actions:
   Before formulating a response, consider:

   - What data is already available
   - Which actions need to be initiated
   - The order of dependencies between actions
   - How to handle potential action failures
   - What information to provide while actions are processing

3. Formulate a output (if needed):
   If you decide to respond to the message, use <output> tags to enclose your output.
   Consider:

   - Using available data when possible
   - Acknowledging that certain information may not be immediately available
   - Setting appropriate expectations about action processing time
   - Indicating what will happen after actions complete

4. Initiate actions (if needed):
   Use <action_call> tags to initiate actions. Remember:

   - Actions are processed asynchronously after your response
   - Results will not be immediately available
   - You can only use actions listed in the <available_actions> section
   - Follow the schemas provided for each action
   - Actions should be used when necessary to fulfill requests or provide information that cannot be conveyed through a simple response
   - IMPORTANT: If you say you will perform an action, you MUST issue the corresponding action call here

5. No output or action:
   If you determine that no output or action is necessary, don't respond to that message.

Here are the available actions you can initiate:
<available_actions>
{{actions}}
</available_actions>

Here are the available outputs you can use:
<outputs>
{{outputs}}
</outputs>

Here is the current contexts:
<contexts>
{{context}}
</contexts>

Now, analyze the following updates to contexts:
<contexts>
{{updates}}
</contexts>

Here's how you structure your response:
<response>
<reasoning>
[Your reasoning of the context, think, messages, and planned actions]
</reasoning>

[List of async action calls to be initiated, if applicable]
<action_call name="[Action name]">[action arguments using the schema as JSON]</action_call>

[List of outputs, if applicable]
<output type="[Output type]">
[output data using the schema]
</output>
</response>

IMPORTANT: Always include the 'type' attribute in the output tag and ensure it matches one of the available output types listed above.
{{examples}}
`,wt=rt(zt,({outputs:t,actions:e,updates:r,context:o})=>({context:o,outputs:t.map(B),actions:e.length>0?e.map(Z):"NO ACTIONS AVAILABLE",updates:r,examples:[]})),At=Tt(()=>({think:[],reasonings:[],calls:[],outputs:[],response:void 0}),{response:(t,e,r)=>(t.response=e.content,r()),action_call:(t,e)=>{let[r,o]=[void 0,void 0];try{r=JSON.parse(e.content)}catch(a){o=a}t.calls.push({name:e.attributes.name,data:r,error:o})},think:(t,e)=>{t.think.push(e.content)},reasoning:(t,e)=>{t.reasonings.push(e.content)},output:(t,e)=>{t.outputs.push({type:e.attributes.type,content:e.content})}}),Qt=`
You are an AI agent tasked with analyzing the results of previously initiated actions and formulating appropriate responses based on these results. 
You will be provided with the original context, your previous analysis, and the results of the actions you initiated.

Follow these steps to process the <action_results>:

1. Analyze the results:
   Wrap your thinking process in <reasoning> tags. Consider:

   - The original context and your previous analysis
   - The results of each <action_call> by their id
   - Any dependencies between action results
   - Success or failure status of each action
   - Whether the combined results fulfill the original request

2. Correlate results with previous actions:
   For each action result:

   - Match it with the corresponding action using callId
   - Validate if the result meets the expected outcome
   - Identify any missing or incomplete results
   - You must determine if additional actions are needed based on these results

3. Formulate a response (if needed):
   If you decide to respond to the message, use <response> tags to enclose your response.
   Consider:

   - Using available data when possible
   - Acknowledging that certain information may not be immediately available
   - Setting appropriate expectations about action processing time
   - Addressing any failures or unexpected results
   - Providing relevant insights from the combined results
   - Indicating if any follow-up actions are needed

4. Initiate follow-up actions (if needed):
   Use <action_call> tags to initiate actions. Remember:

   - Actions are processed asynchronously after your response
   - Results will not be immediately available
   - You can only use actions listed in the <available_actions> section
   - Follow the schemas provided for each action
   - Actions should be used when necessary to fulfill requests or provide information that cannot be conveyed through a simple response
   - IMPORTANT: If you say you will perform an action, you MUST issue the corresponding action call here
   - IMPORTANT: Never end your response with a plan to do something without actually doing it. Always follow through with action calls.

Here are the available actions you can initiate:
<available_actions>
{{actions}}
</available_actions>

Here are the available outputs you can use:
<outputs>
{{outputs}}
</outputs>

Here is the current contexts:
<contexts>
{{context}}
</contexts>

Here is the contexts that triggered the actions:
<contexts>
{{updates}}
</contexts>

Now, review your current chain of reasoning/actions/outputs:

<chain>
{{logs}}
</chain>

Now, analyze the latests action results:

<action_results>
{{results}}
</action_results>

Here's how you should structure your next response:
<response>
<reasoning>
[Your reasoning of the context, think, messages, and planned actions]
</reasoning>

[List of async action calls to be initiated, if applicable]
<action_call name="[Action name]">[action arguments using the schema as JSON]</action_call>

[List of outputs, if applicable]
<output type="[Output type]">
[output data using the schema]
</output>

</response>

# Remember
- Always correlate results with their original actions using callId
- Never repeat your outputs
- Consider the complete chain of results when formulating responses
- Address any failures or unexpected results explicitly
- Initiate follow-up actions only when necessary
- Provide clear, actionable insights based on the combined results
- Maintain context awareness between original request and final results

IMPORTANT: Always include the 'type' attribute in the output tag and ensure it matches one of the available output types listed above.
`,vt=rt(Qt,({outputs:t,actions:e,updates:r,context:o,logs:a,results:u})=>({logs:a.map(c=>X(c)).flat(),results:u.map(X),context:o,outputs:t.map(B),actions:e.map(Z),updates:r,examples:[]}));var ot=class extends Error{constructor(r){super();this.call=r}},at=class extends Error{constructor(r){super();this.parsingError=r}};async function kt({call:t,actions:e,logger:r}){let o=e.find(a=>a.name===t.name);if(!o)throw r.error("agent:action","ACTION_MISMATCH",{name:t.name,data:t.content}),new ot(t);try{let a=o.schema.parse(t.content.length>0?JSON.parse(t.content):{});return t.data=a,{action:o,data:a}}catch(a){throw new at(a)}}async function Ct({state:t,workingMemory:e,action:r,logger:o,call:a,taskRunner:u,agent:c,agentState:i,abortSignal:l}){let d;r.memory&&(d=await c.memory.store.get(r.memory.key)??r.memory.create());let g=await u.enqueueTask(Pt,{action:r,call:a,agent:c,logger:o,ctx:{...t,workingMemory:e,actionMemory:d,agentMemory:i?.memory,abortSignal:l}},{debug:c.debugger}),f={ref:"action_result",id:L(),callId:a.id,data:g,name:a.name,timestamp:Date.now(),processed:!1};return r.format&&(f.formatted=r.format(f)),r.memory&&await c.memory.store.set(r.memory.key,d),f}async function St({outputRef:t,outputs:e,logger:r,state:o,workingMemory:a,agent:u}){let c=e.find(i=>i.type===t.type);if(!c)return r.error("agent:output","OUTPUT_NOT_FOUND",{outputRef:t,availableOutputs:e.map(i=>i.type)}),{...t,params:{error:"OUTPUT NOT FOUND"},timestamp:Date.now(),data:{content:t.data,error:"OUTPUT NOT FOUND"}};r.debug("agent:output",t.type,t.data);try{let i=t.data;if(typeof i=="string"&&c.schema._def.typeName!=="ZodString")try{i=JSON.parse(i.trim())}catch(g){throw console.log("failed parsing output content",{content:i}),g}let l;try{l=c.schema.parse(i)}catch(g){throw console.log("failed parsing output schema"),g}let d=await c.handler(l,{...o,workingMemory:a},u);if(Array.isArray(d)){let g=[];for(let f of d){let h={...t,id:L(),...f};h.formatted=c.format?c.format(d):void 0,g.push(h)}return g}else if(d){let g={...t,...d};return g.formatted=c.format?c.format(d):void 0,g}return{...t,formatted:c.format?c.format(l):void 0,data:l}}catch(i){let l={...t,params:{error:"true"},timestamp:Date.now(),data:{content:t.data,error:i}};return r.error("agent:output",t.type,i),l}}import{generateObject as Yt}from"ai";import{openai as Bt}from"@ai-sdk/openai";import{z as $}from"zod";import{v7 as Zt}from"uuid";var z=typeof window<"u"&&typeof window.document<"u",M,Ot;if(!z)try{M=ut("fs"),Ot=ut("path")}catch{console.warn("File system modules not available in this environment")}var Kt=async(t,e,r,o)=>{let a=await Yt({model:t.memory.vectorModel||Bt("gpt-4-turbo"),schema:$.object({observation:$.string().describe("The context and setup - what happened"),thoughts:$.string().describe("Internal reasoning process and observations of the agent in the episode that let it arrive at the correct action and result. 'I ...'"),result:$.string().describe("Outcome and retrospective. What did you do well? What could you do better next time? I ...")}),prompt:`
    You are creating an episodic memory for an AI agent to help it recall and learn from past experiences.
    
    Your task is to analyze the agent's thoughts, actions, and the results of those actions to create a structured memory that can be used for future reference and learning.

    ## Context
    <thoughts>
    ${JSON.stringify(e)}
    </thoughts>

    ## Actions Taken
    <actions>
    ${JSON.stringify(r)}
    </actions>

    ## Results & Outcomes
    <results>
    ${JSON.stringify(o)}
    </results>
    
    ## Instructions
    Create a comprehensive episodic memory with these components:
    
    1. OBSERVATION: Provide a clear, concise description of the situation, context, and key elements. Include:
       - What was the environment or scenario?
       - What was the agent trying to accomplish?
       - What were the initial conditions or constraints?
    
    2. THOUGHTS: Capture the agent's internal reasoning process that led to its actions:
       - What was the agent's understanding of the situation?
       - What strategies or approaches did it consider?
       - What key insights or realizations occurred during the process?
       - Use first-person perspective ("I realized...", "I considered...")
    
    3. RESULT: Summarize the outcomes and provide a retrospective analysis:
       - What was accomplished or not accomplished?
       - What worked well and what didn't?
       - What lessons can be learned for future similar situations?
       - What would be done differently next time?
       - Use first-person perspective ("I succeeded in...", "Next time I would...")
    
    Make the memory detailed enough to be useful for future recall, but concise enough to be quickly processed. Focus on capturing the essence of the experience, key decision points, and lessons learned.`});return{observation:a.object.observation,thoughts:a.object.thoughts,result:a.object.result}};function Xt(t){let e=t.observation,r=`${t.thoughts}

${t.result}`;return{prompt:e,completion:r}}async function Rt(t,e){if(z){console.warn("saveTrainingData is not supported in browser environments");return}try{if(!M){console.warn("File system module not available");return}let r=Ot.dirname(e);M.existsSync(r)||M.mkdirSync(r,{recursive:!0});let o=t.map(a=>JSON.stringify(a)).join(`
`);M.writeFileSync(e,o,"utf8")}catch(r){throw console.error("Error saving training data:",r),r}}async function te(t,e,r,o,a){let u=await Kt(o,t,e,r);if(a?.exportTrainingData&&!z&&M){let c=Xt(u),i=a.trainingDataPath||"./training-data.jsonl",l=[];M.existsSync(i)&&(l=M.readFileSync(i,"utf8").split(`
`).filter(g=>g.trim()!=="").map(g=>JSON.parse(g))),l.push(c),await Rt(l,i)}return{id:Zt(),timestamp:Date.now(),observation:u.observation,result:u.result,thoughts:u.thoughts}}async function It(t,e="./training-data.jsonl"){if(z){console.warn("exportEpisodesAsTrainingData is not supported in browser environments");return}if(!M){console.warn("File system module not available");return}let r=t.map(o=>({prompt:o.observation,completion:`${o.thoughts}

${o.result}`}));await Rt(r,e)}async function Mt(t,e,r,o,a,u){let c=u.find(f=>f.name===e.name);if(!c)return;let g=await te([t],[c],[r],o,{exportTrainingData:o.exportTrainingData===!0,trainingDataPath:o.trainingDataPath||"./training-data.jsonl"});await o.memory.vector.upsert(`${a}`,[{id:g.id,text:g.observation,metadata:g}])}async function Dt(t,e,r,o){let a=gt(o);a.next();let u,c=[],i=e;function l(d){let g=a.next(d);for(;!g.done&&g.value;)g.value.type==="start"&&(u&&c.push(u),u={index:i++,tag:g.value.name,attributes:g.value.attributes,content:[],done:!1},r(u)),g.value.type==="end"&&(u&&r({...u,done:!0}),u=c.pop()),g.value.type==="text"&&u&&(u.content.push(g.value.content),r(u)),g=a.next()}for await(let d of t)l(d);a.return?.()}async function*Lt(t,e,r){yield e;for await(let o of t)yield o;yield r}var ee=new Set(["think","response","output","action_call","reasoning"]);function Nt({agent:t,chain:e,ctxState:r,agentCtxState:o,logger:a,handlers:u,taskRunner:c,outputs:i,actions:l,actionCalls:d,workingMemory:g,abortSignal:f}){let h={index:0,logsByIndex:new Map};function k(n,T){return h.logsByIndex.has(n)||h.logsByIndex.set(n,{id:L(),timestamp:Date.now(),processed:!1,...T}),h.logsByIndex.get(n)}async function S(n,T){if(T&&e.push(n),n.ref==="thought"&&T&&(g.thoughts.push(n),a.debug("agent:think","thought",n.content),u?.onThinking?.(n)),n.ref==="action_call"&&T&&g.calls.push(n),n.ref==="action_result"&&T){g.results.push(n);let P=g.thoughts[g.thoughts.length-1],p=g.calls[g.calls.length-1];P&&p&&t.memory.generateMemories&&Mt(P,p,n,t,r.id,l).catch(s=>{a.error("agent:generateEpisode","Failed to generate episode",s)})}u?.onLogStream?.(n,T)}async function C(n,T){if(!T)return S(n,!1);let{action:P}=await kt({call:n,actions:l,logger:a});f?.aborted||(S(n,!0),d.push(Ct({call:n,action:P,agent:t,logger:a,state:r,taskRunner:c,workingMemory:g,agentState:o,abortSignal:f}).catch(p=>({ref:"action_result",id:L(),callId:n.id,data:{error:JSON.stringify(p)},name:n.name,timestamp:Date.now(),processed:!1})).then(p=>(S(p,!0),p))))}async function E(n,T){if(!T)return S(n,!1);let P=await St({agent:t,logger:a,state:r,workingMemory:g,outputs:i,outputRef:n});for(let p of Array.isArray(P)?P:[P])a.debug("agent:output","Output processed status",{type:p.type,processed:p.processed}),g.outputs.push(p),S(p,!0)}async function F(n){if(!f?.aborted)switch(h.index=Math.max(n.index,h.index),n.tag){case"think":case"reasoning":{let T=k(n.index,{ref:"thought"});S({...T,content:n.content.join("")},n.done);break}case"action_call":{let T=k(n.index,{ref:"action_call"});C({...T,name:n.attributes.name,content:n.content.join(""),data:void 0},n.done);break}case"output":{let T=k(n.index,{ref:"output"});if(!n.attributes.type){a.error("agent:output","Missing output type attribute",{content:n.content.join(""),attributes:n.attributes});break}E({...T,type:n.attributes.type,data:n.content.join("").trim()},n.done);break}default:break}}return{state:h,handler:F,tags:ee}}var ne={"qwen-qwq-32b":{prefix:""}};function Wt({model:t,stream:e,logger:r,contextId:o,step:a,task:{callId:u,debug:c}}){let i=ne[t.modelId]?.prefix??"<think>",l="</response>";return{response:new Promise(async(g,f)=>{try{let h=await e.text,k=i+h+l;c(o,[a,u],k),r.debug("agent:response",k,{contextId:o,callId:u}),g(At(k))}catch(h){f(h)}}),stream:Lt(e.textStream,i,l)}}var Ft=H("agent:run:generate",async({contexts:t,workingMemory:e,outputs:r,actions:o,logger:a,model:u,contextId:c,abortSignal:i},{callId:l,debug:d})=>{d(c,["workingMemory",l],JSON.stringify(e,null,2));let g=t.find(S=>S.id===c),f=wt({context:tt(c,t,e),outputs:r,actions:o,updates:K({type:g.context.type,key:g.key,content:et({memory:{inputs:e.inputs,results:e.results},processed:!1})})});d(c,["prompt",l],f),a.debug("agent:system",f);let h=[{role:"user",content:[{type:"text",text:f}]},{role:"assistant",content:"<think>"}];e.currentImage&&(h[0].content=[...h[0].content,{type:"image",image:e.currentImage}]);let k=Vt({model:u,messages:h,stopSequences:["</response>"],temperature:.6,abortSignal:i,experimental_transform:Et({chunking:"word"}),onError:S=>{console.error(S)}});return e.currentImage=void 0,Wt({model:u,step:"response",contextId:c,logger:a,stream:k,task:{callId:l,debug:d}})}),_t=H("agent:run:generate-results",async({contexts:t,workingMemory:e,outputs:r,actions:o,logger:a,model:u,contextId:c,chain:i,abortSignal:l},{callId:d,debug:g})=>{g(c,["workingMemory",d],JSON.stringify(e,null,2));let f=t.find(C=>C.id===c),h=vt({context:tt(c,t,e),outputs:r,actions:o,updates:K({type:f.context.type,key:f.key,content:et({memory:{inputs:e.inputs},processed:!1})}),logs:i.filter(C=>C.ref==="action_result"?!1:C.processed!==!0),results:e.results.filter(C=>C.processed!==!0)});j(e).forEach(C=>{C.ref!=="input"&&(C.processed=!0)}),g(c,["prompt-results",d],h),a.debug("agent:system",h,{contextId:c,callId:d});let k=[{role:"user",content:[{type:"text",text:h}]},{role:"assistant",content:"<think>"}];e.currentImage&&(k[0].content=[...k[0].content,{type:"image",image:e.currentImage}]);let S=Vt({model:u,messages:k,stopSequences:["</response>"],temperature:.6,abortSignal:l,experimental_transform:Et({chunking:"word"}),onError:C=>{console.error(C)}});return e.currentImage=void 0,Wt({model:u,step:"results-response",contextId:c,logger:a,stream:S,task:{callId:d,debug:g}})}),Pt=H("agent:run:action",async({ctx:t,action:e,call:r,agent:o,logger:a})=>{try{a.info("agent:action_call:"+r.id,r.name,JSON.stringify(r.data));let u=await e.handler(r,t,o);return a.debug("agent:action_result:"+r.id,r.name,u),u}catch(u){throw a.error("agent:action","ACTION_FAILED",{error:u}),u}});function On(t){let e=!1,r=new Map,o=new Map,a=new Set,{inputs:u={},outputs:c={},events:i={},actions:l=[],experts:d={},services:g=[],extensions:f=[],model:h,reasoningModel:k,exportTrainingData:S,trainingDataPath:C}=t,E=t.container??yt(),F=t.taskRunner??new G(3),n=new ct({level:t.logger??2,enableTimestamp:!0,enableColors:!0});E.instance("logger",n),n.debug("dreams","Creating agent",{hasModel:!!h,hasReasoningModel:!!k,inputsCount:Object.keys(u).length,outputsCount:Object.keys(c).length,actionsCount:l.length,servicesCount:g.length,extensionsCount:f.length});let T=(...s)=>{if(t.debugger)try{t.debugger(...s)}catch{console.log("debugger failed")}},P=pt(E);for(let s of g)P.register(s);for(let s of f)if(s.inputs&&Object.assign(u,s.inputs),s.outputs&&Object.assign(c,s.outputs),s.events&&Object.assign(i,s.events),s.actions&&l.push(...s.actions),s.services)for(let w of s.services)P.register(w);let p={inputs:u,outputs:c,events:i,actions:l,experts:d,memory:t.memory??ht(xt(),bt()),container:E,model:h,reasoningModel:k,taskRunner:F,debugger:T,context:t.context??void 0,exportTrainingData:S,trainingDataPath:C,emit:(s,w)=>{n.debug("agent:event",s,w)},async getContexts(){return Array.from(o.entries()).map(([s,{type:w,args:m}])=>({id:s,type:w,args:m}))},getContext(s){return n.trace("agent:getContext","Getting context state",s),W(p,s.context,s.args)},getContextId(s){return n.trace("agent:getContextId","Getting context id",s),mt(s.context,s.args)},getWorkingMemory(s){return n.trace("agent:getWorkingMemory","Getting working memory",{contextId:s}),U(p,s)},async start(s){if(n.info("agent:start","Starting agent",{args:s,booted:e}),e)return p;e=!0,n.debug("agent:start","Booting services"),await P.bootAll(),n.debug("agent:start","Installing extensions",{count:f.length});for(let m of f)m.install&&await m.install(p);n.debug("agent:start","Setting up inputs",{count:Object.keys(p.inputs).length});for(let[m,x]of Object.entries(p.inputs))if(x.install&&(n.trace("agent:start","Installing input",{type:m}),await Promise.resolve(x.install(p))),x.subscribe){n.trace("agent:start","Subscribing to input",{type:m});let v=x.subscribe((D,y,b)=>{n.debug("agent","input",{context:D,args:y,data:b}),p.send({context:D,input:{type:m,data:b},args:y}).catch(R=>{n.error("agent:input","error",R)})},p);typeof v=="object"&&(v=await Promise.resolve(v)),v&&r.set(m,v)}n.debug("agent:start","Setting up outputs",{count:Object.keys(c).length});for(let[m,x]of Object.entries(c))x.install&&(n.trace("agent:start","Installing output",{type:m}),await Promise.resolve(x.install(p)));n.debug("agent:start","Setting up actions",{count:l.length});for(let m of l)m.install&&(n.trace("agent:start","Installing action",{name:m.name}),await Promise.resolve(m.install(p)));if(p.context){n.debug("agent:start","Setting up agent context",{type:p.context.type});let{id:m}=await W(p,p.context,s);o.set(m,{type:p.context.type,args:s}),o.set("agent:context",{type:p.context.type,args:s})}n.debug("agent:start","Loading saved contexts");let w=await p.memory.store.get("contexts");if(w){n.trace("agent:start","Restoring saved contexts",{count:w.length});for(let[m,{type:x,args:v}]of w)o.set(m,{type:x,args:v})}return n.info("agent:start","Agent started successfully"),p},async stop(){n.info("agent:stop","Stopping agent")},run:async({context:s,args:w,outputs:m,handlers:x,abortSignal:v,model:D})=>{if(!e)throw n.error("agent:run","Agent not booted"),new Error("Not booted");n.info("agent:run","Running context",{contextType:s.type,hasArgs:!!w,hasCustomOutputs:!!m,hasHandlers:!!x});let y=await W(p,s,w);if(n.debug("agent:run","Context state retrieved",{id:y.id}),o.set(y.id,{type:s.type,args:w}),await p.memory.store.set("contexts",Array.from(o.entries())),a.has(y.id))return n.debug("agent:run","Context already running",{id:y.id}),[];a.add(y.id),n.debug("agent:run","Added context to running set",{id:y.id});let b=await U(p,y.id);n.trace("agent:run","Working memory retrieved",{id:y.id,inputsCount:b.inputs.length,outputsCount:b.outputs.length,thoughtsCount:b.thoughts.length});let R=Object.entries({...p.outputs,...m??{}}).filter(([A,I])=>I.enabled?I.enabled({...y,context:s,workingMemory:b}):!0).map(([A,I])=>({type:A,...I}));n.debug("agent:run","Enabled outputs",{count:R.length});let O=p.context?await W(p,p.context,o.get("agent:context").args):void 0;n.debug("agent:run","Preparing actions");let Q=await Promise.all(l.map(async A=>{if(A.context&&A.context.type!==s.type)return;let I;return A.memory&&(I=await p.memory.store.get(A.memory.key)??A.memory.create()),(A.enabled?A.enabled({...y,context:s,workingMemory:b,actionMemory:I,agentMemory:O?.memory}):!0)?A:void 0})).then(A=>A.filter(I=>!!I));n.debug("agent:run","Enabled actions",{count:Q.length}),n.debug("agent:run","Agent context state",{hasAgentContext:!!O,id:O?.id});let _=[],qt=!1,q=[],{state:st,handler:jt,tags:Ut}=Nt({agent:p,chain:_,actions:Q,actionCalls:q,agentCtxState:O,ctxState:y,handlers:x,logger:n,outputs:R,taskRunner:F,workingMemory:b,abortSignal:v}),V=1,it=s.maxSteps??5;for(;it>V;){n.info("agent:run",`Starting step ${V}/${it}`,{contextId:y.id});try{let{stream:A,response:I}=await F.enqueueTask(V>1?_t:Ft,{agent:p,model:D??s.model??t.reasoningModel??t.model,contexts:[O,y].filter(Y=>!!Y),contextId:y.id,actions:Q,outputs:R,workingMemory:b,logger:n,chain:_,abortSignal:v},{debug:p.debugger});if(n.debug("agent:run","Processing stream",{step:V}),await Dt(A,st.index,jt,Ut),st.index++,n.debug("agent:run","Waiting for action calls to complete",{pendingCalls:q.length}),await Promise.allSettled(q),q.length=0,n.debug("agent:run","Saving context state",{id:y.id}),await p.memory.store.set(y.id,y.memory),O&&(n.debug("agent:run","Saving agent context state",{id:O.id}),await p.memory.store.set(O.id,O.memory)),n.debug("agent:run","Saving working memory",{id:y.id,workingMemory:b}),V++,s.onStep&&await s.onStep({...y,workingMemory:b}),qt){n.warn("agent:run","Continuing despite error",{step:V});continue}if(await nt(p,y.id,b),b.results.filter(Y=>Y.processed===!1).length===0||v?.aborted)break}catch(A){console.error(A);break}}return n.debug("agent:run","Marking all working memory as processed"),j(b).forEach(A=>{A.processed=!0}),n.debug("agent:run","Removing context from running set",{id:y.id}),a.delete(y.id),n.info("agent:run","Run completed",{contextId:y.id,chainLength:_.length}),_},send:async s=>{if(n.info("agent:send","Sending input",{inputType:s.input.type,contextType:s.context.type}),!(s.input.type in p.inputs))throw n.error("agent:send","Invalid input type",{type:s.input.type}),new Error("invalid input");let w=s.context.schema.parse(s.args),{key:m,id:x,options:v,memory:D}=await W(p,s.context,w);n.debug("agent:send","Context state retrieved",{id:x,key:m});let y=await U(p,x);n.trace("agent:send","Working memory retrieved",{id:x,inputsCount:y.inputs.length});let b=p.inputs[s.input.type],R=b.schema.parse(s.input.data);n.debug("agent:send","Input data parsed",{type:s.input.type}),n.debug("agent:send","Querying episodic memory");let O=await p.memory.vector.query(`${x}`,JSON.stringify(R));return n.trace("agent:send","Episodic memory retrieved",{episodesCount:O.length}),y.episodicMemory={episodes:O},b.handler?(n.debug("agent:send","Using custom input handler",{type:s.input.type}),await b.handler(R,{id:x,context:s.context,args:w,type:s.context.type,key:m,memory:D,workingMemory:y,options:v},p)):(n.debug("agent:send","Adding input to working memory",{type:s.context.type}),y.inputs.push({id:L(),ref:"input",type:s.context.type,data:R,timestamp:Date.now(),formatted:b.format?b.format(R):void 0,processed:!1})),n.debug("agent:send","Running evaluator"),await p.evaluator({type:s.context.type,key:m,memory:D,options:v}),n.debug("agent:send","Saving context memory",{id:x}),await p.memory.store.set(x,D),n.debug("agent:send","Saving working memory"),await nt(p,x,y),n.debug("agent:send","Running run method"),await p.run(s)},evaluator:async s=>{let{id:w,memory:m}=s;n.debug("agent:evaluator","memory",m)},async exportAllTrainingData(s){n.info("agent:exportTrainingData","Exporting episodes as training data");let w=await p.getContexts(),m=[];for(let{id:x}of w){let v=await p.memory.vector.query(x,"");v.length>0&&m.push(...v)}n.info("agent:exportTrainingData",`Found ${m.length} episodes to export`),m.length>0?(await It(m,s||p.trainingDataPath||"./training-data.jsonl"),n.info("agent:exportTrainingData","Episodes exported successfully")):n.warn("agent:exportTrainingData","No episodes found to export")}};return E.instance("agent",p),p}var N=class extends Error{constructor(r,o){super(r);this.message=r;this.details=o}};async function re(t,e,r){try{let o=await fetch(t,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({query:e,variables:r})});if(!o.ok)throw new N(`HTTP Error: ${o.status} ${o.statusText}`,{status:o.status,statusText:o.statusText});let a=await o.json();return a.errors&&a.errors.length>0?new N(a.errors[0].message,a.errors):a.data?a.data:new N("No data returned from GraphQL query")}catch(o){return o instanceof N?o:new N("Unknown error during GraphQL fetch",o)}}export{oe as HandlerRole,Ht as LogLevel,ct as Logger,G as TaskRunner,me as action,Ce as context,Jt as createContainer,On as createDreams,ht as createMemory,xt as createMemoryStore,Tt as createParser,rt as createPrompt,pt as createServiceManager,ue as createTagParser,ie as createTagRegex,bt as createVectorStore,Se as createWorkingMemory,Oe as defaultContext,Pe as defaultWorkingMemory,fe as expert,be as extension,re as fetchGraphQL,Z as formatAction,K as formatContext,X as formatContextLog,tt as formatContexts,Ae as formatInput,ke as formatMsg,ve as formatOutput,B as formatOutputInterface,ge as formatValue,se as formatXml,mt as getContextId,W as getContextState,U as getContextWorkingMemory,De as getOrCreateConversationMemory,j as getWorkingMemoryLogs,je as getZodJsonSchema,Ct as handleActionCall,St as handleOutput,de as input,pe as isElement,le as isText,xe as memory,ye as output,lt as parse,ce as parseAttributes,kt as prepareActionCall,L as randomUUIDv7,dt as render,et as renderWorkingMemory,nt as saveContextWorkingMemory,ae as service,he as splitTextIntoChunks,H as task,we as trimWorkingMemory,Te as validateEnv,gt as xmlStreamParser};
//# sourceMappingURL=index.js.map