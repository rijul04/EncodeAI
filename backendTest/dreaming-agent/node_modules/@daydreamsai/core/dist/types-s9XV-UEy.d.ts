import { LanguageModelV1 } from 'ai';
import { z } from 'zod';

/**
 * Represents a constructor function that creates an instance of type T.
 */
type Constructor<T> = new (...args: any[]) => T;
/**
 * Represents a factory function that creates an instance of type T using the container.
 */
type Factory<T> = (container: Container) => T;
/**
 * Represents any function type.
 */
type FunctionType = (...args: any[]) => any;
/**
 * Represents a dependency injection token that can be a string, symbol, constructor, or function.
 */
type Token = string | symbol | Constructor<any> | FunctionType;
/**
 * Interface for a dependency injection container.
 */
interface Container {
    /**
     * Registers a factory function for a token.
     * Each time the token is resolved, the factory will be called to create a new instance.
     *
     * @param token - The token to register
     * @param factory - The factory function that creates the instance
     * @returns The container instance for chaining
     */
    register: <T>(token: Token, factory: Factory<T>) => Container;
    /**
     * Registers a singleton factory function for a token.
     * The factory will be called only once when the token is first resolved,
     * and the same instance will be returned for subsequent resolutions.
     *
     * @param token - The token to register
     * @param factory - The factory function that creates the singleton instance
     * @returns The container instance for chaining
     */
    singleton: <T>(token: Token, factory: Factory<T>) => Container;
    /**
     * Registers a pre-created instance for a token.
     *
     * @param token - The token to register
     * @param instance - The instance to register
     * @returns The container instance for chaining
     */
    instance: <T>(token: Token, instance: T) => Container;
    /**
     * Creates an alias for an existing token.
     *
     * @param aliasToken - The alias token (must be a string or symbol)
     * @param originalToken - The original token to alias
     * @returns The container instance for chaining
     */
    alias: (aliasToken: string | symbol, originalToken: Token) => Container;
    /**
     * Resolves a token to its registered instance.
     *
     * @param token - The token to resolve
     * @returns The resolved instance
     * @throws Error if no registration is found for the token
     */
    resolve: <T>(token: Token) => T;
}
/**
 * Creates a new dependency injection container.
 *
 * @returns A new Container instance
 *
 * @example
 * ```typescript
 * const container = createContainer();
 *
 * // Register a transient dependency
 * container.register('logger', () => new Logger());
 *
 * // Register a singleton
 * container.singleton('database', (c) => new Database(c.resolve('config')));
 *
 * // Register a pre-created instance
 * container.instance('config', { connectionString: 'mongodb://localhost:27017' });
 *
 * // Create an alias
 * container.alias('db', 'database');
 *
 * // Resolve dependencies
 * const db = container.resolve<Database>('db');
 * ```
 */
declare const createContainer: () => Container;

type ServiceProvider = {
    register?: (container: Container) => void;
    boot?: (container: Container) => void | Promise<void>;
};
type ServiceManager = {
    register: (provider: ServiceProvider) => void;
    bootAll: () => Promise<void>;
    isBooted: (provider: ServiceProvider) => boolean;
    isRegistered: (provider: ServiceProvider) => boolean;
};
declare const service: (config: ServiceProvider) => ServiceProvider;
declare const createServiceManager: (container: Container) => ServiceManager;

/**
 * Base memory implementation providing storage and vector capabilities
 */
type BaseMemory = {
    /** Store for conversation memory data */
    store: MemoryStore;
    /** Store for vector embeddings and similarity search */
    vector: VectorStore;
    vectorModel?: LanguageModelV1;
    generateMemories?: boolean;
};
/**
 * Creates a new BaseMemory instance
 * @param store - Memory store implementation for conversation data
 * @param vector - Vector store implementation for embeddings
 * @param vectorModel - Vector model implementation for embeddings
 * @returns A new BaseMemory instance
 */
declare function createMemory(store: MemoryStore, vector: VectorStore, vectorModel?: LanguageModelV1): BaseMemory;
/**
 * Retrieves or creates a new conversation memory for the given ID
 * @param memory - The memory store to use
 * @param conversationId - Unique identifier for the conversation
 * @returns A WorkingMemory object for the conversation
 */
declare function getOrCreateConversationMemory(memory: MemoryStore, conversationId: string): Promise<WorkingMemory>;
declare function createMemoryStore(): MemoryStore;
/**
 * Creates a no-op vector store implementation
 * @returns A VectorStore implementation that performs no operations
 */
declare function createVectorStore(): VectorStore;

/**
 * Options for configuring a task.
 */
type TaskOptions = {
    limit?: number;
    retry?: number;
    debug?: Debugger;
    priority?: number;
    callId?: string;
};
/**
 * Context provided to a task.
 */
type TaskContext = {
    callId: string;
    debug: Debugger;
};
/**
 * A task function that takes parameters and options and returns a promise.
 */
type Task<in Params, out Result> = (params: Params, options?: TaskOptions) => Promise<Result>;
type InferTaskParams<T extends Task<any, any>> = T extends Task<infer Params, any> ? Params : unknown;
type InferTaskResult<T extends Task<any, any>> = T extends Task<any, infer Result> ? Result : unknown;
/**
 * Manages the execution of tasks with concurrency control.
 */
declare class TaskRunner {
    private queue;
    private running;
    private concurrency;
    private processing;
    /**
     * Creates a new TaskRunner instance.
     * @param concurrency - The maximum number of tasks to run concurrently.
     */
    constructor(concurrency?: number);
    /**
     * Sets the concurrency level for the task runner.
     * @param concurrency - The new concurrency level.
     */
    setConcurrency(concurrency: number): void;
    /**
     * Processes the task queue, running tasks up to the concurrency limit.
     */
    private processQueue;
    /**
     * Enqueues a task for execution.
     * @param taskFn - The function to execute as a task.
     * @param priority - The priority of the task.
     * @returns A promise that resolves when the task is completed.
     */
    enqueue<T>(taskFn: () => Promise<T>, priority?: number): Promise<T>;
    /**
     * Gets the number of active tasks.
     */
    get activeTasksCount(): number;
    /**
     * Gets the number of tasks in the queue.
     */
    get queuedTasksCount(): number;
    /**
     * Enqueues a task function for execution.
     * @param taskFn - The task function to execute
     * @param params - Parameters to pass to the task
     * @param options - Task options including priority
     * @returns A promise that resolves when the task is completed
     */
    enqueueTask<TTask extends Task<any, any>>(taskFn: TTask, params: InferTaskParams<TTask>, options?: TaskOptions): Promise<InferTaskResult<TTask>>;
}
/**
 * Creates a task function that can be executed or enqueued.
 * @param key - A unique key for the task.
 * @param fn - The function to execute as the task.
 * @param defaultOptions - Default options for the task.
 * @returns A task function that can be executed directly or enqueued.
 */
declare function task<Params, Result>(key: string, fn: (params: Params, ctx: TaskContext) => Promise<Result>, defaultOptions?: Omit<TaskOptions, "callId">): (params: Params, options?: TaskOptions) => Promise<Result>;

/**
 * Represents a memory configuration for storing data
 * @template Data - Type of data stored in memory
 */
type Memory<Data = any> = {
    /** Unique identifier for this memory */
    key: string;
    /** Function to initialize memory data */
    create: () => Promise<Data> | Data;
};
/**
 * Extracts the data type from a Memory type
 * @template TMemory - Memory type to extract data from
 */
type InferMemoryData<TMemory extends Memory<any>> = TMemory extends Memory<infer Data> ? Data : never;
/**
 * Represents an execution chain with experts and metadata
 */
type Chain = {
    /** Unique identifier for the chain */
    id: string;
    /** Current thinking/reasoning state */
    thinking: string;
    /** Goal or purpose of this chain */
    purpose: string;
    /** List of experts involved in the chain */
    experts: {
        name: string;
        data: string;
    }[];
};
/**
 * Interface for storing and retrieving memory data
 */
interface MemoryStore {
    /**
     * Retrieves data from memory
     * @template T - Type of data to retrieve
     * @param key - Key to lookup
     * @returns Promise resolving to data or null if not found
     */
    get<T>(key: string): Promise<T | null>;
    /**
     * Stores data in memory
     * @template T - Type of data to store
     * @param key - Key to store under
     * @param value - Data to store
     */
    set<T>(key: string, value: T): Promise<void>;
    /**
     * Removes data from memory
     * @param key - Key to remove
     */
    delete(key: string): Promise<void>;
    /**
     * Removes all data from memory
     */
    clear(): Promise<void>;
}
/**
 * Interface for storing and retrieving vector data
 */
interface VectorStore {
    /** Optional connection string for the vector store */
    connection?: string;
    /**
     * Adds or updates data in the vector store
     * @param contextId - Unique identifier for the context
     * @param data - Data to add or update
     */
    upsert(contextId: string, data: any): Promise<void>;
    /**
     * Searches the vector store for similar data
     * @param contextId - Context to search within
     * @param query - Query text to search for
     * @returns Array of matching documents
     */
    query(contextId: string, query: string): Promise<any[]>;
    /**
     * Creates a new index in the vector store
     * @param indexName - Name of the index to create
     */
    createIndex(indexName: string): Promise<void>;
    /**
     * Deletes an existing index from the vector store
     * @param indexName - Name of the index to delete
     */
    deleteIndex(indexName: string): Promise<void>;
}
/**
 * Represents the working memory state during execution
 */
interface WorkingMemory {
    /** List of input references */
    inputs: InputRef[];
    /** List of output references */
    outputs: OutputRef[];
    /** List of thought records */
    thoughts: Thought[];
    /** List of action calls */
    calls: ActionCall[];
    /** List of action results */
    results: ActionResult[];
    episodicMemory?: EpisodicMemory;
    /** Current image URL for multimodal context */
    currentImage?: URL;
}
type InferSchema<T> = T extends {
    schema?: infer S extends z.AnyZodObject;
} ? z.infer<S> : unknown;
type InferAgentContext<TAgent extends AnyAgent> = TAgent extends Agent<infer Content> ? Content : never;
type InferAgentMemory<TAgent extends AnyAgent> = InferContextMemory<InferAgentContext<TAgent>>;
/**
 * Represents an evaluator that can validate action/output results
 * @template Data - Type of data being evaluated
 * @template Context - Context type for the evaluation
 */
type Evaluator<Data = any, Context extends AgentContext<any> = AgentContext<any>, TAgent extends AnyAgent = AnyAgent> = {
    name: string;
    description?: string;
    /** Schema for the evaluation result */
    schema?: z.ZodType<any>;
    /** Custom prompt template for LLM-based evaluation */
    prompt?: string;
    /** Custom handler for evaluation logic */
    handler?: (data: Data, ctx: Context, agent: TAgent) => Promise<boolean> | boolean;
    /** Optional callback when evaluation fails */
    onFailure?: (ctx: Context, agent: TAgent) => Promise<void> | void;
};
type ActionContext<TContext extends AnyContext = AnyContext, AContext extends AnyContext = AnyContext, ActionMemory extends Memory<any> = Memory<any>> = AgentContext<TContext> & {
    actionMemory: InferMemoryData<ActionMemory>;
    agentMemory: InferContextMemory<AContext> | undefined;
    abortSignal?: AbortSignal;
};
/**
 * Represents an action that can be executed with typed parameters
 * @template Schema - Zod schema defining parameter types
 * @template Result - Return type of the action
 * @template Context - Context type for the action execution
 */
type Action<Schema extends z.AnyZodObject = z.AnyZodObject, Result = any, TContext extends AnyContext = AnyContext, TAgent extends AnyAgent = AnyAgent, TMemory extends Memory<any> = Memory<any>> = {
    name: string;
    description?: string;
    instructions?: string;
    schema: Schema;
    memory?: TMemory;
    install?: (agent: TAgent) => Promise<void> | void;
    enabled?: (ctx: ActionContext<TContext, InferAgentContext<TAgent>, TMemory>) => boolean;
    examples?: z.infer<Schema>[];
    handler: (call: ActionCall<z.infer<Schema>>, ctx: ActionContext<TContext, InferAgentContext<TAgent>, TMemory>, agent: TAgent) => Promise<Result> | Result;
    format?: (result: ActionResult<Result>) => string | string[];
    /** Optional evaluator for this specific action */
    evaluator?: Evaluator<Result, AgentContext<TContext>, TAgent>;
    context?: TContext;
};
type OutputSchema = z.AnyZodObject | z.ZodString;
type OutputRefResponse = Omit<OutputRef, "id" | "ref" | "type" | "processed">;
type OutputResponse = OutputRefResponse | OutputRefResponse[] | undefined | void;
type Output<Schema extends OutputSchema = OutputSchema, Context extends AgentContext<any> = AgentContext<any>, Response extends OutputResponse = OutputResponse, TAgent extends AnyAgent = AnyAgent> = {
    type: string;
    description?: string;
    instructions?: string;
    schema: Schema;
    install?: (agent: TAgent) => Promise<void>;
    enabled?: (ctx: AgentContext<any>) => boolean;
    handler: (params: z.infer<Schema>, ctx: Context, agent: TAgent) => Promise<Response> | Response;
    format?: (res: Response) => string | string[];
    examples?: z.infer<Schema>[];
    /** Optional evaluator for this specific output */
    evaluator?: Evaluator<Response, Context, TAgent>;
    required?: boolean;
};
type AnyAction = Action<any, any, any, any, any>;
/**
 * Represents an input handler with validation and subscription capability
 * @template Schema - Zod schema for input parameters
 * @template Context - Context type for input handling
 */
type Input<Schema extends z.AnyZodObject = z.AnyZodObject, TAgent extends AnyAgent = AnyAgent> = {
    type: string;
    description?: string;
    schema: Schema;
    format?: (params: z.infer<Schema>) => string | string[];
    install?: (agent: TAgent) => Promise<void>;
    handler?: <TContext extends AgentContext<AnyContext> = AgentContext<AnyContext>>(params: z.infer<Schema>, ctx: TContext, agent: TAgent) => Promise<boolean> | boolean;
    subscribe?: (send: <TContext extends AnyContext>(contextHandler: TContext, args: z.infer<TContext["schema"]>, data: z.infer<Schema>) => void, agent: TAgent) => (() => void) | void | Promise<void | (() => void)>;
};
/** Reference to an input event in the system */
type InputRef<Data = any> = {
    id: string;
    ref: "input";
    type: string;
    data: Data;
    params?: Record<string, string>;
    timestamp: number;
    processed: boolean;
    formatted?: string | string[];
};
/** Reference to an output event in the system */
type OutputRef<Data = any> = {
    id: string;
    ref: "output";
    type: string;
    data: Data;
    params?: Record<string, string>;
    timestamp: number;
    processed: boolean;
    formatted?: string | string[];
};
/** Represents a call to an action */
type ActionCall<Data = any> = {
    ref: "action_call";
    id: string;
    name: string;
    content: string;
    data: Data;
    timestamp: number;
    processed: boolean;
};
/** Represents the result of an action execution */
type ActionResult<Data = any> = {
    ref: "action_result";
    id: string;
    callId: string;
    name: string;
    data: Data;
    timestamp: number;
    processed: boolean;
    formatted?: string | string[];
};
/** Represents a thought or reasoning step */
type Thought = {
    ref: "thought";
    id: string;
    content: string;
    timestamp: number;
    processed: boolean;
};
type Log = InputRef | OutputRef | Thought | ActionCall | ActionResult;
/** Properties required for Chain-of-Thought execution */
type COTProps = {
    model: LanguageModelV1;
    plan: string;
    inputs: InputRef[];
    actions: Action[];
    outputs: Output[];
    logs: Log[];
};
/** Response structure from Chain-of-Thought execution */
type COTResponse = {
    plan: string[];
    actions: ActionCall[];
    outputs: OutputRef[];
    thinking: Thought[];
};
/** Represents an XML element structure */
type XMLElement = {
    tag: string;
    params?: Record<string, string>;
    content: string | (XMLElement | string)[];
};
/** Utility type to preserve type information */
type Pretty<type> = {
    [key in keyof type]: type[key];
} & unknown;
/**
 * Extracts variable names from a template string
 * @template T - Template string type
 */
type ExtractTemplateVariables<T extends string> = T extends `${infer Start}{{${infer Var}}}${infer Rest}` ? Var | ExtractTemplateVariables<Rest> : never;
/**
 * Creates a type mapping template variables to string values
 * @template T - Template string type
 */
type TemplateVariables<T extends string> = Pretty<{
    [K in ExtractTemplateVariables<T>]: string | string[] | object | any;
}>;
/** Represents an expert system with instructions and actions */
type Expert = {
    type: string;
    description: string;
    instructions: string;
    model?: LanguageModelV1;
    actions?: AnyAction[];
};
interface AgentContext<TContext extends AnyContext = AnyContext> {
    id: string;
    context: TContext;
    args: z.infer<TContext["schema"]>;
    options: InferContextOptions<TContext>;
    memory: InferContextMemory<TContext>;
    workingMemory: WorkingMemory;
}
type AnyAgent = Agent<any>;
interface Handlers {
    onLogStream: (log: Log, done: boolean) => void;
    onThinking: (thought: Thought) => void;
}
/**
 * Represents an agent with various configurations and methods for handling contexts, inputs, outputs, and more.
 * @template Memory - The type of memory used by the agent.
 * @template TContext - The type of context used by the agent.
 */
interface Agent<TContext extends AnyContext = AnyContext> {
    /**
     * The memory store and vector store used by the agent.
     */
    memory: BaseMemory;
    /**
     * The current context of the agent.
     */
    context?: TContext;
    /**
     * Debugger function for the agent.
     */
    debugger: Debugger;
    /**
     * The container used by the agent.
     */
    container: Container;
    /**
     * The task runner used by the agent.
     */
    taskRunner: TaskRunner;
    /**
     * The primary language model used by the agent.
     */
    model: LanguageModelV1;
    /**
     * The reasoning model used by the agent, if any.
     */
    reasoningModel?: LanguageModelV1;
    /**
     * The vector model used by the agent, if any.
     */
    vectorModel?: LanguageModelV1;
    /**
     * A record of input configurations for the agent.
     */
    inputs: Record<string, InputConfig<any>>;
    /**
     * A record of output configurations for the agent.
     */
    outputs: Record<string, Omit<Output<any, AgentContext<TContext>, any, any>, "type">>;
    /**
     * A record of event schemas for the agent.
     */
    events: Record<string, z.AnyZodObject>;
    /**
     * A record of expert configurations for the agent.
     */
    experts: Record<string, ExpertConfig>;
    /**
     * An array of actions available to the agent.
     */
    actions: Action<any, any, AnyContext, this, Memory<any>>[];
    /**
     * Whether to export training data for episodes
     */
    exportTrainingData?: boolean;
    /**
     * Path to save training data
     */
    trainingDataPath?: string;
    /**
     * Exports all episodes as training data
     * @param filePath Optional path to save the training data
     */
    exportAllTrainingData?: (filePath?: string) => Promise<void>;
    /**
     * Emits an event with the provided arguments.
     * @param args - Arguments to pass to the event handler.
     */
    emit: (...args: any[]) => void;
    /**
     * Runs the agent with the provided options.
     * @param opts - Options for running the agent.
     * @returns A promise that resolves to an array of logs.
     */
    run: <TContext extends AnyContext>(opts: {
        context: TContext;
        args: z.infer<TContext["schema"]>;
        model?: LanguageModelV1;
        outputs?: Record<string, Omit<Output<any, AgentContext<TContext>, any, any>, "type">>;
        handlers?: Partial<Handlers>;
        abortSignal?: AbortSignal;
    }) => Promise<Log[]>;
    /**
     * Sends an input to the agent with the provided options.
     * @param opts - Options for sending input to the agent.
     * @returns A promise that resolves to an array of logs.
     */
    send: <SContext extends AnyContext>(opts: {
        context: SContext;
        args: z.infer<NonNullable<SContext["schema"]>>;
        input: {
            type: string;
            data: any;
        };
        model?: LanguageModelV1;
        outputs?: Record<string, Omit<Output<any, AgentContext<SContext>, any, any>, "type">>;
        handlers?: Partial<Handlers>;
        abortSignal?: AbortSignal;
    }) => Promise<Log[]>;
    /**
     * Evaluates the provided context.
     * @param ctx - The context to evaluate.
     * @returns A promise that resolves when evaluation is complete.
     */
    evaluator: (ctx: AgentContext<TContext>) => Promise<void>;
    /**
     * Starts the agent with the provided arguments.
     * @param args - Arguments to pass to the agent on start.
     * @returns A promise that resolves to the agent instance.
     */
    start(args?: z.infer<TContext["schema"]>): Promise<this>;
    /**
     * Stops the agent.
     * @returns A promise that resolves when the agent is stopped.
     */
    stop(): Promise<void>;
    /**
     * Retrieves the contexts managed by the agent.
     * @returns A promise that resolves to an array of context objects.
     */
    getContexts(): Promise<{
        id: string;
        type: string;
        args?: any;
    }[]>;
    /**
     * Retrieves the ID for a given context and arguments.
     * @param params - Parameters for retrieving the context ID.
     * @returns The context ID.
     */
    getContextId<TContext extends AnyContext>(params: {
        context: TContext;
        args: z.infer<NonNullable<TContext["schema"]>>;
    }): string;
    /**
     * Retrieves the state of a given context and arguments.
     * @param params - Parameters for retrieving the context state.
     * @returns A promise that resolves to the context state.
     */
    getContext<TContext extends AnyContext>(params: {
        context: TContext;
        args: z.infer<NonNullable<TContext["schema"]>>;
    }): Promise<ContextState<TContext>>;
    /**
     * Retrieves the working memory for a given context ID.
     * @param contextId - The ID of the context.
     * @returns A promise that resolves to the working memory.
     */
    getWorkingMemory(contextId: string): Promise<WorkingMemory>;
}
type Debugger = (contextId: string, keys: string[], data: any) => void;
type Config<TContext extends AnyContext = AnyContext> = Partial<Agent<TContext>> & {
    model: Agent["model"];
    reasoningModel?: Agent["reasoningModel"];
    logger?: LogLevel;
    services?: ServiceProvider[];
    extensions?: Extension<TContext>[];
    /** Whether to export training data for episodes */
    exportTrainingData?: boolean;
    /** Path to save training data */
    trainingDataPath?: string;
};
/** Configuration type for inputs without type field */
type InputConfig<Schema extends z.AnyZodObject = z.AnyZodObject, TAgent extends AnyAgent = AnyAgent> = Omit<Input<Schema, TAgent>, "type">;
/** Configuration type for outputs without type field */
type OutputConfig<Schema extends OutputSchema = OutputSchema, Context extends AgentContext<any> = AgentContext<any>, Response extends OutputResponse = OutputResponse, TAgent extends AnyAgent = AnyAgent> = Omit<Output<Schema, Context, Response, TAgent>, "type">;
/** Configuration type for experts without type field */
type ExpertConfig = Omit<Expert, "type">;
/** Function type for subscription cleanup */
type Subscription = () => void;
/** Enum defining available log levels */
declare enum LogLevel {
    ERROR = 0,
    WARN = 1,
    INFO = 2,
    DEBUG = 3,
    TRACE = 4
}
/** Interface for custom log writers */
interface LogWriter {
    init(logPath: string): void;
    write(data: string): void;
}
/** Configuration options for logging */
interface LoggerConfig {
    level: LogLevel;
    enableTimestamp?: boolean;
    enableColors?: boolean;
    logToFile?: boolean;
    logPath?: string;
    logWriter?: LogWriter;
}
/** Structure of a log entry */
interface LogEntry {
    level: LogLevel;
    timestamp: Date;
    context: string;
    message: string;
    data?: any;
}
/** Results from a research operation */
interface ResearchResult {
    learnings: string[];
    visitedUrls: string[];
}
/** Configuration for research operations */
interface ResearchConfig {
    query: string;
    breadth: number;
    depth: number;
    learnings?: string[];
    visitedUrls?: string[];
}
interface IChain {
    /**
     * A unique identifier for the chain (e.g., "starknet", "ethereum", "solana", etc.)
     */
    chainId: string;
    /**
     * Read (call) a contract or perform a query on this chain.
     * The `call` parameter can be chain-specific data.
     */
    read(call: unknown): Promise<any>;
    /**
     * Write (execute a transaction) on this chain, typically requiring signatures, etc.
     */
    write(call: unknown): Promise<any>;
}
/** Type representing instructions that can be either a single string or array of strings */
type Instruction = string | string[];
/** Type representing any Context with generic type parameters */
type AnyContext = Context<any, any, any>;
/**
 * Extracts the Memory type from a Context type
 * @template TContext - The Context type to extract Memory from
 */
type InferContextMemory<TContext extends AnyContext> = TContext extends Context<infer Memory> ? Memory : never;
/**
 * Extracts the Context type from a Context type
 * @template TContext - The Context type to extract Ctx from
 */
type InferContextOptions<TContext extends AnyContext> = TContext extends Context<any, any, infer Options> ? Options : never;
/**
 * Configuration for a context that manages state and behavior
 * @template Memory - Type of memory for this context
 * @template Args - Zod schema type for context arguments
 * @template Ctx - Type of context data
 * @template Exports - Type of exported data
 */
interface Context<Memory = any, Args extends z.ZodTypeAny = any, Ctx = any> {
    /** Unique type identifier for this context */
    type: string;
    /** Zod schema for validating context arguments */
    schema: Args;
    /** Function to generate a unique key from context arguments */
    key?: (args: z.infer<Args>) => string;
    /** Optional description of this context */
    description?: string | string[] | ((state: ContextState<this>) => string | string[]);
    /** Setup function to initialize context data */
    setup?: (args: z.infer<Args>, agent: AnyAgent) => Promise<Ctx> | Ctx;
    /** Optional instructions for this context */
    instructions?: Instruction | ((state: ContextState<this>) => Instruction);
    /** Optional function to create new memory for this context */
    create?: (state: Omit<ContextState<this>, "memory">) => Memory;
    /** Optional function to load existing memory */
    load?: (state: Omit<ContextState<this>, "memory">) => Promise<Memory>;
    /** Optional function to save memory state */
    save?: (state: ContextState<this>) => Promise<void>;
    /** Optional function to render memory state */
    render?: (state: ContextState<this>) => string | string[];
    model?: LanguageModelV1;
    onStep?: (ctx: AgentContext<this>) => Promise<void>;
    maxSteps?: number;
}
type ContextState<TContext extends AnyContext = AnyContext> = {
    id: string;
    key: string;
    context: TContext;
    args: z.infer<TContext["schema"]>;
    options: InferContextOptions<TContext>;
    memory: InferContextMemory<TContext>;
};
/** Enum defining roles for different types of handlers
 * @deprecated
 */
declare enum HandlerRole {
    /** Handler for processing inputs */
    INPUT = "input",
    /** Handler for processing outputs */
    OUTPUT = "output",
    /** Handler for executing actions */
    ACTION = "action"
}
type Extension<TContext extends AnyContext = AnyContext, Contexts extends Record<string, AnyContext> = Record<string, AnyContext>> = Pick<Config<TContext>, "inputs" | "outputs" | "actions" | "services" | "events"> & {
    name: string;
    install?: (agent: AnyAgent) => Promise<void> | void;
    contexts?: Contexts;
};
interface Episode {
    id: string;
    timestamp: number;
    observation: string;
    result: string;
    thoughts: string;
    metadata?: {
        success?: boolean;
        tags?: string[];
        [key: string]: any;
    };
}
interface EpisodicMemory {
    episodes: Episode[];
    index?: number;
}

export { type Instruction as $, type AnyContext as A, type Input as B, type Config as C, type Thought as D, type ExpertConfig as E, type COTProps as F, type COTResponse as G, type ExtractTemplateVariables as H, type InputConfig as I, type Expert as J, type Handlers as K, type LoggerConfig as L, type Memory as M, type Debugger as N, type OutputSchema as O, type Pretty as P, LogLevel as Q, type LogWriter as R, type Subscription as S, type TemplateVariables as T, type LogEntry as U, type VectorStore as V, type WorkingMemory as W, type XMLElement as X, type ResearchResult as Y, type ResearchConfig as Z, type IChain as _, type Agent as a, type InferContextMemory as a0, type InferContextOptions as a1, HandlerRole as a2, type Episode as a3, type EpisodicMemory as a4, type BaseMemory as a5, createMemory as a6, getOrCreateConversationMemory as a7, createMemoryStore as a8, createVectorStore as a9, type TaskOptions as aa, type TaskContext as ab, type Task as ac, task as ad, type Container as ae, createContainer as af, createServiceManager as ag, service as ah, type ServiceProvider as ai, type ServiceManager as aj, type AnyAgent as b, type Action as c, type AgentContext as d, type OutputResponse as e, type OutputConfig as f, type Extension as g, type InputRef as h, type OutputRef as i, type Output as j, type Log as k, type ContextState as l, type Context as m, type ActionCall as n, type AnyAction as o, TaskRunner as p, type ActionResult as q, type InferMemoryData as r, type Chain as s, type MemoryStore as t, type InferSchema as u, type InferAgentContext as v, type InferAgentMemory as w, type Evaluator as x, type ActionContext as y, type OutputRefResponse as z };
