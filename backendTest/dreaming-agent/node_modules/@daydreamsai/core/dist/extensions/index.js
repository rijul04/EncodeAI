import{F as d,e as f}from"../chunk-3S76ZAL5.js";import*as h from"readline/promises";import{z as p}from"zod";var v={type:"cli",key:({user:t})=>t.toString(),schema:p.object({user:p.string()})},C=f({register(t){t.singleton("readline",()=>h.createInterface({input:process.stdin,output:process.stdout}))}}),j={name:"cli",services:[C],contexts:{cli:v},inputs:{"cli:message":{schema:p.object({user:p.string(),text:p.string()}),format:({user:t,text:l})=>d({role:"user",content:l,user:t}),async subscribe(t,{container:l}){let s=l.resolve("readline"),i=new AbortController;return new Promise(async r=>{for(;!i.signal.aborted;){let n=await s.question("> ");if(n==="exit")break;console.log("User:",n),t(v,{user:"admin"},{user:"admin",text:n})}r()}),()=>{i.abort()}}}},outputs:{"cli:message":{description:"Send messages to the user",schema:p.object({message:p.string().describe("The message to send")}),handler(t){return console.log("Agent:",t.message),{data:t,timestamp:Date.now()}},format:({data:t})=>d({role:"assistant",content:t.message})}}};import{Client as y}from"@modelcontextprotocol/sdk/client/index.js";import{StdioClientTransport as b}from"@modelcontextprotocol/sdk/client/stdio.js";import{SSEClientTransport as I}from"@modelcontextprotocol/sdk/client/sse.js";async function u(t){let l=t.clientInfo||{name:"generic-mcp-client",version:"1.0.0"},s=t.capabilities||{prompts:{},resources:{},tools:{}},i;if(t.transport.type==="stdio"){if(!t.transport.command)throw new Error("Command is required for stdio transport");i=new b({command:t.transport.command,args:t.transport.args||[]})}else if(t.transport.type==="sse"){if(!t.transport.serverUrl)throw new Error("Server URL is required for SSE transport");let n=new URL(t.transport.serverUrl);i=new I(n)}else throw new Error(`Unsupported transport type: ${t.transport.type}`);let r=new y(l,{capabilities:s});return await r.connect(i),r}import{z as o}from"zod";import"@modelcontextprotocol/sdk/client/index.js";function w(t){let l=new Map;return{name:"mcp",async install(s){let i=s.container.resolve("logger");i.info("mcp:extension","Installing MCP extension",{serversCount:t.length});for(let r of t){i.debug("mcp:extension","Connecting to MCP server",{id:r.id,name:r.name,transportType:r.transport.type});try{let n=await u({clientInfo:{name:"agent-mcp-client",version:"1.0.0"},transport:r.transport,capabilities:r.capabilities});l.set(r.id,n),i.info("mcp:extension","Connected to MCP server",{id:r.id,name:r.name})}catch(n){i.error("mcp:extension","Failed to connect to MCP server",{id:r.id,name:r.name,error:n})}}},actions:[{name:"mcp.listPrompts",description:"List available prompts from an MCP server",schema:o.object({serverId:o.string().describe("ID of the MCP server to query")}),async handler(s,i,r){let n=r.container.resolve("logger"),{serverId:e}=s.data,c=l.get(e);if(!c)return{error:`MCP server with ID '${e}' not found`};try{return{prompts:await c.listPrompts()}}catch(a){return n.error("mcp:action","Failed to list prompts",{serverId:e,error:a}),{error:String(a)}}}},{name:"mcp.getPrompt",description:"Get a prompt from an MCP server",schema:o.object({serverId:o.string().describe("ID of the MCP server to query"),name:o.string().describe("Name of the prompt to get"),arguments:o.record(o.any()).optional().describe("Arguments for the prompt")}),async handler(s,i,r){let n=r.container.resolve("logger"),{serverId:e,name:c,arguments:a}=s.data,m=l.get(e);if(!m)return{error:`MCP server with ID '${e}' not found`};try{return{prompt:await m.getPrompt({name:c,arguments:a||{}})}}catch(g){return n.error("mcp:action","Failed to get prompt",{serverId:e,name:c,error:g}),{error:String(g)}}}},{name:"mcp.listResources",description:"List available resources from an MCP server",schema:o.object({serverId:o.string().describe("ID of the MCP server to query")}),async handler(s,i,r){let n=r.container.resolve("logger"),{serverId:e}=s.data,c=l.get(e);if(!c)return{error:`MCP server with ID '${e}' not found`};try{return{resources:await c.listResources()}}catch(a){return n.error("mcp:action","Failed to list resources",{serverId:e,error:a}),{error:String(a)}}}},{name:"mcp.readResource",description:"Read a resource from an MCP server",schema:o.object({serverId:o.string().describe("ID of the MCP server to query"),uri:o.string().describe("URI of the resource to read")}),async handler(s,i,r){let n=r.container.resolve("logger"),{serverId:e,uri:c}=s.data,a=l.get(e);if(!a)return{error:`MCP server with ID '${e}' not found`};try{return{resource:await a.readResource({uri:c})}}catch(m){return n.error("mcp:action","Failed to read resource",{serverId:e,uri:c,error:m}),{error:String(m)}}}},{name:"mcp.callTool",description:"Call a tool on an MCP server",schema:o.object({serverId:o.string().describe("ID of the MCP server to query"),name:o.string().describe("Name of the tool to call"),arguments:o.record(o.any()).optional().describe("Arguments for the tool")}),async handler(s,i,r){let n=r.container.resolve("logger"),{serverId:e,name:c,arguments:a}=s.data,m=l.get(e);if(!m)return{error:`MCP server with ID '${e}' not found`};try{return{result:await m.callTool({name:c,arguments:a||{}})}}catch(g){return n.error("mcp:action","Failed to call tool",{serverId:e,name:c,error:g}),{error:String(g)}}}},{name:"mcp.listServers",description:"List all connected MCP servers",schema:o.object({}),async handler(s,i,r){return{servers:t.map(e=>({id:e.id,name:e.name,connected:l.has(e.id),transportType:e.transport.type}))}}},{name:"mcp.listTools",description:"List available tools from an MCP server",schema:o.object({serverId:o.string().describe("ID of the MCP server to query")}),async handler(s,i,r){let n=r.container.resolve("logger"),{serverId:e}=s.data,c=l.get(e);if(!c)return{error:`MCP server with ID '${e}' not found`};try{return{tools:await c.listTools()}}catch(a){return n.error("mcp:action","Failed to list tools",{serverId:e,error:a}),{error:String(a)}}}}]}}export{j as cli,u as createMcpClient,w as createMcpExtension};
//# sourceMappingURL=index.js.map