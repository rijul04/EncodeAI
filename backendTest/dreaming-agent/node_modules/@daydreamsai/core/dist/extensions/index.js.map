{"version":3,"sources":["../../src/extensions/cli.ts","../../src/extensions/mcp/client.ts","../../src/extensions/mcp/extension.ts"],"sourcesContent":["import * as readline from \"readline/promises\";\nimport { context } from \"../context\";\nimport { z } from \"zod\";\nimport { extension, input, output } from \"../utils\";\nimport { formatMsg } from \"../formatters\";\nimport { service } from \"../serviceProvider\";\n\nconst cliContext = context({\n  type: \"cli\",\n  key: ({ user }) => user.toString(),\n  schema: z.object({ user: z.string() }),\n});\n\nconst readlineService = service({\n  register(container) {\n    container.singleton(\"readline\", () =>\n      readline.createInterface({\n        input: process.stdin,\n        output: process.stdout,\n      })\n    );\n  },\n});\n\nexport const cli = extension({\n  name: \"cli\",\n  services: [readlineService],\n  contexts: {\n    cli: cliContext,\n  },\n  inputs: {\n    // Handle incoming messages\n    \"cli:message\": input({\n      schema: z.object({\n        user: z.string(),\n        text: z.string(),\n      }),\n      format: ({ user, text }) =>\n        formatMsg({\n          role: \"user\",\n          content: text,\n          user,\n        }),\n      // Subscribe to CLI input\n      async subscribe(send, { container }) {\n        const rl = container.resolve<readline.Interface>(\"readline\");\n\n        const controller = new AbortController();\n\n        new Promise<void>(async (resolve) => {\n          while (!controller.signal.aborted) {\n            const question = await rl.question(\"> \");\n            if (question === \"exit\") {\n              break;\n            }\n            console.log(\"User:\", question);\n            send(\n              cliContext,\n              { user: \"admin\" },\n              {\n                user: \"admin\",\n                text: question,\n              }\n            );\n          }\n\n          resolve();\n        });\n\n        return () => {\n          controller.abort();\n        };\n      },\n    }),\n  },\n  outputs: {\n    \"cli:message\": output({\n      description: \"Send messages to the user\",\n      schema: z.object({\n        message: z.string().describe(\"The message to send\"),\n      }),\n      handler(content) {\n        console.log(\"Agent:\", content.message);\n        return {\n          data: content,\n          timestamp: Date.now(),\n        };\n      },\n      format: ({ data }) =>\n        formatMsg({\n          role: \"assistant\",\n          content: data.message,\n        }),\n    }),\n  },\n});\n","import { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport { SSEClientTransport } from \"@modelcontextprotocol/sdk/client/sse.js\";\n\n/**\n * Creates and connects an MCP client to a server\n * @param options Configuration options for the MCP client\n * @returns Connected MCP client instance\n */\nexport async function createMcpClient(options: {\n  // Client identification\n  clientInfo?: {\n    name: string;\n    version: string;\n  };\n  // Transport configuration\n  transport: {\n    type: \"stdio\" | \"sse\";\n    // For stdio transport\n    command?: string;\n    args?: string[];\n    // For SSE transport\n    serverUrl?: string;\n    sseEndpoint?: string;\n    messageEndpoint?: string;\n  };\n  // Capabilities to request from the server\n  capabilities?: {\n    prompts?: Record<string, unknown>;\n    resources?: Record<string, unknown>;\n    tools?: Record<string, unknown>;\n  };\n}) {\n  // Set default client info if not provided\n  const clientInfo = options.clientInfo || {\n    name: \"generic-mcp-client\",\n    version: \"1.0.0\",\n  };\n\n  // Set default capabilities if not provided\n  const capabilities = options.capabilities || {\n    prompts: {},\n    resources: {},\n    tools: {},\n  };\n\n  // Create the appropriate transport based on the type\n  let transport;\n  if (options.transport.type === \"stdio\") {\n    if (!options.transport.command) {\n      throw new Error(\"Command is required for stdio transport\");\n    }\n\n    transport = new StdioClientTransport({\n      command: options.transport.command,\n      args: options.transport.args || [],\n    });\n  } else if (options.transport.type === \"sse\") {\n    if (!options.transport.serverUrl) {\n      throw new Error(\"Server URL is required for SSE transport\");\n    }\n\n    // Create the SSE transport with the correct configuration\n    // Convert string URL to URL object\n    const serverUrl = new URL(options.transport.serverUrl);\n    transport = new SSEClientTransport(serverUrl);\n  } else {\n    throw new Error(`Unsupported transport type: ${options.transport.type}`);\n  }\n\n  // Create the client\n  const client = new Client(clientInfo, { capabilities });\n\n  // Connect to the server\n  await client.connect(transport);\n\n  return client;\n}\n\n// Example usage:\n/*\n// Connect to a stdio-based server\nconst stdioClient = await createMcpClient({\n  clientInfo: {\n    name: \"my-agent\",\n    version: \"1.0.0\",\n  },\n  transport: {\n    type: \"stdio\",\n    command: \"node\",\n    args: [\"server.js\"],\n  },\n  capabilities: {\n    prompts: {},\n    resources: {},\n    tools: {},\n  },\n});\n\n// Connect to an SSE-based server\nconst sseClient = await createMcpClient({\n  transport: {\n    type: \"sse\",\n    serverUrl: \"http://localhost:3001\",\n  },\n});\n\n// List prompts\nconst prompts = await client.listPrompts();\n\n// Get a prompt\nconst prompt = await client.getPrompt({\n  name: \"example-prompt\",\n  arguments: {\n    arg1: \"value\",\n  },\n});\n\n// List resources\nconst resources = await client.listResources();\n\n// Read a resource\nconst resource = await client.readResource({\n  uri: \"file:///example.txt\",\n});\n\n// Call a tool\nconst result = await client.callTool({\n  name: \"example-tool\",\n  arguments: {\n    arg1: \"value\",\n  },\n});\n*/\n","import { z } from \"zod\";\nimport { createMcpClient } from \"./client\";\nimport type { AnyAgent, Extension, ActionCall } from \"../../types\";\nimport { Logger } from \"../../logger\";\n\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\n\nexport interface McpServerConfig {\n  id: string;\n  name: string;\n  transport: {\n    type: \"stdio\" | \"sse\";\n    // For stdio transport\n    command?: string;\n    args?: string[];\n    // For SSE transport\n    serverUrl?: string;\n    sseEndpoint?: string;\n    messageEndpoint?: string;\n  };\n  capabilities?: {\n    prompts?: Record<string, unknown>;\n    resources?: Record<string, unknown>;\n    tools?: Record<string, unknown>;\n  };\n}\n\n/**\n * Creates an extension that connects to one or more MCP servers\n * and exposes their capabilities as actions within the agent system.\n *\n * @param servers Configuration for one or more MCP servers to connect to\n * @returns An extension that can be added to the agent's extensions list\n */\nexport function createMcpExtension(servers: McpServerConfig[]): Extension {\n  const clients = new Map<string, Client>();\n\n  return {\n    name: \"mcp\",\n\n    // Initialize MCP clients when the extension is installed\n    async install(agent: AnyAgent) {\n      const logger = agent.container.resolve<Logger>(\"logger\");\n\n      logger.info(\"mcp:extension\", \"Installing MCP extension\", {\n        serversCount: servers.length,\n      });\n\n      // Connect to each configured MCP server\n      for (const server of servers) {\n        logger.debug(\"mcp:extension\", \"Connecting to MCP server\", {\n          id: server.id,\n          name: server.name,\n          transportType: server.transport.type,\n        });\n\n        try {\n          const client = await createMcpClient({\n            clientInfo: {\n              name: `agent-mcp-client`,\n              version: \"1.0.0\",\n            },\n            transport: server.transport,\n            capabilities: server.capabilities,\n          });\n\n          clients.set(server.id, client);\n          logger.info(\"mcp:extension\", \"Connected to MCP server\", {\n            id: server.id,\n            name: server.name,\n          });\n        } catch (error) {\n          logger.error(\"mcp:extension\", \"Failed to connect to MCP server\", {\n            id: server.id,\n            name: server.name,\n            error,\n          });\n        }\n      }\n    },\n\n    // Define actions for interacting with MCP servers\n    actions: [\n      // Action to list available prompts from a specific MCP server\n      {\n        name: \"mcp.listPrompts\",\n        description: \"List available prompts from an MCP server\",\n        schema: z.object({\n          serverId: z.string().describe(\"ID of the MCP server to query\"),\n        }),\n        async handler(call: ActionCall<{ serverId: string }>, ctx, agent) {\n          const logger = agent.container.resolve<Logger>(\"logger\");\n          const { serverId } = call.data;\n\n          const client = clients.get(serverId);\n          if (!client) {\n            return {\n              error: `MCP server with ID '${serverId}' not found`,\n            };\n          }\n\n          try {\n            const prompts = await client.listPrompts();\n            return { prompts };\n          } catch (error) {\n            logger.error(\"mcp:action\", \"Failed to list prompts\", {\n              serverId,\n              error,\n            });\n            return { error: String(error) };\n          }\n        },\n      },\n\n      // Action to get a prompt from a specific MCP server\n      {\n        name: \"mcp.getPrompt\",\n        description: \"Get a prompt from an MCP server\",\n        schema: z.object({\n          serverId: z.string().describe(\"ID of the MCP server to query\"),\n          name: z.string().describe(\"Name of the prompt to get\"),\n          arguments: z\n            .record(z.any())\n            .optional()\n            .describe(\"Arguments for the prompt\"),\n        }),\n        async handler(\n          call: ActionCall<{\n            serverId: string;\n            name: string;\n            arguments?: Record<string, any>;\n          }>,\n          ctx,\n          agent\n        ) {\n          const logger = agent.container.resolve<Logger>(\"logger\");\n          const { serverId, name, arguments: args } = call.data;\n\n          const client = clients.get(serverId);\n          if (!client) {\n            return {\n              error: `MCP server with ID '${serverId}' not found`,\n            };\n          }\n\n          try {\n            const prompt = await client.getPrompt({\n              name,\n              arguments: args || {},\n            });\n            return { prompt };\n          } catch (error) {\n            logger.error(\"mcp:action\", \"Failed to get prompt\", {\n              serverId,\n              name,\n              error,\n            });\n            return { error: String(error) };\n          }\n        },\n      },\n\n      // Action to list available resources from a specific MCP server\n      {\n        name: \"mcp.listResources\",\n        description: \"List available resources from an MCP server\",\n        schema: z.object({\n          serverId: z.string().describe(\"ID of the MCP server to query\"),\n        }),\n        async handler(call: ActionCall<{ serverId: string }>, ctx, agent) {\n          const logger = agent.container.resolve<Logger>(\"logger\");\n          const { serverId } = call.data;\n\n          const client = clients.get(serverId);\n          if (!client) {\n            return {\n              error: `MCP server with ID '${serverId}' not found`,\n            };\n          }\n\n          try {\n            const resources = await client.listResources();\n            return { resources };\n          } catch (error) {\n            logger.error(\"mcp:action\", \"Failed to list resources\", {\n              serverId,\n              error,\n            });\n            return { error: String(error) };\n          }\n        },\n      },\n\n      // Action to read a resource from a specific MCP server\n      {\n        name: \"mcp.readResource\",\n        description: \"Read a resource from an MCP server\",\n        schema: z.object({\n          serverId: z.string().describe(\"ID of the MCP server to query\"),\n          uri: z.string().describe(\"URI of the resource to read\"),\n        }),\n        async handler(\n          call: ActionCall<{ serverId: string; uri: string }>,\n          ctx,\n          agent\n        ) {\n          const logger = agent.container.resolve<Logger>(\"logger\");\n          const { serverId, uri } = call.data;\n\n          const client = clients.get(serverId);\n          if (!client) {\n            return {\n              error: `MCP server with ID '${serverId}' not found`,\n            };\n          }\n\n          try {\n            const resource = await client.readResource({\n              uri,\n            });\n            return { resource };\n          } catch (error) {\n            logger.error(\"mcp:action\", \"Failed to read resource\", {\n              serverId,\n              uri,\n              error,\n            });\n            return { error: String(error) };\n          }\n        },\n      },\n\n      // Action to call a tool on a specific MCP server\n      {\n        name: \"mcp.callTool\",\n        description: \"Call a tool on an MCP server\",\n        schema: z.object({\n          serverId: z.string().describe(\"ID of the MCP server to query\"),\n          name: z.string().describe(\"Name of the tool to call\"),\n          arguments: z\n            .record(z.any())\n            .optional()\n            .describe(\"Arguments for the tool\"),\n        }),\n        async handler(\n          call: ActionCall<{\n            serverId: string;\n            name: string;\n            arguments?: Record<string, any>;\n          }>,\n          ctx,\n          agent\n        ) {\n          const logger = agent.container.resolve<Logger>(\"logger\");\n          const { serverId, name, arguments: args } = call.data;\n\n          const client = clients.get(serverId);\n          if (!client) {\n            return {\n              error: `MCP server with ID '${serverId}' not found`,\n            };\n          }\n\n          try {\n            const result = await client.callTool({\n              name,\n              arguments: args || {},\n            });\n            return { result };\n          } catch (error) {\n            logger.error(\"mcp:action\", \"Failed to call tool\", {\n              serverId,\n              name,\n              error,\n            });\n            return { error: String(error) };\n          }\n        },\n      },\n\n      // Action to list all connected MCP servers\n      {\n        name: \"mcp.listServers\",\n        description: \"List all connected MCP servers\",\n        schema: z.object({}),\n        async handler(call: ActionCall<{}>, ctx, agent) {\n          const serverList = servers.map((server) => ({\n            id: server.id,\n            name: server.name,\n            connected: clients.has(server.id),\n            transportType: server.transport.type,\n          }));\n\n          return { servers: serverList };\n        },\n      },\n\n      // Action to list available tools from a specific MCP server\n      {\n        name: \"mcp.listTools\",\n        description: \"List available tools from an MCP server\",\n        schema: z.object({\n          serverId: z.string().describe(\"ID of the MCP server to query\"),\n        }),\n        async handler(call: ActionCall<{ serverId: string }>, ctx, agent) {\n          const logger = agent.container.resolve<Logger>(\"logger\");\n          const { serverId } = call.data;\n\n          const client = clients.get(serverId);\n          if (!client) {\n            return {\n              error: `MCP server with ID '${serverId}' not found`,\n            };\n          }\n\n          try {\n            const tools = await client.listTools();\n            return { tools };\n          } catch (error) {\n            logger.error(\"mcp:action\", \"Failed to list tools\", {\n              serverId,\n              error,\n            });\n            return { error: String(error) };\n          }\n        },\n      },\n    ],\n  };\n}\n"],"mappings":"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","names":["readline","z","cliContext","user","z","readlineService","service","container","cli","text","formatMsg","send","rl","controller","resolve","question","content","data","Client","StdioClientTransport","SSEClientTransport","createMcpClient","options","clientInfo","capabilities","transport","serverUrl","client","z","createMcpExtension","servers","clients","agent","logger","server","client","createMcpClient","error","z","call","ctx","serverId","name","args","uri"]}