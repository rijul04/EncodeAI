{"version":3,"sources":["../src/container.ts","../src/task.ts","../src/memory/base.ts","../src/tasks/index.ts","../src/prompt.ts","../src/prompts/main.ts","../src/handlers.ts","../src/memory/utils.ts","../src/streaming.ts","../src/dreams.ts","../src/providers/api.ts"],"sourcesContent":["/**\n * Represents a constructor function that creates an instance of type T.\n */\ntype Constructor<T> = new (...args: any[]) => T;\n\n/**\n * Represents a factory function that creates an instance of type T using the container.\n */\ntype Factory<T> = (container: Container) => T;\n\n/**\n * Represents any function type.\n */\ntype FunctionType = (...args: any[]) => any;\n\n/**\n * Represents a dependency injection token that can be a string, symbol, constructor, or function.\n */\ntype Token = string | symbol | Constructor<any> | FunctionType;\n\n/**\n * Interface for a dependency injection container.\n */\nexport interface Container {\n  /**\n   * Registers a factory function for a token.\n   * Each time the token is resolved, the factory will be called to create a new instance.\n   *\n   * @param token - The token to register\n   * @param factory - The factory function that creates the instance\n   * @returns The container instance for chaining\n   */\n  register: <T>(token: Token, factory: Factory<T>) => Container;\n\n  /**\n   * Registers a singleton factory function for a token.\n   * The factory will be called only once when the token is first resolved,\n   * and the same instance will be returned for subsequent resolutions.\n   *\n   * @param token - The token to register\n   * @param factory - The factory function that creates the singleton instance\n   * @returns The container instance for chaining\n   */\n  singleton: <T>(token: Token, factory: Factory<T>) => Container;\n\n  /**\n   * Registers a pre-created instance for a token.\n   *\n   * @param token - The token to register\n   * @param instance - The instance to register\n   * @returns The container instance for chaining\n   */\n  instance: <T>(token: Token, instance: T) => Container;\n\n  /**\n   * Creates an alias for an existing token.\n   *\n   * @param aliasToken - The alias token (must be a string or symbol)\n   * @param originalToken - The original token to alias\n   * @returns The container instance for chaining\n   */\n  alias: (aliasToken: string | symbol, originalToken: Token) => Container;\n\n  /**\n   * Resolves a token to its registered instance.\n   *\n   * @param token - The token to resolve\n   * @returns The resolved instance\n   * @throws Error if no registration is found for the token\n   */\n  resolve: <T>(token: Token) => T;\n}\n\n/**\n * Creates a new dependency injection container.\n *\n * @returns A new Container instance\n *\n * @example\n * ```typescript\n * const container = createContainer();\n *\n * // Register a transient dependency\n * container.register('logger', () => new Logger());\n *\n * // Register a singleton\n * container.singleton('database', (c) => new Database(c.resolve('config')));\n *\n * // Register a pre-created instance\n * container.instance('config', { connectionString: 'mongodb://localhost:27017' });\n *\n * // Create an alias\n * container.alias('db', 'database');\n *\n * // Resolve dependencies\n * const db = container.resolve<Database>('db');\n * ```\n */\nexport const createContainer = (): Container => {\n  const instances = new Map<Token, any>();\n  const factories = new Map<Token, Factory<any>>();\n  const singletons = new Set<Token>();\n  const aliases = new Map<string | symbol, Token>();\n\n  /**\n   * Converts a token to a string representation for error messages.\n   */\n  const getTokenString = (token: Token): string => {\n    if (typeof token === \"string\") return token;\n    if (typeof token === \"symbol\") return token.toString();\n    if (typeof token === \"function\") {\n      return token.name || \"anonymous function\";\n    }\n    return \"unknown token\";\n  };\n\n  /**\n   * Resolves a token to its original token if it's an alias.\n   */\n  const resolveToken = (token: Token): Token => {\n    if (typeof token === \"string\" || typeof token === \"symbol\") {\n      return aliases.get(token) || token;\n    }\n    return token;\n  };\n\n  const container: Container = {\n    register: <T>(token: Token, factory: Factory<T>): Container => {\n      factories.set(token, factory);\n      instances.delete(token);\n      return container;\n    },\n\n    singleton: <T>(token: Token, factory: Factory<T>): Container => {\n      factories.set(token, factory);\n      singletons.add(token);\n      instances.delete(token);\n      return container;\n    },\n\n    instance: <T>(token: Token, value: T): Container => {\n      instances.set(token, value);\n      factories.delete(token);\n      singletons.delete(token);\n      return container;\n    },\n\n    alias: (aliasToken: string | symbol, originalToken: Token): Container => {\n      aliases.set(aliasToken, originalToken);\n      return container;\n    },\n\n    resolve: <T>(token: Token): T => {\n      const resolvedToken = resolveToken(token);\n\n      if (instances.has(resolvedToken)) {\n        return instances.get(resolvedToken);\n      }\n\n      const factory = factories.get(resolvedToken);\n      if (!factory) {\n        throw new Error(\n          `No registration found for ${getTokenString(resolvedToken)}`\n        );\n      }\n\n      if (singletons.has(resolvedToken)) {\n        if (!instances.has(resolvedToken)) {\n          instances.set(resolvedToken, factory(container));\n        }\n        return instances.get(resolvedToken);\n      }\n\n      return factory(container);\n    },\n  };\n\n  return container;\n};\n\nexport default createContainer;\n","import { v7 as randomUUIDv7 } from \"uuid\";\nimport type { Debugger } from \"./types\";\n\n/**\n * Options for configuring a task.\n */\nexport type TaskOptions = {\n  limit?: number;\n  retry?: number;\n  debug?: Debugger;\n  priority?: number;\n  callId?: string;\n};\n\n/**\n * Context provided to a task.\n */\nexport type TaskContext = {\n  callId: string;\n  debug: Debugger;\n};\n\n/**\n * A task function that takes parameters and options and returns a promise.\n */\nexport type Task<in Params, out Result> = (\n  params: Params,\n  options?: TaskOptions\n) => Promise<Result>;\n\ntype InferTaskParams<T extends Task<any, any>> =\n  T extends Task<infer Params, any> ? Params : unknown;\ntype InferTaskResult<T extends Task<any, any>> =\n  T extends Task<any, infer Result> ? Result : unknown;\n\n/**\n * Represents a task that is queued for execution.\n */\ninterface QueuedTask {\n  id: string;\n  execute: () => Promise<any>;\n  priority: number;\n  resolve: (value: any) => void;\n  reject: (reason: any) => void;\n}\n\n/**\n * Manages the execution of tasks with concurrency control.\n */\nexport class TaskRunner {\n  private queue: QueuedTask[] = [];\n  private running: Set<string> = new Set();\n  private concurrency: number;\n  private processing: boolean = false;\n\n  /**\n   * Creates a new TaskRunner instance.\n   * @param concurrency - The maximum number of tasks to run concurrently.\n   */\n  constructor(concurrency: number = 1) {\n    this.concurrency = concurrency;\n  }\n\n  /**\n   * Sets the concurrency level for the task runner.\n   * @param concurrency - The new concurrency level.\n   */\n  setConcurrency(concurrency: number) {\n    this.concurrency = concurrency;\n    this.processQueue();\n  }\n\n  /**\n   * Processes the task queue, running tasks up to the concurrency limit.\n   */\n  private async processQueue() {\n    if (this.processing) return;\n    this.processing = true;\n\n    try {\n      while (this.queue.length > 0 && this.running.size < this.concurrency) {\n        // Sort entire queue by priority\n        this.queue.sort((a, b) => b.priority - a.priority);\n\n        const task = this.queue.shift();\n        if (!task) break;\n\n        this.running.add(task.id);\n\n        // Execute task without awaiting to allow concurrent execution\n        task\n          .execute()\n          .then((result) => {\n            task.resolve(result);\n          })\n          .catch((error) => {\n            task.reject(error);\n          })\n          .finally(() => {\n            this.running.delete(task.id);\n            // Try to process more tasks after one completes\n            this.processQueue();\n          });\n      }\n    } finally {\n      this.processing = false;\n    }\n  }\n\n  /**\n   * Enqueues a task for execution.\n   * @param taskFn - The function to execute as a task.\n   * @param priority - The priority of the task.\n   * @returns A promise that resolves when the task is completed.\n   */\n  enqueue<T>(taskFn: () => Promise<T>, priority: number = 0): Promise<T> {\n    return new Promise((resolve, reject) => {\n      const queuedTask: QueuedTask = {\n        id: randomUUIDv7(),\n        execute: taskFn,\n        priority,\n        resolve,\n        reject,\n      };\n\n      this.queue.push(queuedTask);\n      // Use setTimeout to ensure proper task ordering\n      setTimeout(() => this.processQueue(), 0);\n    });\n  }\n\n  /**\n   * Gets the number of active tasks.\n   */\n  get activeTasksCount(): number {\n    return this.running.size;\n  }\n\n  /**\n   * Gets the number of tasks in the queue.\n   */\n  get queuedTasksCount(): number {\n    return this.queue.length;\n  }\n\n  /**\n   * Enqueues a task function for execution.\n   * @param taskFn - The task function to execute\n   * @param params - Parameters to pass to the task\n   * @param options - Task options including priority\n   * @returns A promise that resolves when the task is completed\n   */\n  enqueueTask<TTask extends Task<any, any>>(\n    taskFn: TTask,\n    params: InferTaskParams<TTask>,\n    options: TaskOptions = {}\n  ): Promise<InferTaskResult<TTask>> {\n    return this.enqueue(() => taskFn(params, options), options.priority ?? 0);\n  }\n}\n\n/**\n * Creates a task function that can be executed or enqueued.\n * @param key - A unique key for the task.\n * @param fn - The function to execute as the task.\n * @param defaultOptions - Default options for the task.\n * @returns A task function that can be executed directly or enqueued.\n */\nexport function task<Params, Result>(\n  key: string,\n  fn: (params: Params, ctx: TaskContext) => Promise<Result>,\n  defaultOptions?: Omit<TaskOptions, \"callId\">\n): (params: Params, options?: TaskOptions) => Promise<Result> {\n  async function execute(params: Params, options?: TaskOptions) {\n    const callId = options?.callId ?? randomUUIDv7();\n\n    const mergedOptions = {\n      ...defaultOptions,\n      ...options,\n    };\n\n    delete mergedOptions.callId;\n\n    try {\n      const res = await Promise.resolve(\n        fn(params, {\n          callId,\n          debug: mergedOptions?.debug ?? (() => {}),\n        })\n      );\n      return res;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  return execute;\n}\n","import type { MemoryStore, VectorStore, WorkingMemory } from \"../types\";\nimport type { LanguageModelV1 } from \"ai\";\n/**\n * Base memory implementation providing storage and vector capabilities\n */\nexport type BaseMemory = {\n  /** Store for conversation memory data */\n  store: MemoryStore;\n  /** Store for vector embeddings and similarity search */\n  vector: VectorStore;\n  vectorModel?: LanguageModelV1;\n  generateMemories?: boolean;\n};\n\n/**\n * Creates a new BaseMemory instance\n * @param store - Memory store implementation for conversation data\n * @param vector - Vector store implementation for embeddings\n * @param vectorModel - Vector model implementation for embeddings\n * @returns A new BaseMemory instance\n */\nexport function createMemory(\n  store: MemoryStore,\n  vector: VectorStore,\n  vectorModel?: LanguageModelV1\n): BaseMemory {\n  return { store, vector, vectorModel };\n}\n\n/**\n * Retrieves or creates a new conversation memory for the given ID\n * @param memory - The memory store to use\n * @param conversationId - Unique identifier for the conversation\n * @returns A WorkingMemory object for the conversation\n */\nexport async function getOrCreateConversationMemory(\n  memory: MemoryStore,\n  conversationId: string\n): Promise<WorkingMemory> {\n  const data = await memory.get<WorkingMemory>(conversationId);\n  if (data) return data;\n  return {\n    inputs: [],\n    outputs: [],\n    thoughts: [],\n    calls: [],\n    results: [],\n  };\n}\n\n/**\n * Creates a new in-memory store for conversation data\n * @returns A MemoryStore implementation using a Map for storage\n */\nconst data = new Map<string, any>();\nexport function createMemoryStore(): MemoryStore {\n  return {\n    /**\n     * Retrieves a value from the store\n     * @param key - Key to look up\n     * @returns The stored value or null if not found\n     */\n    async get(key: string) {\n      return data.get(key) ?? null;\n    },\n\n    /**\n     * Removes all entries from the store\n     */\n    async clear() {\n      data.clear();\n    },\n\n    /**\n     * Removes a specific entry from the store\n     * @param key - Key to remove\n     */\n    async delete(key: string) {\n      data.delete(key);\n    },\n\n    /**\n     * Stores a value in the store\n     * @param key - Key to store under\n     * @param value - Value to store\n     */\n    async set(key: string, value: any) {\n      data.set(key, value);\n    },\n  };\n}\n\n/**\n * Creates a no-op vector store implementation\n * @returns A VectorStore implementation that performs no operations\n */\nexport function createVectorStore(): VectorStore {\n  return {\n    /**\n     * No-op implementation of vector store upsert\n     * @param contextId - Context ID (unused)\n     * @param data - Data to store (unused)\n     */\n    upsert(contextId: string, data: any[]) {\n      return Promise.resolve();\n    },\n\n    /**\n     * No-op implementation of vector store query\n     * @param contextId - Context ID (unused)\n     * @param query - Query string (unused)\n     * @returns Empty array\n     */\n    query(contextId: string, query: string) {\n      return Promise.resolve([]);\n    },\n\n    /**\n     * No-op implementation of index creation\n     * @param indexName - Name of index to create (unused)\n     */\n    createIndex(indexName: string) {\n      return Promise.resolve();\n    },\n\n    /**\n     * No-op implementation of index deletion\n     * @param indexName - Name of index to delete (unused)\n     */\n    deleteIndex(indexName: string) {\n      return Promise.resolve();\n    },\n  };\n}\n","import {\n  smoothStream,\n  streamText,\n  type CoreMessage,\n  type LanguageModelV1,\n  type StreamTextResult,\n  type ToolSet,\n} from \"ai\";\nimport { parse, prompt, resultsPrompt } from \"../prompts/main\";\nimport { task, type TaskContext } from \"../task\";\nimport { formatContext, formatContexts } from \"../formatters\";\nimport { getWorkingMemoryLogs, renderWorkingMemory } from \"../context\";\nimport type {\n  ActionCall,\n  ActionContext,\n  AnyAction,\n  AnyAgent,\n  AnyContext,\n  ContextState,\n  Log,\n  Output,\n  WorkingMemory,\n} from \"../types\";\nimport type { Logger } from \"../logger\";\nimport { wrapStream } from \"../streaming\";\n\nconst customModelsConfig: Record<string, any> = {\n  \"qwen-qwq-32b\": {\n    prefix: \"\",\n  },\n};\n\n/**\n * Prepares a stream response by handling the stream result and parsing it.\n *\n * @param options - Configuration options\n * @param options.contextId - The ID of the context\n * @param options.step - The current step in the process\n * @param options.stream - The stream result to process\n * @param options.logger - The logger instance\n * @param options.task - The task context containing callId and debug function\n * @returns An object containing the parsed response promise and wrapped text stream\n */\nfunction prepareStreamResponse({\n  model,\n  stream,\n  logger,\n  contextId,\n  step,\n  task: { callId, debug },\n}: {\n  model: LanguageModelV1;\n  contextId: string;\n  step: string;\n  stream: StreamTextResult<ToolSet, never>;\n  logger: Logger;\n  task: TaskContext;\n}) {\n  const prefix = customModelsConfig[model.modelId]?.prefix ?? \"<think>\";\n  const suffix = \"</response>\";\n\n  const response = new Promise<ReturnType<typeof parse>>(\n    async (resolve, reject) => {\n      try {\n        const result = await stream.text;\n        const text = prefix + result + suffix;\n\n        debug(contextId, [step, callId], text);\n\n        logger.debug(\"agent:response\", text, {\n          contextId,\n          callId,\n        });\n\n        resolve(parse(text));\n      } catch (error) {\n        reject(error);\n      }\n    }\n  );\n\n  return {\n    response,\n    stream: wrapStream(stream.textStream, prefix, suffix),\n  };\n}\n\n/**\n * Task that generates a response from the agent based on the current context and working memory.\n *\n * @param options - Configuration options\n * @param options.agent - The agent instance\n * @param options.contexts - Array of context states\n * @param options.contextId - The ID of the current context\n * @param options.workingMemory - The working memory state\n * @param options.outputs - Available outputs\n * @param options.actions - Available actions\n * @param options.logger - The logger instance\n * @param options.model - The language model to use\n * @param taskContext - The task context containing callId and debug function\n * @returns The prepared stream response with parsed result and text stream\n */\nexport const runGenerate = task(\n  \"agent:run:generate\",\n  async (\n    {\n      contexts,\n      workingMemory,\n      outputs,\n      actions,\n      logger,\n      model,\n      contextId,\n      abortSignal,\n    }: {\n      agent: AnyAgent;\n      contexts: ContextState<AnyContext>[];\n      contextId: string;\n      workingMemory: WorkingMemory;\n      outputs: Output[];\n      actions: AnyAction[];\n      logger: Logger;\n      model: LanguageModelV1;\n      abortSignal?: AbortSignal;\n    },\n    { callId, debug }: TaskContext\n  ) => {\n    debug(\n      contextId,\n      [\"workingMemory\", callId],\n      JSON.stringify(workingMemory, null, 2)\n    );\n\n    const mainContext = contexts.find((ctx) => ctx.id === contextId)!;\n\n    const system = prompt({\n      context: formatContexts(contextId, contexts, workingMemory),\n      outputs,\n      actions,\n      updates: formatContext({\n        type: mainContext.context.type,\n        key: mainContext.key,\n        content: renderWorkingMemory({\n          memory: {\n            inputs: workingMemory.inputs,\n            results: workingMemory.results,\n          },\n          processed: false,\n        }),\n      }),\n    });\n\n    debug(contextId, [\"prompt\", callId], system);\n\n    logger.debug(\"agent:system\", system);\n\n    const messages = [\n      {\n        role: \"user\",\n        content: [\n          {\n            type: \"text\",\n            text: system,\n          },\n        ],\n      },\n      {\n        role: \"assistant\",\n        content: \"<think>\",\n      },\n    ] as CoreMessage[];\n\n    if (workingMemory.currentImage) {\n      messages[0].content = [\n        ...messages[0].content,\n        {\n          type: \"image\",\n          image: workingMemory.currentImage,\n        },\n      ] as CoreMessage[\"content\"];\n    }\n\n    const stream = streamText({\n      model,\n      messages,\n      stopSequences: [\"</response>\"],\n      temperature: 0.6,\n      abortSignal,\n      experimental_transform: smoothStream({\n        chunking: \"word\",\n      }),\n      onError: (error) => {\n        console.error(error);\n      },\n    });\n\n    // Clear the current image after using it\n    workingMemory.currentImage = undefined;\n\n    return prepareStreamResponse({\n      model,\n      step: \"response\",\n      contextId,\n      logger,\n      stream,\n      task: { callId, debug },\n    });\n  }\n);\n\n/**\n * Task that generates results based on the agent's actions and working memory.\n *\n * @param options - Configuration options\n * @param options.agent - The agent instance\n * @param options.contexts - Array of context states\n * @param options.contextId - The ID of the current context\n * @param options.workingMemory - The working memory state\n * @param options.outputs - Available outputs\n * @param options.actions - Available actions\n * @param options.logger - The logger instance\n * @param options.model - The language model to use\n * @param options.chain - Array of logs representing the action chain\n * @param taskContext - The task context containing callId and debug function\n * @returns The prepared stream response with parsed result and text stream\n */\nexport const runGenerateResults = task(\n  \"agent:run:generate-results\",\n  async (\n    {\n      contexts,\n      workingMemory,\n      outputs,\n      actions,\n      logger,\n      model,\n      contextId,\n      chain,\n      abortSignal,\n    }: {\n      agent: AnyAgent;\n      contexts: ContextState<AnyContext>[];\n      contextId: string;\n      workingMemory: WorkingMemory;\n      outputs: Output[];\n      actions: AnyAction[];\n      logger: Logger;\n      model: LanguageModelV1;\n      chain: Log[];\n      abortSignal?: AbortSignal;\n    },\n    { callId, debug }: TaskContext\n  ) => {\n    debug(\n      contextId,\n      [\"workingMemory\", callId],\n      JSON.stringify(workingMemory, null, 2)\n    );\n\n    const mainContext = contexts.find((ctx) => ctx.id === contextId)!;\n\n    const system = resultsPrompt({\n      context: formatContexts(contextId, contexts, workingMemory),\n      outputs,\n      actions,\n      updates: formatContext({\n        type: mainContext.context.type,\n        key: mainContext.key,\n        content: renderWorkingMemory({\n          memory: {\n            inputs: workingMemory.inputs,\n          },\n          processed: false,\n        }),\n      }),\n      logs: chain.filter((i) =>\n        i.ref === \"action_result\" ? false : i.processed !== true\n      ),\n      results: workingMemory.results.filter((i) => i.processed !== true),\n    });\n\n    getWorkingMemoryLogs(workingMemory).forEach((i) => {\n      if (i.ref !== \"input\") i.processed = true;\n    });\n\n    debug(contextId, [\"prompt-results\", callId], system);\n\n    logger.debug(\"agent:system\", system, {\n      contextId,\n      callId,\n    });\n\n    const messages = [\n      {\n        role: \"user\",\n        content: [\n          {\n            type: \"text\",\n            text: system,\n          },\n        ],\n      },\n      {\n        role: \"assistant\",\n        content: \"<think>\",\n      },\n    ] as CoreMessage[];\n\n    if (workingMemory.currentImage) {\n      messages[0].content = [\n        ...messages[0].content,\n        {\n          type: \"image\",\n          image: workingMemory.currentImage,\n        },\n      ] as CoreMessage[\"content\"];\n    }\n\n    const stream = streamText({\n      model,\n      messages: messages,\n      stopSequences: [\"</response>\"],\n      temperature: 0.6,\n      abortSignal,\n      experimental_transform: smoothStream({\n        chunking: \"word\",\n      }),\n      onError: (error) => {\n        console.error(error);\n      },\n    });\n\n    // Clear the current image after using it\n    workingMemory.currentImage = undefined;\n\n    return prepareStreamResponse({\n      model,\n      step: \"results-response\",\n      contextId,\n      logger,\n      stream,\n      task: { callId, debug },\n    });\n  }\n);\n\n/**\n * Task that executes an action with the given context and parameters.\n *\n * @param options - Configuration options\n * @param options.ctx - The agent context with memory\n * @param options.action - The action to execute\n * @param options.call - The action call details\n * @param options.agent - The agent instance\n * @param options.logger - The logger instance\n * @returns The result of the action execution\n * @throws Will throw an error if the action execution fails\n */\nexport const runAction = task(\n  \"agent:run:action\",\n  async <TContext extends AnyContext>({\n    ctx,\n    action,\n    call,\n    agent,\n    logger,\n  }: {\n    ctx: ActionContext<TContext>;\n    action: AnyAction;\n    call: ActionCall;\n    agent: AnyAgent;\n    logger: Logger;\n  }) => {\n    try {\n      logger.info(\n        \"agent:action_call:\" + call.id,\n        call.name,\n        JSON.stringify(call.data)\n      );\n      const result = await action.handler(call, ctx, agent);\n      logger.debug(\"agent:action_result:\" + call.id, call.name, result);\n      return result;\n    } catch (error) {\n      logger.error(\"agent:action\", \"ACTION_FAILED\", { error });\n      throw error;\n    }\n  }\n);\n","import { ZodType } from \"zod\";\nimport zodToJsonSchema from \"zod-to-json-schema\";\nimport type { Node, ElementNode } from \"./xml\";\nimport { parse as parseXML } from \"./xml\";\nimport { render } from \"./utils\";\nimport type { TemplateVariables } from \"./types\";\n\nexport type Formatter<\n  Variables extends Record<string, any> = Record<string, any>,\n  Data = any,\n> = (data: Data) => Record<keyof Variables, any>;\n\nexport type InferFormatter<TPrompt extends AnyPrompt> =\n  TPrompt extends Prompt<infer Data, infer Variables>\n    ? Formatter<Variables, Data>\n    : never;\n\nexport type PromptVisitor<\n  Output = any,\n  Attributes extends Record<string, any> = Record<string, any>,\n> = (\n  output: Output,\n  node: ElementNode<Attributes>,\n  parse: () => Node[]\n) => void;\n\nexport type GetVisitors<\n  Output = any,\n  T extends Record<string, Record<string, any>> = Record<\n    string,\n    Record<string, any>\n  >,\n> = {\n  [K in keyof T]?: PromptVisitor<Output, T[K]>;\n} & {\n  [key: string]: PromptVisitor<Output, any>;\n};\n\nexport type Prompt<\n  Data = any,\n  Variables extends Record<string, any> = Record<string, any>,\n> = <TData extends Data>(\n  data: TData,\n  formatter?: Formatter<Variables, TData>\n) => string;\n\nexport type AnyPrompt = Prompt<any, any>;\n\nexport type InferPromptVariables<TPrompt extends AnyPrompt> =\n  TPrompt extends Prompt<any, infer Vars> ? Vars : never;\n\nexport type InferPromptData<TPrompt extends AnyPrompt> =\n  TPrompt extends Prompt<infer Data> ? Data : never;\n\nexport type GeneratePromptConfig<\n  TPrompt extends AnyPrompt | string = any,\n  Variables extends Record<string, any> = any,\n  Data = Record<string, any>,\n  TFormatter extends Formatter<Variables, Data> = Formatter<Variables, Data>,\n> = {\n  template: TPrompt;\n  variables: Variables;\n  data: Data;\n  formatter?: TFormatter;\n};\n\nexport type InferGeneratePromptConfig<TPrompt extends AnyPrompt | string> =\n  | (TPrompt extends Prompt<infer Data, infer Variables>\n      ? GeneratePromptConfig<TPrompt, Variables, Data>\n      : never)\n  | (TPrompt extends string\n      ? GeneratePromptConfig<TPrompt, TemplateVariables<TPrompt>>\n      : never);\n\nexport type InferPromptComponents<TPrompt extends AnyPrompt | string> =\n  TPrompt extends Prompt<any, infer Components> ? Components : never;\n\nexport function getZodJsonSchema(schema: ZodType<any>) {\n  return zodToJsonSchema(schema, \"schema\").definitions!.schema;\n}\n\nexport function createPrompt<\n  Template extends string = string,\n  Variables extends TemplateVariables<Template> = TemplateVariables<Template>,\n  Data extends Record<string, any> = Record<string, any>,\n>(\n  prompt: Template,\n  formatter?: Formatter<Variables, Data>\n): Prompt<Data, Variables> {\n  return (data, customFormatter) => {\n    return render(\n      prompt,\n      customFormatter\n        ? customFormatter(data)\n        : formatter\n          ? formatter(data)\n          : data\n    );\n  };\n}\n\nexport type Parser<Output> = (content: string) => Output;\n\nexport function createParser<\n  Output = any,\n  Components extends Record<string, Record<string, any>> = Record<\n    string,\n    Record<string, any>\n  >,\n  Visitors extends GetVisitors<Output, Components> = GetVisitors<\n    Output,\n    Components\n  >,\n>(getOutput: () => Output, visitors: Visitors): Parser<Output> {\n  return (content) => {\n    const validTags = new Set(Object.keys(visitors));\n\n    // fix for bad outputs;\n\n    content = content\n      .split(\"\\n\")\n      .map((line) => {\n        // Check if line starts with '/'\n        if (line.startsWith(\"/\")) {\n          // Extract the tag name using regex\n          const match = line.match(/^\\/([^ >]+)/);\n\n          if (match && match[1]) {\n            const tagName = match[1];\n\n            // Check if this is a valid tag\n            if (validTags.has(tagName)) {\n              console.log(\"fixing line:\\n\" + line);\n              // Replace the leading '/' with '<'\n              return line.replace(\"/\", \"<\");\n            }\n          }\n        }\n\n        // Return original line if no fix needed\n        return line;\n      })\n      .join(\"\\n\");\n\n    const state = getOutput();\n\n    parseXML(content, (node, parse) => {\n      if (node.type === \"element\" && node.name in visitors) {\n        visitors[node.name](state, node as ElementNode<any>, parse);\n      }\n      return node;\n    });\n\n    return state;\n  };\n}\n","import {\n  formatAction,\n  formatContextLog,\n  formatOutputInterface,\n} from \"../formatters\";\nimport { createParser, createPrompt } from \"../prompt\";\nimport type { ActionResult, AnyAction, Log, Output } from \"../types\";\nimport { xmlStreamParser } from \"../xml\";\n\n/*\n\n## Instructions\n- If asked for something - never do a summary unless you are asked to do a summary. Always respond with the exact information requested.\n- You must use the available actions and outputs to respond to the context.\n- You must reason about the context, think, and planned actions.\n- IMPORTANT: If you state that you will perform an action, you MUST issue the corresponding action call. Do not say you will do something without actually issuing the action call.\n- IMPORTANT: Never end your response with a plan to do something without actually doing it. Always follow through with action calls.\n- When you determine that no further actions or outputs are needed and the flow should end, use the <finalize/> tag to indicate completion.\n\n*/\n\nconst promptTemplate = `\nYou are tasked with analyzing messages, formulating responses, and initiating actions based on a given context. \nYou will be provided with a set of available actions, outputs, and a current context. \nYour instructions is to analyze the situation and respond appropriately.\n\nFollow these steps to process the updates:\n\n1. Analyze the updates and available data:\n   Wrap your reasoning process in <reasoning> tags. Consider:\n\n   - Check the available data to avoid redundant action calls\n   - The availabe contexts and their state\n   - The available actions and their asynchronous nature\n   - The content of the new updates\n   - Potential dependencies between actions\n\n   Response determination guidelines:\n\n   a) First check if required state exists in the available contexts\n   b) Respond to direct questions or requests for information\n\n2. Plan actions:\n   Before formulating a response, consider:\n\n   - What data is already available\n   - Which actions need to be initiated\n   - The order of dependencies between actions\n   - How to handle potential action failures\n   - What information to provide while actions are processing\n\n3. Formulate a output (if needed):\n   If you decide to respond to the message, use <output> tags to enclose your output.\n   Consider:\n\n   - Using available data when possible\n   - Acknowledging that certain information may not be immediately available\n   - Setting appropriate expectations about action processing time\n   - Indicating what will happen after actions complete\n\n4. Initiate actions (if needed):\n   Use <action_call> tags to initiate actions. Remember:\n\n   - Actions are processed asynchronously after your response\n   - Results will not be immediately available\n   - You can only use actions listed in the <available_actions> section\n   - Follow the schemas provided for each action\n   - Actions should be used when necessary to fulfill requests or provide information that cannot be conveyed through a simple response\n   - IMPORTANT: If you say you will perform an action, you MUST issue the corresponding action call here\n\n5. No output or action:\n   If you determine that no output or action is necessary, don't respond to that message.\n\nHere are the available actions you can initiate:\n<available_actions>\n{{actions}}\n</available_actions>\n\nHere are the available outputs you can use:\n<outputs>\n{{outputs}}\n</outputs>\n\nHere is the current contexts:\n<contexts>\n{{context}}\n</contexts>\n\nNow, analyze the following updates to contexts:\n<contexts>\n{{updates}}\n</contexts>\n\nHere's how you structure your response:\n<response>\n<reasoning>\n[Your reasoning of the context, think, messages, and planned actions]\n</reasoning>\n\n[List of async action calls to be initiated, if applicable]\n<action_call name=\"[Action name]\">[action arguments using the schema as JSON]</action_call>\n\n[List of outputs, if applicable]\n<output type=\"[Output type]\">\n[output data using the schema]\n</output>\n</response>\n\nIMPORTANT: Always include the 'type' attribute in the output tag and ensure it matches one of the available output types listed above.\n{{examples}}\n`;\n\nexport const prompt = createPrompt(\n  promptTemplate,\n  ({\n    outputs,\n    actions,\n    updates,\n    context,\n  }: {\n    context: string | string[];\n    outputs: Output[];\n    updates: string | string[];\n    actions: AnyAction[];\n  }) => ({\n    context: context,\n    outputs: outputs.map(formatOutputInterface),\n    actions:\n      actions.length > 0 ? actions.map(formatAction) : \"NO ACTIONS AVAILABLE\",\n    updates: updates,\n    examples: [],\n  })\n);\n\nexport const parse = createParser<\n  {\n    think: string[];\n    response: string | undefined;\n    reasonings: string[];\n    calls: { name: string; data: any; error?: any }[];\n    outputs: { type: string; content: string }[];\n  },\n  {\n    action: { name: string };\n    output: { type: string };\n  }\n>(\n  () => ({\n    think: [],\n    reasonings: [],\n    calls: [],\n    outputs: [],\n    response: undefined,\n  }),\n  {\n    response: (state, element, parse) => {\n      state.response = element.content;\n      return parse();\n    },\n\n    action_call: (state, element) => {\n      let [data, error] = [undefined, undefined] as [any, any];\n\n      try {\n        data = JSON.parse(element.content);\n      } catch (_error) {\n        error = _error;\n      }\n\n      state.calls.push({\n        name: element.attributes.name,\n        data,\n        error,\n      });\n    },\n\n    think: (state, element) => {\n      state.think.push(element.content);\n    },\n\n    reasoning: (state, element) => {\n      state.reasonings.push(element.content);\n    },\n\n    output: (state, element) => {\n      state.outputs.push({\n        type: element.attributes.type,\n        content: element.content,\n      });\n    },\n  }\n);\n\nconst resultsTemplate = `\nYou are an AI agent tasked with analyzing the results of previously initiated actions and formulating appropriate responses based on these results. \nYou will be provided with the original context, your previous analysis, and the results of the actions you initiated.\n\nFollow these steps to process the <action_results>:\n\n1. Analyze the results:\n   Wrap your thinking process in <reasoning> tags. Consider:\n\n   - The original context and your previous analysis\n   - The results of each <action_call> by their id\n   - Any dependencies between action results\n   - Success or failure status of each action\n   - Whether the combined results fulfill the original request\n\n2. Correlate results with previous actions:\n   For each action result:\n\n   - Match it with the corresponding action using callId\n   - Validate if the result meets the expected outcome\n   - Identify any missing or incomplete results\n   - You must determine if additional actions are needed based on these results\n\n3. Formulate a response (if needed):\n   If you decide to respond to the message, use <response> tags to enclose your response.\n   Consider:\n\n   - Using available data when possible\n   - Acknowledging that certain information may not be immediately available\n   - Setting appropriate expectations about action processing time\n   - Addressing any failures or unexpected results\n   - Providing relevant insights from the combined results\n   - Indicating if any follow-up actions are needed\n\n4. Initiate follow-up actions (if needed):\n   Use <action_call> tags to initiate actions. Remember:\n\n   - Actions are processed asynchronously after your response\n   - Results will not be immediately available\n   - You can only use actions listed in the <available_actions> section\n   - Follow the schemas provided for each action\n   - Actions should be used when necessary to fulfill requests or provide information that cannot be conveyed through a simple response\n   - IMPORTANT: If you say you will perform an action, you MUST issue the corresponding action call here\n   - IMPORTANT: Never end your response with a plan to do something without actually doing it. Always follow through with action calls.\n\nHere are the available actions you can initiate:\n<available_actions>\n{{actions}}\n</available_actions>\n\nHere are the available outputs you can use:\n<outputs>\n{{outputs}}\n</outputs>\n\nHere is the current contexts:\n<contexts>\n{{context}}\n</contexts>\n\nHere is the contexts that triggered the actions:\n<contexts>\n{{updates}}\n</contexts>\n\nNow, review your current chain of reasoning/actions/outputs:\n\n<chain>\n{{logs}}\n</chain>\n\nNow, analyze the latests action results:\n\n<action_results>\n{{results}}\n</action_results>\n\nHere's how you should structure your next response:\n<response>\n<reasoning>\n[Your reasoning of the context, think, messages, and planned actions]\n</reasoning>\n\n[List of async action calls to be initiated, if applicable]\n<action_call name=\"[Action name]\">[action arguments using the schema as JSON]</action_call>\n\n[List of outputs, if applicable]\n<output type=\"[Output type]\">\n[output data using the schema]\n</output>\n\n</response>\n\n# Remember\n- Always correlate results with their original actions using callId\n- Never repeat your outputs\n- Consider the complete chain of results when formulating responses\n- Address any failures or unexpected results explicitly\n- Initiate follow-up actions only when necessary\n- Provide clear, actionable insights based on the combined results\n- Maintain context awareness between original request and final results\n\nIMPORTANT: Always include the 'type' attribute in the output tag and ensure it matches one of the available output types listed above.\n`;\n\nexport const resultsPrompt = createPrompt(\n  resultsTemplate,\n  ({\n    outputs,\n    actions,\n    updates,\n    context,\n    logs,\n    results,\n  }: {\n    context: string | string[];\n    outputs: Output[];\n    updates: string | string[];\n    actions: AnyAction[];\n    logs: Log[];\n    results: ActionResult[];\n  }) => ({\n    logs: logs\n      // .sort((a, b) => (a.timestamp > b.timestamp ? 1 : -1))\n      .map((i) => formatContextLog(i))\n      .flat(),\n    results: results.map(formatContextLog),\n    context: context,\n    outputs: outputs.map(formatOutputInterface),\n    actions: actions.map(formatAction),\n    updates: updates,\n    examples: [],\n  })\n);\n","import type { Logger } from \"./logger\";\nimport type { TaskRunner } from \"./task\";\nimport { runAction } from \"./tasks\";\nimport type {\n  ActionCall,\n  ActionResult,\n  AnyAction,\n  AnyAgent,\n  AnyContext,\n  ContextState,\n  Memory,\n  Output,\n  OutputRef,\n  WorkingMemory,\n} from \"./types\";\nimport { randomUUIDv7 } from \"./utils\";\n\nclass ActionNotFoundError extends Error {\n  constructor(public call: ActionCall) {\n    super();\n  }\n}\n\nclass ParsingError extends Error {\n  constructor(public parsingError: unknown) {\n    super();\n  }\n}\n\nexport async function prepareActionCall({\n  call,\n  actions,\n  logger,\n}: {\n  call: ActionCall;\n  actions: AnyAction[];\n  logger: Logger;\n}) {\n  const action = actions.find((a) => a.name === call.name);\n\n  if (!action) {\n    logger.error(\"agent:action\", \"ACTION_MISMATCH\", {\n      name: call.name,\n      data: call.content,\n    });\n\n    throw new ActionNotFoundError(call);\n  }\n\n  try {\n    const data = action.schema.parse(\n      call.content.length > 0 ? JSON.parse(call.content) : {}\n    );\n\n    call.data = data;\n    return { action, data };\n  } catch (error) {\n    throw new ParsingError(error);\n  }\n}\n\nexport async function handleActionCall({\n  state,\n  workingMemory,\n  action,\n  logger,\n  call,\n  taskRunner,\n  agent,\n  agentState,\n  abortSignal,\n}: {\n  state: ContextState<AnyContext>;\n  workingMemory: WorkingMemory;\n  call: ActionCall;\n  action: AnyAction;\n  logger: Logger;\n  taskRunner: TaskRunner;\n  agent: AnyAgent;\n  agentState?: ContextState;\n  abortSignal?: AbortSignal;\n}) {\n  let actionMemory: Memory<any> | undefined = undefined;\n\n  if (action.memory) {\n    actionMemory =\n      (await agent.memory.store.get(action.memory.key)) ??\n      action.memory.create();\n  }\n\n  const resultData = await taskRunner.enqueueTask(\n    runAction,\n    {\n      action,\n      call,\n      agent,\n      logger,\n      ctx: {\n        ...state,\n        workingMemory,\n        actionMemory,\n        agentMemory: agentState?.memory,\n        abortSignal,\n      },\n    },\n    {\n      debug: agent.debugger,\n    }\n  );\n\n  const result: ActionResult = {\n    ref: \"action_result\",\n    id: randomUUIDv7(),\n    callId: call.id,\n    data: resultData,\n    name: call.name,\n    timestamp: Date.now(),\n    processed: false,\n  };\n\n  if (action.format) result.formatted = action.format(result);\n\n  if (action.memory) {\n    await agent.memory.store.set(action.memory.key, actionMemory);\n  }\n\n  return result;\n}\n\nexport async function handleOutput({\n  outputRef,\n  outputs,\n  logger,\n  state,\n  workingMemory,\n  agent,\n}: {\n  outputs: Output[];\n  outputRef: OutputRef;\n  logger: Logger;\n  workingMemory: WorkingMemory;\n  state: ContextState;\n  agent: AnyAgent;\n}) {\n  const output = outputs.find((output) => output.type === outputRef.type);\n\n  if (!output) {\n    logger.error(\"agent:output\", \"OUTPUT_NOT_FOUND\", {\n      outputRef,\n      availableOutputs: outputs.map((o) => o.type),\n    });\n    return {\n      ...outputRef,\n      params: { error: \"OUTPUT NOT FOUND\" },\n      timestamp: Date.now(),\n      data: { content: outputRef.data, error: \"OUTPUT NOT FOUND\" },\n    };\n  }\n\n  logger.debug(\"agent:output\", outputRef.type, outputRef.data);\n\n  try {\n    let parsedContent = outputRef.data;\n    if (typeof parsedContent === \"string\") {\n      if (output.schema._def.typeName !== \"ZodString\") {\n        try {\n          parsedContent = JSON.parse(parsedContent.trim());\n        } catch (error) {\n          console.log(\"failed parsing output content\", {\n            content: parsedContent,\n          });\n          throw error;\n        }\n      }\n    }\n    let data: any;\n    try {\n      data = output.schema.parse(parsedContent);\n    } catch (error) {\n      console.log(\"failed parsing output schema\");\n      throw error;\n    }\n\n    const response = await output.handler(\n      data,\n      {\n        ...state,\n        workingMemory,\n      },\n      agent\n    );\n\n    if (Array.isArray(response)) {\n      const refs: OutputRef[] = [];\n      for (const res of response) {\n        const ref: OutputRef = {\n          ...outputRef,\n          id: randomUUIDv7(),\n          ...res,\n        };\n\n        ref.formatted = output.format ? output.format(response) : undefined;\n        refs.push(ref);\n      }\n      return refs;\n    } else if (response) {\n      const ref: OutputRef = {\n        ...outputRef,\n        ...response,\n      };\n\n      ref.formatted = output.format ? output.format(response) : undefined;\n\n      return ref;\n    }\n\n    return {\n      ...outputRef,\n      formatted: output.format ? output.format(data) : undefined,\n      data,\n    };\n  } catch (error) {\n    const ref: OutputRef = {\n      ...outputRef,\n      params: { error: \"true\" },\n      timestamp: Date.now(),\n      data: { content: outputRef.data, error },\n    };\n\n    logger.error(\"agent:output\", outputRef.type, error);\n\n    return ref;\n  }\n}\n","import { generateObject } from \"ai\";\nimport { openai } from \"@ai-sdk/openai\";\nimport type {\n  AnyAgent,\n  Episode,\n  ActionResult,\n  Action,\n  Thought,\n  ActionCall,\n  AnyAction,\n} from \"../types\";\nimport { z } from \"zod\";\nimport { v7 as randomUUIDv7 } from \"uuid\";\n\n// Check if we're in a browser environment\nconst isBrowser =\n  typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\n// Conditionally import Node.js modules\nlet fs: any;\nlet path: any;\n\nif (!isBrowser) {\n  // Only import in Node.js environment\n  // Using dynamic import to avoid browser errors\n  try {\n    fs = require(\"fs\");\n    path = require(\"path\");\n  } catch (e) {\n    console.warn(\"File system modules not available in this environment\");\n  }\n}\n\nexport const generateEpisodicMemory = async (\n  agent: AnyAgent,\n  thoughts: Thought[],\n  actions: Action[],\n  results: ActionResult[]\n): Promise<{\n  observation: string;\n  thoughts: string;\n  result: string;\n}> => {\n  const extractEpisode = await generateObject({\n    model: agent.memory.vectorModel || openai(\"gpt-4-turbo\"),\n    schema: z.object({\n      observation: z.string().describe(\"The context and setup - what happened\"),\n      thoughts: z\n        .string()\n        .describe(\n          \"Internal reasoning process and observations of the agent in the episode that let it arrive at the correct action and result. 'I ...'\"\n        ),\n      result: z\n        .string()\n        .describe(\n          \"Outcome and retrospective. What did you do well? What could you do better next time? I ...\"\n        ),\n    }),\n    prompt: `\n    You are creating an episodic memory for an AI agent to help it recall and learn from past experiences.\n    \n    Your task is to analyze the agent's thoughts, actions, and the results of those actions to create a structured memory that can be used for future reference and learning.\n\n    ## Context\n    <thoughts>\n    ${JSON.stringify(thoughts)}\n    </thoughts>\n\n    ## Actions Taken\n    <actions>\n    ${JSON.stringify(actions)}\n    </actions>\n\n    ## Results & Outcomes\n    <results>\n    ${JSON.stringify(results)}\n    </results>\n    \n    ## Instructions\n    Create a comprehensive episodic memory with these components:\n    \n    1. OBSERVATION: Provide a clear, concise description of the situation, context, and key elements. Include:\n       - What was the environment or scenario?\n       - What was the agent trying to accomplish?\n       - What were the initial conditions or constraints?\n    \n    2. THOUGHTS: Capture the agent's internal reasoning process that led to its actions:\n       - What was the agent's understanding of the situation?\n       - What strategies or approaches did it consider?\n       - What key insights or realizations occurred during the process?\n       - Use first-person perspective (\"I realized...\", \"I considered...\")\n    \n    3. RESULT: Summarize the outcomes and provide a retrospective analysis:\n       - What was accomplished or not accomplished?\n       - What worked well and what didn't?\n       - What lessons can be learned for future similar situations?\n       - What would be done differently next time?\n       - Use first-person perspective (\"I succeeded in...\", \"Next time I would...\")\n    \n    Make the memory detailed enough to be useful for future recall, but concise enough to be quickly processed. Focus on capturing the essence of the experience, key decision points, and lessons learned.`,\n  });\n\n  return {\n    observation: extractEpisode.object.observation,\n    thoughts: extractEpisode.object.thoughts,\n    result: extractEpisode.object.result,\n  };\n};\n\n/**\n * Creates a training data pair from episodic memory\n * @param episodicMemory The episodic memory generated\n * @returns A prompt-completion pair for training data\n */\nexport function createTrainingDataPair(episodicMemory: {\n  observation: string;\n  thoughts: string;\n  result: string;\n}): {\n  prompt: string;\n  completion: string;\n} {\n  // Create a simple prompt with the observation\n  const prompt = episodicMemory.observation;\n\n  // Create a simple completion with thoughts and result\n  const completion = `${episodicMemory.thoughts}\\n\\n${episodicMemory.result}`;\n\n  return {\n    prompt,\n    completion,\n  };\n}\n\n/**\n * Saves training data to a JSON lines file\n * @param trainingData Array of prompt-completion pairs\n * @param filePath Path to save the file\n */\nexport async function saveTrainingData(\n  trainingData: Array<{ prompt: string; completion: string }>,\n  filePath: string\n): Promise<void> {\n  // Skip in browser environment\n  if (isBrowser) {\n    console.warn(\"saveTrainingData is not supported in browser environments\");\n    return;\n  }\n\n  try {\n    // Ensure fs is available\n    if (!fs) {\n      console.warn(\"File system module not available\");\n      return;\n    }\n\n    // Ensure directory exists\n    const dir = path.dirname(filePath);\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true });\n    }\n\n    // Convert each object to a JSON string and join with newlines\n    const jsonLines = trainingData\n      .map((item) => JSON.stringify(item))\n      .join(\"\\n\");\n\n    // Write to file\n    fs.writeFileSync(filePath, jsonLines, \"utf8\");\n  } catch (error) {\n    console.error(\"Error saving training data:\", error);\n    throw error;\n  }\n}\n\n/**\n * Creates an episode from working memory components\n * @param thoughts The thoughts that led to the actions\n * @param actions The actions taken\n * @param results The results of the actions\n * @param agent The agent that generated the episode\n * @param options Optional configuration for exporting training data\n * @param options.exportTrainingData Whether to export this episode as training data\n * @param options.trainingDataPath Path to save the training data\n * @returns A new Episode object\n */\nexport async function createEpisodeFromWorkingMemory(\n  thoughts: Thought[],\n  actions: Action[],\n  results: ActionResult[],\n  agent: AnyAgent,\n  options?: {\n    exportTrainingData?: boolean;\n    trainingDataPath?: string;\n  }\n): Promise<Episode> {\n  const episodicMemory = await generateEpisodicMemory(\n    agent,\n    thoughts,\n    actions,\n    results\n  );\n\n  // If exportTrainingData is true and not in browser, create and save training data\n  if (options?.exportTrainingData && !isBrowser && fs) {\n    const trainingDataPair = createTrainingDataPair(episodicMemory);\n\n    // Default path if not provided\n    const filePath = options.trainingDataPath || \"./training-data.jsonl\";\n\n    // Check if file exists to append or create new\n    let existingData: Array<{ prompt: string; completion: string }> = [];\n    if (fs.existsSync(filePath)) {\n      const fileContent = fs.readFileSync(filePath, \"utf8\");\n      existingData = fileContent\n        .split(\"\\n\")\n        .filter((line: string) => line.trim() !== \"\")\n        .map((line: string) => JSON.parse(line));\n    }\n\n    // Add new training data pair\n    existingData.push(trainingDataPair);\n\n    // Save updated training data\n    await saveTrainingData(existingData, filePath);\n  }\n\n  return {\n    id: randomUUIDv7(),\n    timestamp: Date.now(),\n    observation: episodicMemory.observation,\n    result: episodicMemory.result,\n    thoughts: episodicMemory.thoughts,\n  };\n}\n\n/**\n * Exports all episodes as training data\n * @param episodes Array of episodes to export\n * @param filePath Path to save the training data\n */\nexport async function exportEpisodesAsTrainingData(\n  episodes: Episode[],\n  filePath: string = \"./training-data.jsonl\"\n): Promise<void> {\n  // Skip in browser environment\n  if (isBrowser) {\n    console.warn(\n      \"exportEpisodesAsTrainingData is not supported in browser environments\"\n    );\n    return;\n  }\n\n  // Ensure fs is available\n  if (!fs) {\n    console.warn(\"File system module not available\");\n    return;\n  }\n\n  const trainingData = episodes.map((episode) => ({\n    prompt: episode.observation,\n    completion: `${episode.thoughts}\\n\\n${episode.result}`,\n  }));\n\n  await saveTrainingData(trainingData, filePath);\n}\n\nexport async function generateEpisode(\n  thought: Thought,\n  actionCall: ActionCall,\n  result: ActionResult,\n  agent: AnyAgent,\n  contextId: string,\n  actions: AnyAction[]\n) {\n  // Find the corresponding Action for the ActionCall\n  const action = actions.find((a) => a.name === actionCall.name);\n\n  if (!action) {\n    return;\n  }\n\n  const thoughts = [thought];\n  const actionsArray = [action];\n  const results = [result];\n\n  const episode = await createEpisodeFromWorkingMemory(\n    thoughts,\n    actionsArray,\n    results,\n    agent,\n    {\n      exportTrainingData: agent.exportTrainingData === true,\n      trainingDataPath: agent.trainingDataPath || \"./training-data.jsonl\",\n    }\n  );\n\n  await agent.memory.vector.upsert(`${contextId}`, [\n    {\n      id: episode.id,\n      text: episode.observation,\n      metadata: episode,\n    },\n  ]);\n}\n","import { handleActionCall, handleOutput, prepareActionCall } from \"./handlers\";\nimport type { Logger } from \"./logger\";\nimport { generateEpisode } from \"./memory/utils\";\nimport type { TaskRunner } from \"./task\";\nimport type {\n  ActionCall,\n  ActionResult,\n  AnyAction,\n  AnyAgent,\n  AnyContext,\n  ContextState,\n  Handlers,\n  Log,\n  Output,\n  OutputRef,\n  WorkingMemory,\n} from \"./types\";\nimport { randomUUIDv7 } from \"./utils\";\nimport { xmlStreamParser } from \"./xml\";\n\ntype PartialLog = Partial<Log> &\n  Pick<Log, \"ref\" | \"id\" | \"timestamp\" | \"processed\">;\n\ntype AsyncIterableStream<T> = AsyncIterable<T> & ReadableStream<T>;\n\nexport type StackElement = {\n  index: number;\n  tag: string;\n  attributes: Record<string, any>;\n  content: string[];\n  done: boolean;\n};\n\nexport async function handleStream(\n  textStream: AsyncGenerator<string>,\n  initialIndex: number,\n  fn: (el: StackElement) => void,\n  tags: Set<string>\n) {\n  const parser = xmlStreamParser(tags);\n\n  parser.next();\n\n  let current: StackElement | undefined = undefined;\n  let stack: StackElement[] = [];\n\n  let index = initialIndex;\n\n  function handleChunk(chunk: string) {\n    let result = parser.next(chunk);\n    while (!result.done && result.value) {\n      if (result.value.type === \"start\") {\n        if (current) stack.push(current);\n        current = {\n          index: index++,\n          tag: result.value.name,\n          attributes: result.value.attributes,\n          content: [],\n          done: false,\n        };\n        fn(current);\n      }\n\n      if (result.value.type === \"end\") {\n        if (current)\n          fn({\n            ...current,\n            done: true,\n          });\n        current = stack.pop();\n      }\n\n      if (result.value.type === \"text\") {\n        if (current) {\n          current.content.push(result.value.content);\n          fn(current);\n        }\n      }\n      result = parser.next();\n    }\n  }\n\n  for await (const chunk of textStream) {\n    handleChunk(chunk);\n  }\n\n  parser.return?.();\n}\n\nexport async function* wrapStream(\n  stream: AsyncIterable<string>,\n  prefix: string,\n  suffix: string\n) {\n  yield prefix;\n  for await (const value of stream) {\n    yield value;\n  }\n  yield suffix;\n}\n\nconst defaultTags = new Set([\n  \"think\",\n  \"response\",\n  \"output\",\n  \"action_call\",\n  \"reasoning\",\n]);\n\nexport function createContextStreamHandler({\n  agent,\n  chain,\n  ctxState,\n  agentCtxState,\n  logger,\n  handlers,\n  taskRunner,\n  outputs,\n  actions,\n  actionCalls,\n  workingMemory,\n  abortSignal,\n}: {\n  agent: AnyAgent;\n  taskRunner: TaskRunner;\n  ctxState: ContextState<AnyContext>;\n  agentCtxState?: ContextState<AnyContext>;\n  chain: Log[];\n  logger: Logger;\n  handlers?: Partial<Handlers>;\n  outputs: Output[];\n  actions: AnyAction[];\n  actionCalls: Promise<any>[];\n  workingMemory: WorkingMemory;\n  abortSignal?: AbortSignal;\n}) {\n  const state = {\n    index: 0,\n    logsByIndex: new Map<number, PartialLog>(),\n  };\n\n  function getOrCreateRef<\n    TLog extends Omit<PartialLog, \"id\" | \"timestamp\" | \"processed\">,\n  >(\n    index: number,\n    ref: TLog\n  ): TLog & Pick<PartialLog, \"id\" | \"timestamp\" | \"processed\"> {\n    if (!state.logsByIndex.has(index)) {\n      state.logsByIndex.set(index, {\n        id: randomUUIDv7(),\n        timestamp: Date.now(),\n        processed: false,\n        ...ref,\n      });\n    }\n\n    return state.logsByIndex.get(index)! as TLog &\n      Pick<PartialLog, \"id\" | \"timestamp\" | \"processed\">;\n  }\n\n  async function pushLogStream(log: Log, done: boolean) {\n    if (done) chain.push(log);\n\n    if (log.ref === \"thought\" && done) {\n      workingMemory.thoughts.push(log);\n      logger.debug(\"agent:think\", \"thought\", log.content);\n      handlers?.onThinking?.(log);\n    }\n\n    if (log.ref === \"action_call\" && done) {\n      workingMemory.calls.push(log);\n    }\n\n    if (log.ref === \"action_result\" && done) {\n      workingMemory.results.push(log);\n\n      // Find the most recent thought and action call\n      const lastThought =\n        workingMemory.thoughts[workingMemory.thoughts.length - 1];\n      const lastActionCall =\n        workingMemory.calls[workingMemory.calls.length - 1];\n\n      // If we have a complete thought-action-result cycle, generate an episode\n      if (lastThought && lastActionCall && agent.memory.generateMemories) {\n        // Generate episode with the last thought, action call, and result\n        generateEpisode(\n          lastThought,\n          lastActionCall,\n          log,\n          agent,\n          ctxState.id,\n          actions\n        ).catch((error) => {\n          logger.error(\n            \"agent:generateEpisode\",\n            \"Failed to generate episode\",\n            error\n          );\n        });\n      }\n    }\n\n    handlers?.onLogStream?.(log, done);\n  }\n\n  async function handleActionCallStream(call: ActionCall, done: boolean) {\n    if (!done) {\n      return pushLogStream(call, false);\n    }\n\n    // todo: handle errors\n    const { action } = await prepareActionCall({\n      call,\n      actions,\n      logger,\n    });\n\n    if (abortSignal?.aborted) return;\n\n    pushLogStream(call, true);\n\n    actionCalls.push(\n      handleActionCall({\n        call,\n        action,\n        agent,\n        logger,\n        state: ctxState,\n        taskRunner,\n        workingMemory,\n        agentState: agentCtxState,\n        abortSignal,\n      })\n        .catch((err) => {\n          const result: ActionResult = {\n            ref: \"action_result\",\n            id: randomUUIDv7(),\n            callId: call.id,\n            data: { error: JSON.stringify(err) },\n            name: call.name,\n            timestamp: Date.now(),\n            processed: false,\n          };\n\n          return result;\n        })\n        .then((res) => {\n          pushLogStream(res, true);\n          return res;\n        })\n    );\n  }\n\n  async function handleOutputStream(outputRef: OutputRef, done: boolean) {\n    if (!done) {\n      return pushLogStream(outputRef, false);\n    }\n\n    const refs = await handleOutput({\n      agent,\n      logger,\n      state: ctxState,\n      workingMemory,\n      outputs,\n      outputRef,\n    });\n\n    for (const ref of Array.isArray(refs) ? refs : [refs]) {\n      logger.debug(\"agent:output\", \"Output processed status\", {\n        type: ref.type,\n        processed: ref.processed,\n      });\n\n      workingMemory.outputs.push(ref);\n      pushLogStream(ref, true);\n    }\n  }\n\n  async function handler(el: StackElement) {\n    if (abortSignal?.aborted) return;\n\n    state.index = Math.max(el.index, state.index);\n\n    switch (el.tag) {\n      case \"think\":\n      case \"reasoning\": {\n        const ref = getOrCreateRef(el.index, {\n          ref: \"thought\",\n        });\n\n        pushLogStream(\n          {\n            ...ref,\n            content: el.content.join(\"\"),\n          },\n          el.done\n        );\n\n        break;\n      }\n\n      case \"action_call\": {\n        const ref = getOrCreateRef(el.index, {\n          ref: \"action_call\",\n        });\n\n        handleActionCallStream(\n          {\n            ...ref,\n            name: el.attributes.name,\n            content: el.content.join(\"\"),\n            data: undefined,\n          },\n          el.done\n        );\n\n        break;\n      }\n\n      case \"output\": {\n        const ref = getOrCreateRef(el.index, {\n          ref: \"output\",\n        });\n\n        // Check if the type attribute exists\n        if (!el.attributes.type) {\n          logger.error(\"agent:output\", \"Missing output type attribute\", {\n            content: el.content.join(\"\"),\n            attributes: el.attributes,\n          });\n          break;\n        }\n\n        handleOutputStream(\n          {\n            ...ref,\n            type: el.attributes.type,\n            data: el.content.join(\"\").trim(),\n          },\n          el.done\n        );\n\n        break;\n      }\n\n      default:\n        break;\n    }\n  }\n\n  return {\n    state,\n    handler,\n    tags: defaultTags,\n  };\n}\n","import {\n  LogLevel,\n  type Agent,\n  type AnyContext,\n  type Config,\n  type Debugger,\n  type Log,\n  type Output,\n  type Subscription,\n} from \"./types\";\nimport { Logger } from \"./logger\";\nimport createContainer from \"./container\";\nimport { createServiceManager } from \"./serviceProvider\";\nimport { TaskRunner } from \"./task\";\nimport {\n  getContextId,\n  getContextState,\n  getContextWorkingMemory,\n  getWorkingMemoryLogs,\n  saveContextWorkingMemory,\n} from \"./context\";\nimport { createMemoryStore } from \"./memory\";\nimport { createMemory } from \"./memory\";\nimport { createVectorStore } from \"./memory/base\";\nimport { runGenerate, runGenerateResults } from \"./tasks\";\nimport { exportEpisodesAsTrainingData } from \"./memory/utils\";\nimport type { Episode, Memory } from \"./types\";\nimport { randomUUIDv7 } from \"./utils\";\nimport { createContextStreamHandler, handleStream } from \"./streaming\";\n\nexport function createDreams<TContext extends AnyContext = AnyContext>(\n  config: Config<TContext>\n): Agent<TContext> {\n  let booted = false;\n\n  const inputSubscriptions = new Map<string, Subscription>();\n  const contexts = new Map<string, { type: string; args?: any }>();\n  const contextsRunning = new Set<string>();\n\n  const {\n    inputs = {},\n    outputs = {},\n    events = {},\n    actions = [],\n    experts = {},\n    services = [],\n    extensions = [],\n    model,\n    reasoningModel,\n    exportTrainingData,\n    trainingDataPath,\n  } = config;\n\n  const container = config.container ?? createContainer();\n\n  const taskRunner = config.taskRunner ?? new TaskRunner(3);\n\n  const logger = new Logger({\n    level: config.logger ?? LogLevel.INFO,\n    enableTimestamp: true,\n    enableColors: true,\n  });\n\n  container.instance(\"logger\", logger);\n\n  logger.debug(\"dreams\", \"Creating agent\", {\n    hasModel: !!model,\n    hasReasoningModel: !!reasoningModel,\n    inputsCount: Object.keys(inputs).length,\n    outputsCount: Object.keys(outputs).length,\n    actionsCount: actions.length,\n    servicesCount: services.length,\n    extensionsCount: extensions.length,\n  });\n\n  const debug: Debugger = (...args) => {\n    if (!config.debugger) return;\n    try {\n      config.debugger(...args);\n    } catch {\n      console.log(\"debugger failed\");\n    }\n  };\n\n  const serviceManager = createServiceManager(container);\n\n  for (const service of services) {\n    serviceManager.register(service);\n  }\n\n  for (const extension of extensions) {\n    if (extension.inputs) Object.assign(inputs, extension.inputs);\n    if (extension.outputs) Object.assign(outputs, extension.outputs);\n    if (extension.events) Object.assign(events, extension.events);\n    if (extension.actions) actions.push(...extension.actions);\n    if (extension.services) {\n      for (const service of extension.services) {\n        serviceManager.register(service);\n      }\n    }\n  }\n\n  const agent: Agent<TContext> = {\n    inputs,\n    outputs,\n    events,\n    actions,\n    experts,\n    memory:\n      config.memory ?? createMemory(createMemoryStore(), createVectorStore()),\n    container,\n    model,\n    reasoningModel,\n    taskRunner,\n    debugger: debug,\n    context: config.context ?? undefined,\n    exportTrainingData,\n    trainingDataPath,\n    emit: (event: string, data: any) => {\n      logger.debug(\"agent:event\", event, data);\n    },\n\n    async getContexts() {\n      return Array.from(contexts.entries()).map(([id, { type, args }]) => ({\n        id,\n        type,\n        args,\n      }));\n    },\n\n    getContext(params) {\n      logger.trace(\"agent:getContext\", \"Getting context state\", params);\n      return getContextState(agent, params.context, params.args);\n    },\n\n    getContextId(params) {\n      logger.trace(\"agent:getContextId\", \"Getting context id\", params);\n      return getContextId(params.context, params.args);\n    },\n\n    getWorkingMemory(contextId) {\n      logger.trace(\"agent:getWorkingMemory\", \"Getting working memory\", {\n        contextId,\n      });\n      return getContextWorkingMemory(agent, contextId);\n    },\n\n    async start(args) {\n      logger.info(\"agent:start\", \"Starting agent\", { args, booted });\n      if (booted) return agent;\n\n      booted = true;\n\n      logger.debug(\"agent:start\", \"Booting services\");\n      await serviceManager.bootAll();\n\n      logger.debug(\"agent:start\", \"Installing extensions\", {\n        count: extensions.length,\n      });\n\n      for (const extension of extensions) {\n        if (extension.install) await extension.install(agent);\n      }\n\n      logger.debug(\"agent:start\", \"Setting up inputs\", {\n        count: Object.keys(agent.inputs).length,\n      });\n\n      for (const [type, input] of Object.entries(agent.inputs)) {\n        if (input.install) {\n          logger.trace(\"agent:start\", \"Installing input\", { type });\n          await Promise.resolve(input.install(agent));\n        }\n\n        if (input.subscribe) {\n          logger.trace(\"agent:start\", \"Subscribing to input\", { type });\n          let subscription = input.subscribe((context, args, data) => {\n            logger.debug(\"agent\", \"input\", { context, args, data });\n            agent\n              .send({\n                context,\n                input: { type, data },\n                args,\n              })\n              .catch((err) => {\n                logger.error(\"agent:input\", \"error\", err);\n              });\n          }, agent);\n\n          if (typeof subscription === \"object\") {\n            subscription = await Promise.resolve(subscription);\n          }\n\n          if (subscription) inputSubscriptions.set(type, subscription);\n        }\n      }\n\n      logger.debug(\"agent:start\", \"Setting up outputs\", {\n        count: Object.keys(outputs).length,\n      });\n      for (const [type, output] of Object.entries(outputs)) {\n        if (output.install) {\n          logger.trace(\"agent:start\", \"Installing output\", { type });\n          await Promise.resolve(output.install(agent));\n        }\n      }\n\n      logger.debug(\"agent:start\", \"Setting up actions\", {\n        count: actions.length,\n      });\n\n      for (const action of actions) {\n        if (action.install) {\n          logger.trace(\"agent:start\", \"Installing action\", {\n            name: action.name,\n          });\n          await Promise.resolve(action.install(agent));\n        }\n      }\n\n      if (agent.context) {\n        logger.debug(\"agent:start\", \"Setting up agent context\", {\n          type: agent.context.type,\n        });\n        const { id } = await getContextState(agent, agent.context, args);\n        contexts.set(id, { type: agent.context.type, args });\n        contexts.set(\"agent:context\", { type: agent.context.type, args });\n      }\n\n      logger.debug(\"agent:start\", \"Loading saved contexts\");\n      const savedContexts =\n        await agent.memory.store.get<[string, { type: string; args?: any }][]>(\n          \"contexts\"\n        );\n\n      if (savedContexts) {\n        logger.trace(\"agent:start\", \"Restoring saved contexts\", {\n          count: savedContexts.length,\n        });\n        for (const [id, { type, args }] of savedContexts) {\n          contexts.set(id, { type, args });\n        }\n      }\n\n      logger.info(\"agent:start\", \"Agent started successfully\");\n      return agent;\n    },\n\n    async stop() {\n      logger.info(\"agent:stop\", \"Stopping agent\");\n    },\n\n    run: async ({ context, args, outputs, handlers, abortSignal, model }) => {\n      if (!booted) {\n        logger.error(\"agent:run\", \"Agent not booted\");\n        throw new Error(\"Not booted\");\n      }\n\n      logger.info(\"agent:run\", \"Running context\", {\n        contextType: context.type,\n        hasArgs: !!args,\n        hasCustomOutputs: !!outputs,\n        hasHandlers: !!handlers,\n      });\n\n      const ctxState = await getContextState(agent, context, args);\n      logger.debug(\"agent:run\", \"Context state retrieved\", { id: ctxState.id });\n\n      contexts.set(ctxState.id, { type: context.type, args });\n\n      await agent.memory.store.set<[string, { args?: any }][]>(\n        \"contexts\",\n        Array.from(contexts.entries())\n      );\n\n      if (contextsRunning.has(ctxState.id)) {\n        logger.debug(\"agent:run\", \"Context already running\", {\n          id: ctxState.id,\n        });\n        return [];\n      }\n\n      contextsRunning.add(ctxState.id);\n      logger.debug(\"agent:run\", \"Added context to running set\", {\n        id: ctxState.id,\n      });\n\n      const workingMemory = await getContextWorkingMemory(agent, ctxState.id);\n\n      logger.trace(\"agent:run\", \"Working memory retrieved\", {\n        id: ctxState.id,\n        inputsCount: workingMemory.inputs.length,\n        outputsCount: workingMemory.outputs.length,\n        thoughtsCount: workingMemory.thoughts.length,\n      });\n\n      const contextOuputs: Output[] = Object.entries({\n        ...agent.outputs,\n        ...(outputs ?? {}),\n      })\n        .filter(([_, output]) =>\n          output.enabled\n            ? output.enabled({\n                ...ctxState,\n                context,\n                workingMemory,\n              })\n            : true\n        )\n        .map(([type, output]) => ({\n          type,\n          ...output,\n        }));\n\n      logger.debug(\"agent:run\", \"Enabled outputs\", {\n        count: contextOuputs.length,\n      });\n\n      const agentCtxState = agent.context\n        ? await getContextState(\n            agent,\n            agent.context,\n            contexts.get(\"agent:context\")!.args\n          )\n        : undefined;\n\n      logger.debug(\"agent:run\", \"Preparing actions\");\n\n      const contextActions = await Promise.all(\n        actions.map(async (action) => {\n          if (action.context && action.context.type !== context.type)\n            return undefined;\n\n          let actionMemory: Memory | undefined = undefined;\n\n          if (action.memory) {\n            actionMemory =\n              (await agent.memory.store.get(action.memory.key)) ??\n              action.memory.create();\n          }\n\n          const enabled = action.enabled\n            ? action.enabled({\n                ...ctxState,\n                context,\n                workingMemory,\n                actionMemory,\n                agentMemory: agentCtxState?.memory,\n              })\n            : true;\n\n          return enabled ? action : undefined;\n        })\n      ).then((r) => r.filter((a) => !!a));\n\n      logger.debug(\"agent:run\", \"Enabled actions\", {\n        count: contextActions.length,\n      });\n\n      logger.debug(\"agent:run\", \"Agent context state\", {\n        hasAgentContext: !!agentCtxState,\n        id: agentCtxState?.id,\n      });\n\n      const chain: Log[] = [];\n\n      let hasError = false;\n      let actionCalls: Promise<any>[] = [];\n\n      const { state, handler, tags } = createContextStreamHandler({\n        agent,\n        chain,\n        actions: contextActions,\n        actionCalls,\n        agentCtxState,\n        ctxState,\n        handlers,\n        logger,\n        outputs: contextOuputs,\n        taskRunner,\n        workingMemory,\n        abortSignal,\n      });\n\n      let step = 1;\n      const maxSteps = context.maxSteps ?? 5;\n\n      while (maxSteps > step) {\n        logger.info(\"agent:run\", `Starting step ${step}/${maxSteps}`, {\n          contextId: ctxState.id,\n        });\n\n        try {\n          const { stream, response } = await taskRunner.enqueueTask(\n            step > 1 ? runGenerateResults : runGenerate,\n            {\n              agent,\n              model:\n                model ?? context.model ?? config.reasoningModel ?? config.model,\n              contexts: [agentCtxState, ctxState].filter((t) => !!t),\n              contextId: ctxState.id,\n              actions: contextActions,\n              outputs: contextOuputs,\n              workingMemory,\n              logger,\n              chain,\n              abortSignal,\n            },\n            {\n              debug: agent.debugger,\n            }\n          );\n\n          logger.debug(\"agent:run\", \"Processing stream\", { step });\n\n          await handleStream(stream, state.index, handler, tags);\n\n          state.index++;\n\n          logger.debug(\"agent:run\", \"Waiting for action calls to complete\", {\n            pendingCalls: actionCalls.length,\n          });\n\n          await Promise.allSettled(actionCalls);\n\n          actionCalls.length = 0;\n\n          logger.debug(\"agent:run\", \"Saving context state\", {\n            id: ctxState.id,\n          });\n\n          await agent.memory.store.set(ctxState.id, ctxState.memory);\n\n          if (agentCtxState) {\n            logger.debug(\"agent:run\", \"Saving agent context state\", {\n              id: agentCtxState.id,\n            });\n\n            await agent.memory.store.set(\n              agentCtxState.id,\n              agentCtxState.memory\n            );\n          }\n\n          logger.debug(\"agent:run\", \"Saving working memory\", {\n            id: ctxState.id,\n            workingMemory,\n          });\n\n          step++;\n\n          if (context.onStep) {\n            await context.onStep({\n              ...ctxState,\n              workingMemory,\n            });\n          }\n\n          if (hasError) {\n            logger.warn(\"agent:run\", \"Continuing despite error\", { step });\n            continue;\n          }\n\n          await saveContextWorkingMemory(agent, ctxState.id, workingMemory);\n\n          const pendingResults = workingMemory.results.filter(\n            (i) => i.processed === false\n          );\n\n          if (pendingResults.length === 0 || abortSignal?.aborted) break;\n        } catch (error) {\n          console.error(error);\n          break;\n        }\n      }\n\n      logger.debug(\"agent:run\", \"Marking all working memory as processed\");\n\n      getWorkingMemoryLogs(workingMemory).forEach((i) => {\n        i.processed = true;\n      });\n\n      logger.debug(\"agent:run\", \"Removing context from running set\", {\n        id: ctxState.id,\n      });\n\n      contextsRunning.delete(ctxState.id);\n\n      logger.info(\"agent:run\", \"Run completed\", {\n        contextId: ctxState.id,\n        chainLength: chain.length,\n      });\n\n      return chain;\n    },\n\n    send: async (params) => {\n      logger.info(\"agent:send\", \"Sending input\", {\n        inputType: params.input.type,\n        contextType: params.context.type,\n      });\n\n      if (params.input.type in agent.inputs === false) {\n        logger.error(\"agent:send\", \"Invalid input type\", {\n          type: params.input.type,\n        });\n        throw new Error(\"invalid input\");\n      }\n\n      const args = params.context.schema.parse(params.args);\n\n      const {\n        key,\n        id: contextId,\n        options,\n        memory,\n      } = await getContextState(agent, params.context, args);\n\n      logger.debug(\"agent:send\", \"Context state retrieved\", {\n        id: contextId,\n        key,\n      });\n\n      const workingMemory = await getContextWorkingMemory(agent, contextId);\n\n      logger.trace(\"agent:send\", \"Working memory retrieved\", {\n        id: contextId,\n        inputsCount: workingMemory.inputs.length,\n      });\n\n      const input = agent.inputs[params.input.type];\n      const data = input.schema.parse(params.input.data);\n\n      logger.debug(\"agent:send\", \"Input data parsed\", {\n        type: params.input.type,\n      });\n\n      logger.debug(\"agent:send\", \"Querying episodic memory\");\n\n      const episodicMemory = await agent.memory.vector.query(\n        `${contextId}`,\n        JSON.stringify(data)\n      );\n\n      logger.trace(\"agent:send\", \"Episodic memory retrieved\", {\n        episodesCount: episodicMemory.length,\n      });\n\n      workingMemory.episodicMemory = {\n        episodes: episodicMemory,\n      };\n\n      if (input.handler) {\n        logger.debug(\"agent:send\", \"Using custom input handler\", {\n          type: params.input.type,\n        });\n\n        await input.handler(\n          data,\n          {\n            id: contextId,\n            context: params.context,\n            args,\n            type: params.context.type,\n            key,\n            memory,\n            workingMemory,\n            options,\n          },\n          agent\n        );\n      } else {\n        logger.debug(\"agent:send\", \"Adding input to working memory\", {\n          type: params.context.type,\n        });\n\n        workingMemory.inputs.push({\n          id: randomUUIDv7(),\n          ref: \"input\",\n          type: params.context.type,\n          data,\n          timestamp: Date.now(),\n          formatted: input.format ? input.format(data) : undefined,\n          processed: false,\n        });\n      }\n\n      logger.debug(\"agent:send\", \"Running evaluator\");\n      await agent.evaluator({\n        type: params.context.type,\n        key,\n        memory,\n        options,\n      } as any);\n\n      logger.debug(\"agent:send\", \"Saving context memory\", { id: contextId });\n      await agent.memory.store.set(contextId, memory);\n\n      logger.debug(\"agent:send\", \"Saving working memory\");\n      await saveContextWorkingMemory(agent, contextId, workingMemory);\n\n      logger.debug(\"agent:send\", \"Running run method\");\n      return await agent.run(params);\n    },\n\n    evaluator: async (ctx) => {\n      const { id, memory } = ctx;\n      logger.debug(\"agent:evaluator\", \"memory\", memory);\n    },\n\n    /**\n     * Exports all episodes as training data\n     * @param filePath Optional path to save the training data\n     */\n    async exportAllTrainingData(filePath?: string) {\n      logger.info(\n        \"agent:exportTrainingData\",\n        \"Exporting episodes as training data\"\n      );\n\n      // Get all contexts\n      const contexts = await agent.getContexts();\n\n      // Collect all episodes from all contexts\n      const allEpisodes: Episode[] = [];\n\n      for (const { id } of contexts) {\n        const episodes = await agent.memory.vector.query(id, \"\");\n        if (episodes.length > 0) {\n          allEpisodes.push(...episodes);\n        }\n      }\n\n      logger.info(\n        \"agent:exportTrainingData\",\n        `Found ${allEpisodes.length} episodes to export`\n      );\n\n      // Export episodes as training data\n      if (allEpisodes.length > 0) {\n        await exportEpisodesAsTrainingData(\n          allEpisodes,\n          filePath || agent.trainingDataPath || \"./training-data.jsonl\"\n        );\n        logger.info(\n          \"agent:exportTrainingData\",\n          \"Episodes exported successfully\"\n        );\n      } else {\n        logger.warn(\"agent:exportTrainingData\", \"No episodes found to export\");\n      }\n    },\n  };\n\n  container.instance(\"agent\", agent);\n\n  return agent;\n}\n","/**\n * A generic response shape for GraphQL queries.\n */\ninterface GraphQLResponse<T> {\n  data?: T;\n  errors?: Array<{\n    message: string;\n    locations?: Array<{\n      line: number;\n      column: number;\n    }>;\n    path?: string[];\n  }>;\n}\n\n/**\n * A generalized error type for convenience.\n */\nclass ApiError extends Error {\n  constructor(\n    public message: string,\n    public details?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * A helper function to perform generic REST requests.\n * - `url`: full endpoint (including protocol, domain, path)\n * - `options`: standard `fetch` options such as method, headers, body, etc.\n */\nexport async function fetchRest<ResponseType = unknown>(\n  url: string,\n  options: RequestInit = {}\n): Promise<ResponseType> {\n  try {\n    const res = await fetch(url, options);\n    if (!res.ok) {\n      throw new ApiError(`HTTP Error: ${res.status} ${res.statusText}`, {\n        status: res.status,\n        statusText: res.statusText,\n      });\n    }\n    return (await res.json()) as ResponseType;\n  } catch (error) {\n    throw error instanceof ApiError\n      ? error\n      : new ApiError(\"Unknown error during REST fetch\", error);\n  }\n}\n\n/**\n * A helper function to perform GraphQL queries.\n * - `endpoint`: the GraphQL endpoint URL.\n * - `query`: the GraphQL query string.\n * - `variables`: an optional variables object for the query.\n */\nexport async function fetchGraphQL<DataType = unknown>(\n  endpoint: string,\n  query: string,\n  variables?: Record<string, unknown>\n): Promise<DataType | Error> {\n  try {\n    const res = await fetch(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        query,\n        variables,\n      }),\n    });\n\n    if (!res.ok) {\n      throw new ApiError(`HTTP Error: ${res.status} ${res.statusText}`, {\n        status: res.status,\n        statusText: res.statusText,\n      });\n    }\n\n    const result = (await res.json()) as GraphQLResponse<DataType>;\n\n    if (result.errors && result.errors.length > 0) {\n      return new ApiError(result.errors[0].message, result.errors);\n    }\n\n    if (!result.data) {\n      return new ApiError(\"No data returned from GraphQL query\");\n    }\n\n    return result.data;\n  } catch (error) {\n    return error instanceof ApiError\n      ? error\n      : new ApiError(\"Unknown error during GraphQL fetch\", error);\n  }\n}\n"],"mappings":"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","names":["createContainer","instances","factories","singletons","aliases","getTokenString","token","resolveToken","container","factory","value","aliasToken","originalToken","resolvedToken","container_default","randomUUIDv7","TaskRunner","concurrency","a","b","task","result","error","taskFn","priority","resolve","reject","queuedTask","params","options","key","fn","defaultOptions","execute","callId","mergedOptions","createMemory","store","vector","vectorModel","getOrCreateConversationMemory","memory","conversationId","data","createMemoryStore","key","value","createVectorStore","contextId","query","indexName","smoothStream","streamText","zodToJsonSchema","getZodJsonSchema","schema","zodToJsonSchema","createPrompt","prompt","formatter","data","customFormatter","render","createParser","getOutput","visitors","content","validTags","line","match","tagName","state","parse","node","promptTemplate","prompt","createPrompt","outputs","actions","updates","context","formatOutputInterface","formatAction","parse","createParser","state","element","data","error","_error","resultsTemplate","resultsPrompt","logs","results","i","formatContextLog","ActionNotFoundError","call","ParsingError","parsingError","prepareActionCall","actions","logger","action","data","error","handleActionCall","state","workingMemory","taskRunner","agent","agentState","abortSignal","actionMemory","resultData","runAction","result","v7","handleOutput","outputRef","outputs","output","o","parsedContent","response","refs","res","ref","generateObject","openai","z","randomUUIDv7","isBrowser","fs","path","generateEpisodicMemory","agent","thoughts","actions","results","extractEpisode","createTrainingDataPair","episodicMemory","prompt","completion","saveTrainingData","trainingData","filePath","dir","jsonLines","item","error","createEpisodeFromWorkingMemory","options","trainingDataPair","existingData","line","exportEpisodesAsTrainingData","episodes","episode","generateEpisode","thought","actionCall","result","contextId","action","a","handleStream","textStream","initialIndex","fn","tags","parser","xmlStreamParser","current","stack","index","handleChunk","chunk","result","wrapStream","stream","prefix","suffix","value","defaultTags","createContextStreamHandler","agent","chain","ctxState","agentCtxState","logger","handlers","taskRunner","outputs","actions","actionCalls","workingMemory","abortSignal","state","getOrCreateRef","ref","v7","pushLogStream","log","done","lastThought","lastActionCall","generateEpisode","error","handleActionCallStream","call","action","prepareActionCall","handleActionCall","err","res","handleOutputStream","outputRef","refs","handleOutput","handler","el","customModelsConfig","prepareStreamResponse","model","stream","logger","contextId","step","callId","debug","prefix","suffix","resolve","reject","result","text","parse","error","wrapStream","runGenerate","task","contexts","workingMemory","outputs","actions","abortSignal","mainContext","ctx","system","prompt","formatContexts","formatContext","renderWorkingMemory","messages","streamText","smoothStream","runGenerateResults","chain","resultsPrompt","i","getWorkingMemoryLogs","runAction","action","call","agent","createDreams","config","booted","inputSubscriptions","contexts","contextsRunning","inputs","outputs","events","actions","experts","services","extensions","model","reasoningModel","exportTrainingData","trainingDataPath","container","container_default","taskRunner","TaskRunner","logger","Logger","debug","args","serviceManager","createServiceManager","service","extension","agent","createMemory","createMemoryStore","createVectorStore","event","data","id","type","params","getContextState","getContextId","contextId","getContextWorkingMemory","input","subscription","context","err","output","action","savedContexts","handlers","abortSignal","ctxState","workingMemory","contextOuputs","_","agentCtxState","contextActions","actionMemory","r","a","chain","hasError","actionCalls","state","handler","tags","createContextStreamHandler","step","maxSteps","stream","response","runGenerateResults","runGenerate","t","handleStream","saveContextWorkingMemory","i","error","getWorkingMemoryLogs","key","options","memory","episodicMemory","v7","ctx","filePath","allEpisodes","episodes","exportEpisodesAsTrainingData","ApiError","message","details","fetchGraphQL","endpoint","query","variables","res","ApiError","result","error"]}