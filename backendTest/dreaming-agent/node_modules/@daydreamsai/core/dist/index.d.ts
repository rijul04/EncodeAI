import { A as AnyContext, C as Config, a as Agent, T as TemplateVariables, b as AnyAgent, I as InputConfig, M as Memory, c as Action, O as OutputSchema, d as AgentContext, e as OutputResponse, f as OutputConfig, E as ExpertConfig, g as Extension, W as WorkingMemory, X as XMLElement, L as LoggerConfig, h as InputRef, i as OutputRef, j as Output, k as Log, l as ContextState, m as Context, n as ActionCall, o as AnyAction, p as TaskRunner, q as ActionResult } from './types-s9XV-UEy.js';
export { y as ActionContext, a5 as BaseMemory, F as COTProps, G as COTResponse, s as Chain, ae as Container, N as Debugger, a3 as Episode, a4 as EpisodicMemory, x as Evaluator, J as Expert, H as ExtractTemplateVariables, a2 as HandlerRole, K as Handlers, _ as IChain, v as InferAgentContext, w as InferAgentMemory, a0 as InferContextMemory, a1 as InferContextOptions, r as InferMemoryData, u as InferSchema, B as Input, $ as Instruction, U as LogEntry, Q as LogLevel, R as LogWriter, t as MemoryStore, z as OutputRefResponse, P as Pretty, Z as ResearchConfig, Y as ResearchResult, aj as ServiceManager, ai as ServiceProvider, S as Subscription, ac as Task, ab as TaskContext, aa as TaskOptions, D as Thought, V as VectorStore, af as createContainer, a6 as createMemory, a8 as createMemoryStore, ag as createServiceManager, a9 as createVectorStore, a7 as getOrCreateConversationMemory, ah as service, ad as task } from './types-s9XV-UEy.js';
import { z, ZodType } from 'zod';
import * as zod_to_json_schema from 'zod-to-json-schema';
export { v7 as randomUUIDv7 } from 'uuid';
import 'ai';

declare function createDreams<TContext extends AnyContext = AnyContext>(config: Config<TContext>): Agent<TContext>;

/**
 * Renders a template string by replacing variables with provided values
 * @template Template - The template string type containing variables in {{var}} format
 * @param str - The template string to render
 * @param data - Object containing values for template variables
 * @returns The rendered string with variables replaced
 */
declare function render<Template extends string>(str: Template, data: TemplateVariables<Template>): string;
/**
 * Formats a value for template rendering
 * @param value - The value to format
 * @returns Formatted string representation of the value
 */
declare function formatValue(value: any): string;
/**
 * Creates an input configuration
 * @template Schema - Zod schema type for input validation
 * @template Context - Context type for input handling
 * @param config - Input configuration object
 * @returns Typed input configuration
 */
declare function input<Schema extends z.AnyZodObject = z.AnyZodObject, TAgent extends AnyAgent = AnyAgent>(config: InputConfig<Schema, TAgent>): InputConfig<Schema, TAgent>;
/**
 * Creates an action configuration
 * @template Schema - Zod schema type for action parameters
 * @template Result - Return type of the action
 * @template Context - Context type for action execution
 * @param action - Action configuration object
 * @returns Typed action configuration
 */
declare function action<Schema extends z.AnyZodObject = z.AnyZodObject, Result = any, TContext extends AnyContext = AnyContext, TAgent extends AnyAgent = AnyAgent, TMemory extends Memory<any> = Memory<any>>(action: Action<Schema, Result, TContext, TAgent, TMemory>): Action<Schema, Result, TContext, TAgent, TMemory>;
/**
 * Creates an output configuration
 * @template Schema - Zod schema type for output validation
 * @template Context - Context type for output handling
 * @param config - Output configuration object
 * @returns Typed output configuration
 */
declare function output<Schema extends OutputSchema = OutputSchema, Context extends AgentContext<any> = AgentContext<any>, TResponse extends OutputResponse = OutputResponse>(config: OutputConfig<Schema, Context, TResponse>): OutputConfig<Schema, Context, TResponse>;
/**
 * Creates an expert configuration
 * @template Context - Context type for expert execution
 * @param config - Expert configuration object
 * @returns Typed expert configuration
 */
declare function expert(config: ExpertConfig): ExpertConfig;
/**
 * Options for text chunking
 */
type ChunkOptions = {
    maxChunkSize: number;
};
/**
 * Splits text into chunks based on maximum chunk size
 * @param text - The text to split into chunks
 * @param options - Chunking options including maximum chunk size
 * @returns Array of text chunks
 */
declare function splitTextIntoChunks(text: string, options: ChunkOptions): string[];
/**
 * Creates a memory configuration
 * @template Data - Type of data stored in memory
 * @param memory - Memory configuration object
 * @returns Typed memory configuration
 */
declare function memory<Data = any>(memory: Memory<Data>): Memory<Data>;
declare function extension<Contexts extends Record<string, AnyContext> = Record<string, AnyContext>>(config: Extension<AnyContext, Contexts>): Extension<AnyContext, Contexts>;
/**
 * Validates environment variables against a Zod schema
 * @param schema The Zod schema to validate against
 * @param env The environment object to validate (defaults to process.env)
 * @returns The validated environment variables
 */
declare function validateEnv<T extends z.ZodTypeAny>(schema: T, env?: NodeJS.ProcessEnv): z.infer<T>;
type TrimWorkingMemoryOptions = {
    thoughts: number;
    inputs: number;
    outputs: number;
    actions: number;
};
declare function trimWorkingMemory(workingMemory: WorkingMemory, options?: TrimWorkingMemoryOptions): void;

/**
 * Formats an XML element into a string representation
 * @param tag - The XML tag name
 * @param params - Optional parameters/attributes for the XML tag
 * @param content - The content of the XML element (string or nested elements)
 * @returns Formatted XML string
 */
declare function formatXml({ tag, params, content }: XMLElement): string;
/**
 * Creates a regular expression to match XML tags with a specific name
 * @param tagName - The name of the XML tag to match
 * @returns RegExp that matches the specified XML tag and captures its attributes and content
 */
declare function createTagRegex(tagName: string): RegExp;
declare function createTagParser<T = string>(tagName: string, contentParser?: (content: any) => T): (content: string) => {
    tag: string;
    params: Record<string, string>;
    content: T extends string ? string : T;
}[];
type TextNode = {
    type: "text";
    content: string;
    parent?: Node;
    children?: never;
};
type ElementNode<Attributes extends Record<string, string> = Record<string, any>> = {
    type: "element";
    name: string;
    attributes: Attributes;
    content: string;
    parent?: Node;
    children?: Node[];
    closed?: true;
};
type Node = TextNode | ElementNode;
type NodeVisitor = (node: Node, parse: () => Node[]) => Node;
declare function parseAttributes(text: string): Record<string, string>;
declare function parse(text: string, visitor: NodeVisitor, depth?: number, parent?: Node | undefined): Node[];
declare function isElement(node: Node): node is ElementNode;
declare function isText(node: Node): node is TextNode;
type StartTag = {
    type: "start";
    name: string;
    attributes: Record<string, string>;
};
type EndTag = {
    type: "end";
    name: string;
};
type TextContent = {
    type: "text";
    content: string;
};
type SelfClosingTag = {
    type: "self-closing";
    name: string;
    attributes: Record<string, string>;
};
type XMLToken = StartTag | EndTag | TextContent | SelfClosingTag;
declare function xmlStreamParser(parseTags: Set<string>): Generator<XMLToken | void, void, string>;

declare class Logger {
    private config;
    private logWriter?;
    constructor(config: LoggerConfig);
    error(context: string, message: string, data?: any): void;
    warn(context: string, message: string, data?: any): void;
    info(context: string, message: string, data?: any): void;
    debug(context: string, message: string, data?: any): void;
    trace(context: string, message: string, data?: any): void;
    private log;
    private formatLogEntry;
    private colorize;
    private initLogFile;
    private writeToFile;
}

/**
 * Formats an input reference into XML format
 * @param input - The input reference to format
 * @returns XML string representation of the input
 */
declare function formatInput(input: InputRef): string;
/**
 * Formats an output reference into XML format
 * @param output - The output reference to format
 * @returns XML string representation of the output
 */
declare function formatOutput(output: OutputRef): string;
/**
 * Formats an output interface definition into XML format
 * @param output - The output interface to format
 * @returns XML string representation of the output interface
 */
declare function formatOutputInterface(output: Output): string;
declare function formatAction(action: Action<any, any, any>): string;
declare function formatContext({ type, key, description, instructions, content, }: {
    type: string;
    key: string;
    description?: string | string[];
    instructions?: string | string[];
    content: XMLElement["content"];
}): string;
type Msg = {
    role: "user";
    user: string;
    content: string;
} | {
    role: "assistant";
    content: string;
};
declare function formatMsg(msg: Msg): string;
declare function formatContextLog(i: Log): string | string[];
declare function formatContexts(mainContextId: string, contexts: ContextState[], workingMemory: WorkingMemory): string;

type Formatter<Variables extends Record<string, any> = Record<string, any>, Data = any> = (data: Data) => Record<keyof Variables, any>;
type InferFormatter<TPrompt extends AnyPrompt> = TPrompt extends Prompt<infer Data, infer Variables> ? Formatter<Variables, Data> : never;
type PromptVisitor<Output = any, Attributes extends Record<string, any> = Record<string, any>> = (output: Output, node: ElementNode<Attributes>, parse: () => Node[]) => void;
type GetVisitors<Output = any, T extends Record<string, Record<string, any>> = Record<string, Record<string, any>>> = {
    [K in keyof T]?: PromptVisitor<Output, T[K]>;
} & {
    [key: string]: PromptVisitor<Output, any>;
};
type Prompt<Data = any, Variables extends Record<string, any> = Record<string, any>> = <TData extends Data>(data: TData, formatter?: Formatter<Variables, TData>) => string;
type AnyPrompt = Prompt<any, any>;
type InferPromptVariables<TPrompt extends AnyPrompt> = TPrompt extends Prompt<any, infer Vars> ? Vars : never;
type InferPromptData<TPrompt extends AnyPrompt> = TPrompt extends Prompt<infer Data> ? Data : never;
type GeneratePromptConfig<TPrompt extends AnyPrompt | string = any, Variables extends Record<string, any> = any, Data = Record<string, any>, TFormatter extends Formatter<Variables, Data> = Formatter<Variables, Data>> = {
    template: TPrompt;
    variables: Variables;
    data: Data;
    formatter?: TFormatter;
};
type InferGeneratePromptConfig<TPrompt extends AnyPrompt | string> = (TPrompt extends Prompt<infer Data, infer Variables> ? GeneratePromptConfig<TPrompt, Variables, Data> : never) | (TPrompt extends string ? GeneratePromptConfig<TPrompt, TemplateVariables<TPrompt>> : never);
type InferPromptComponents<TPrompt extends AnyPrompt | string> = TPrompt extends Prompt<any, infer Components> ? Components : never;
declare function getZodJsonSchema(schema: ZodType<any>): zod_to_json_schema.JsonSchema7Type;
declare function createPrompt<Template extends string = string, Variables extends TemplateVariables<Template> = TemplateVariables<Template>, Data extends Record<string, any> = Record<string, any>>(prompt: Template, formatter?: Formatter<Variables, Data>): Prompt<Data, Variables>;
type Parser<Output> = (content: string) => Output;
declare function createParser<Output = any, Components extends Record<string, Record<string, any>> = Record<string, Record<string, any>>, Visitors extends GetVisitors<Output, Components> = GetVisitors<Output, Components>>(getOutput: () => Output, visitors: Visitors): Parser<Output>;

/**
 * Creates a context configuration
 * @template Memory - Type of working memory
 * @template Args - Zod schema type for context arguments
 * @template Ctx - Type of context data
 * @template Exports - Type of exported data
 * @param ctx - Context configuration object
 * @returns Typed context configuration
 */
declare function context<Memory = any, Args extends z.ZodTypeAny = z.ZodTypeAny, Ctx = any>(ctx: Context<Memory, Args, Ctx>): Context<Memory, Args, Ctx>;
/**
 * Retrieves and sorts working memory logs
 * @param memory - Working memory object
 * @param includeThoughts - Whether to include thought logs (default: true)
 * @returns Sorted array of memory logs
 */
declare function getWorkingMemoryLogs(memory: Partial<WorkingMemory>, includeThoughts?: boolean): Log[];
declare function renderWorkingMemory({ memory, processed, }: {
    memory: Partial<WorkingMemory>;
    processed: boolean;
}): string[];
/**
 * Creates a default working memory object
 * @returns Empty working memory with initialized arrays
 */
declare function createWorkingMemory(): WorkingMemory;
/**
 * Default working memory config
 * Provides a memory container with standard working memory structure
 */
declare const defaultWorkingMemory: Memory<WorkingMemory>;
/**
 * Default context configuration
 * Provides a basic context with string schema and test property
 */
declare const defaultContext: Context<any, z.ZodString, any>;
declare function getContextId<TContext extends AnyContext>(context: TContext, args: z.infer<TContext["schema"]>): string;
declare function getContextState<TContext extends AnyContext>(agent: AnyAgent, context: TContext, args: z.infer<TContext["schema"]>): Promise<ContextState<TContext>>;
declare function getContextWorkingMemory(agent: AnyAgent, contextId: string): Promise<WorkingMemory>;
declare function saveContextWorkingMemory(agent: AnyAgent, contextId: string, workingMemory: WorkingMemory): Promise<void>;

declare function prepareActionCall({ call, actions, logger, }: {
    call: ActionCall;
    actions: AnyAction[];
    logger: Logger;
}): Promise<{
    action: AnyAction;
    data: any;
}>;
declare function handleActionCall({ state, workingMemory, action, logger, call, taskRunner, agent, agentState, abortSignal, }: {
    state: ContextState<AnyContext>;
    workingMemory: WorkingMemory;
    call: ActionCall;
    action: AnyAction;
    logger: Logger;
    taskRunner: TaskRunner;
    agent: AnyAgent;
    agentState?: ContextState;
    abortSignal?: AbortSignal;
}): Promise<ActionResult>;
declare function handleOutput({ outputRef, outputs, logger, state, workingMemory, agent, }: {
    outputs: Output[];
    outputRef: OutputRef;
    logger: Logger;
    workingMemory: WorkingMemory;
    state: ContextState;
    agent: AnyAgent;
}): Promise<OutputRef | OutputRef[]>;

/**
 * A helper function to perform GraphQL queries.
 * - `endpoint`: the GraphQL endpoint URL.
 * - `query`: the GraphQL query string.
 * - `variables`: an optional variables object for the query.
 */
declare function fetchGraphQL<DataType = unknown>(endpoint: string, query: string, variables?: Record<string, unknown>): Promise<DataType | Error>;

export { Action, ActionCall, ActionResult, Agent, AgentContext, AnyAction, AnyAgent, AnyContext, type AnyPrompt, Config, Context, ContextState, type ElementNode, ExpertConfig, Extension, type Formatter, type GeneratePromptConfig, type GetVisitors, type InferFormatter, type InferGeneratePromptConfig, type InferPromptComponents, type InferPromptData, type InferPromptVariables, InputConfig, InputRef, Log, Logger, LoggerConfig, Memory, type Msg, type Node, type NodeVisitor, Output, OutputConfig, OutputRef, OutputResponse, OutputSchema, type Parser, type Prompt, type PromptVisitor, TaskRunner, TemplateVariables, type TextNode, WorkingMemory, XMLElement, action, context, createDreams, createParser, createPrompt, createTagParser, createTagRegex, createWorkingMemory, defaultContext, defaultWorkingMemory, expert, extension, fetchGraphQL, formatAction, formatContext, formatContextLog, formatContexts, formatInput, formatMsg, formatOutput, formatOutputInterface, formatValue, formatXml, getContextId, getContextState, getContextWorkingMemory, getWorkingMemoryLogs, getZodJsonSchema, handleActionCall, handleOutput, input, isElement, isText, memory, output, parse, parseAttributes, prepareActionCall, render, renderWorkingMemory, saveContextWorkingMemory, splitTextIntoChunks, trimWorkingMemory, validateEnv, xmlStreamParser };
