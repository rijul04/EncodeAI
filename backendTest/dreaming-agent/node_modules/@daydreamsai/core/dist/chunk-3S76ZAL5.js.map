{"version":3,"sources":["../src/types.ts","../src/logger.ts","../src/serviceProvider.ts","../src/xml.ts","../src/utils.ts","../src/formatters.ts","../src/context.ts"],"sourcesContent":["import { type LanguageModelV1 } from \"ai\";\nimport { z } from \"zod\";\nimport type { Container } from \"./container\";\nimport type { ServiceProvider } from \"./serviceProvider\";\nimport type { BaseMemory } from \"./memory\";\nimport type { TaskRunner } from \"./task\";\n\n/**\n * Represents a memory configuration for storing data\n * @template Data - Type of data stored in memory\n */\nexport type Memory<Data = any> = {\n  /** Unique identifier for this memory */\n  key: string;\n  /** Function to initialize memory data */\n  create: () => Promise<Data> | Data;\n};\n\n/**\n * Extracts the data type from a Memory type\n * @template TMemory - Memory type to extract data from\n */\nexport type InferMemoryData<TMemory extends Memory<any>> =\n  TMemory extends Memory<infer Data> ? Data : never;\n\n/**\n * Represents an execution chain with experts and metadata\n */\nexport type Chain = {\n  /** Unique identifier for the chain */\n  id: string;\n  /** Current thinking/reasoning state */\n  thinking: string;\n  /** Goal or purpose of this chain */\n  purpose: string;\n  /** List of experts involved in the chain */\n  experts: { name: string; data: string }[];\n};\n\n/**\n * Interface for storing and retrieving memory data\n */\nexport interface MemoryStore {\n  /**\n   * Retrieves data from memory\n   * @template T - Type of data to retrieve\n   * @param key - Key to lookup\n   * @returns Promise resolving to data or null if not found\n   */\n  get<T>(key: string): Promise<T | null>;\n\n  /**\n   * Stores data in memory\n   * @template T - Type of data to store\n   * @param key - Key to store under\n   * @param value - Data to store\n   */\n  set<T>(key: string, value: T): Promise<void>;\n\n  /**\n   * Removes data from memory\n   * @param key - Key to remove\n   */\n  delete(key: string): Promise<void>;\n\n  /**\n   * Removes all data from memory\n   */\n  clear(): Promise<void>;\n}\n\n/**\n * Interface for storing and retrieving vector data\n */\nexport interface VectorStore {\n  /** Optional connection string for the vector store */\n  connection?: string;\n\n  /**\n   * Adds or updates data in the vector store\n   * @param contextId - Unique identifier for the context\n   * @param data - Data to add or update\n   */\n  upsert(contextId: string, data: any): Promise<void>;\n\n  /**\n   * Searches the vector store for similar data\n   * @param contextId - Context to search within\n   * @param query - Query text to search for\n   * @returns Array of matching documents\n   */\n  query(contextId: string, query: string): Promise<any[]>;\n\n  /**\n   * Creates a new index in the vector store\n   * @param indexName - Name of the index to create\n   */\n  createIndex(indexName: string): Promise<void>;\n\n  /**\n   * Deletes an existing index from the vector store\n   * @param indexName - Name of the index to delete\n   */\n  deleteIndex(indexName: string): Promise<void>;\n}\n\n/**\n * Represents the working memory state during execution\n */\nexport interface WorkingMemory {\n  /** List of input references */\n  inputs: InputRef[];\n  /** List of output references */\n  outputs: OutputRef[];\n  /** List of thought records */\n  thoughts: Thought[];\n  /** List of action calls */\n  calls: ActionCall[];\n  /** List of action results */\n  results: ActionResult[];\n  // chains: Chain[];\n  episodicMemory?: EpisodicMemory;\n  /** Current image URL for multimodal context */\n  currentImage?: URL;\n}\n\nexport type InferSchema<T> = T extends {\n  schema?: infer S extends z.AnyZodObject;\n}\n  ? z.infer<S>\n  : unknown;\n\nexport type InferAgentContext<TAgent extends AnyAgent> =\n  TAgent extends Agent<infer Content> ? Content : never;\n\nexport type InferAgentMemory<TAgent extends AnyAgent> = InferContextMemory<\n  InferAgentContext<TAgent>\n>;\n\n/**\n * Represents an evaluator that can validate action/output results\n * @template Data - Type of data being evaluated\n * @template Context - Context type for the evaluation\n */\nexport type Evaluator<\n  Data = any,\n  Context extends AgentContext<any> = AgentContext<any>,\n  TAgent extends AnyAgent = AnyAgent,\n> = {\n  name: string;\n  description?: string;\n  /** Schema for the evaluation result */\n  schema?: z.ZodType<any>;\n  /** Custom prompt template for LLM-based evaluation */\n  prompt?: string;\n  /** Custom handler for evaluation logic */\n  handler?: (\n    data: Data,\n    ctx: Context,\n    agent: TAgent\n  ) => Promise<boolean> | boolean;\n  /** Optional callback when evaluation fails */\n  onFailure?: (ctx: Context, agent: TAgent) => Promise<void> | void;\n};\n\nexport type ActionContext<\n  TContext extends AnyContext = AnyContext,\n  AContext extends AnyContext = AnyContext,\n  ActionMemory extends Memory<any> = Memory<any>,\n> = AgentContext<TContext> & {\n  actionMemory: InferMemoryData<ActionMemory>;\n  agentMemory: InferContextMemory<AContext> | undefined;\n  abortSignal?: AbortSignal;\n};\n\n/**\n * Represents an action that can be executed with typed parameters\n * @template Schema - Zod schema defining parameter types\n * @template Result - Return type of the action\n * @template Context - Context type for the action execution\n */\nexport type Action<\n  Schema extends z.AnyZodObject = z.AnyZodObject,\n  Result = any,\n  TContext extends AnyContext = AnyContext,\n  TAgent extends AnyAgent = AnyAgent,\n  TMemory extends Memory<any> = Memory<any>,\n> = {\n  name: string;\n  description?: string;\n  instructions?: string;\n  schema: Schema;\n  memory?: TMemory;\n  install?: (agent: TAgent) => Promise<void> | void;\n  enabled?: (\n    ctx: ActionContext<TContext, InferAgentContext<TAgent>, TMemory>\n  ) => boolean;\n  examples?: z.infer<Schema>[];\n  handler: (\n    call: ActionCall<z.infer<Schema>>,\n    ctx: ActionContext<TContext, InferAgentContext<TAgent>, TMemory>,\n    agent: TAgent\n  ) => Promise<Result> | Result;\n  format?: (result: ActionResult<Result>) => string | string[];\n  /** Optional evaluator for this specific action */\n  evaluator?: Evaluator<Result, AgentContext<TContext>, TAgent>;\n\n  context?: TContext;\n};\n\nexport type OutputSchema = z.AnyZodObject | z.ZodString;\n\nexport type OutputRefResponse = Omit<\n  OutputRef,\n  \"id\" | \"ref\" | \"type\" | \"processed\"\n>;\n\nexport type OutputResponse =\n  | OutputRefResponse\n  | OutputRefResponse[]\n  | undefined\n  | void;\n\nexport type Output<\n  Schema extends OutputSchema = OutputSchema,\n  Context extends AgentContext<any> = AgentContext<any>,\n  Response extends OutputResponse = OutputResponse,\n  TAgent extends AnyAgent = AnyAgent,\n> = {\n  type: string;\n  description?: string;\n  instructions?: string;\n  schema: Schema;\n  install?: (agent: TAgent) => Promise<void>;\n  enabled?: (ctx: AgentContext<any>) => boolean;\n  handler: (\n    params: z.infer<Schema>,\n    ctx: Context,\n    agent: TAgent\n  ) => Promise<Response> | Response;\n  format?: (res: Response) => string | string[];\n  examples?: z.infer<Schema>[];\n  /** Optional evaluator for this specific output */\n  evaluator?: Evaluator<Response, Context, TAgent>;\n  required?: boolean;\n};\n\nexport type AnyAction = Action<any, any, any, any, any>;\n\n/**\n * Represents an input handler with validation and subscription capability\n * @template Schema - Zod schema for input parameters\n * @template Context - Context type for input handling\n */\nexport type Input<\n  Schema extends z.AnyZodObject = z.AnyZodObject,\n  TAgent extends AnyAgent = AnyAgent,\n> = {\n  type: string;\n  description?: string;\n  schema: Schema;\n  format?: (params: z.infer<Schema>) => string | string[];\n  install?: (agent: TAgent) => Promise<void>;\n  handler?: <\n    TContext extends AgentContext<AnyContext> = AgentContext<AnyContext>,\n  >(\n    params: z.infer<Schema>,\n    ctx: TContext,\n    agent: TAgent\n  ) => Promise<boolean> | boolean;\n  subscribe?: (\n    send: <TContext extends AnyContext>(\n      contextHandler: TContext,\n      args: z.infer<TContext[\"schema\"]>,\n      data: z.infer<Schema>\n    ) => void,\n    agent: TAgent\n  ) => (() => void) | void | Promise<void | (() => void)>;\n};\n\n/** Reference to an input event in the system */\nexport type InputRef<Data = any> = {\n  id: string;\n  ref: \"input\";\n  type: string;\n  data: Data;\n  params?: Record<string, string>;\n  timestamp: number;\n  processed: boolean;\n  formatted?: string | string[];\n};\n\n/** Reference to an output event in the system */\nexport type OutputRef<Data = any> = {\n  id: string;\n  ref: \"output\";\n  type: string;\n  data: Data;\n  params?: Record<string, string>;\n  timestamp: number;\n  processed: boolean;\n  formatted?: string | string[];\n};\n\n/** Represents a call to an action */\nexport type ActionCall<Data = any> = {\n  ref: \"action_call\";\n  id: string;\n  name: string;\n  content: string;\n  data: Data;\n  timestamp: number;\n  processed: boolean;\n};\n\n/** Represents the result of an action execution */\nexport type ActionResult<Data = any> = {\n  ref: \"action_result\";\n  id: string;\n  callId: string;\n  name: string;\n  data: Data;\n  timestamp: number;\n  processed: boolean;\n  formatted?: string | string[];\n};\n\n/** Represents a thought or reasoning step */\nexport type Thought = {\n  ref: \"thought\";\n  id: string;\n  content: string;\n  timestamp: number;\n  processed: boolean;\n};\n\nexport type Log = InputRef | OutputRef | Thought | ActionCall | ActionResult;\n\n/** Properties required for Chain-of-Thought execution */\nexport type COTProps = {\n  model: LanguageModelV1;\n  plan: string;\n  inputs: InputRef[];\n  actions: Action[];\n  outputs: Output[];\n  logs: Log[];\n};\n\n/** Response structure from Chain-of-Thought execution */\nexport type COTResponse = {\n  plan: string[];\n  actions: ActionCall[];\n  outputs: OutputRef[];\n  thinking: Thought[];\n};\n\n/** Represents an XML element structure */\nexport type XMLElement = {\n  tag: string;\n  params?: Record<string, string>;\n  content: string | (XMLElement | string)[];\n};\n\n/** Utility type to preserve type information */\nexport type Pretty<type> = { [key in keyof type]: type[key] } & unknown;\n\n/**\n * Extracts variable names from a template string\n * @template T - Template string type\n */\nexport type ExtractTemplateVariables<T extends string> =\n  T extends `${infer Start}{{${infer Var}}}${infer Rest}`\n    ? Var | ExtractTemplateVariables<Rest>\n    : never;\n\n/**\n * Creates a type mapping template variables to string values\n * @template T - Template string type\n */\nexport type TemplateVariables<T extends string> = Pretty<{\n  [K in ExtractTemplateVariables<T>]: string | string[] | object | any;\n}>;\n\n/** Represents an expert system with instructions and actions */\nexport type Expert = {\n  type: string;\n  description: string;\n  instructions: string;\n  model?: LanguageModelV1;\n  actions?: AnyAction[];\n};\n\nexport interface AgentContext<TContext extends AnyContext = AnyContext> {\n  id: string;\n  context: TContext;\n  args: z.infer<TContext[\"schema\"]>;\n  options: InferContextOptions<TContext>;\n  memory: InferContextMemory<TContext>;\n  workingMemory: WorkingMemory;\n}\n\nexport type AnyAgent = Agent<any>;\n\nexport interface Handlers {\n  onLogStream: (log: Log, done: boolean) => void;\n  onThinking: (thought: Thought) => void;\n}\n\n/**\n * Represents an agent with various configurations and methods for handling contexts, inputs, outputs, and more.\n * @template Memory - The type of memory used by the agent.\n * @template TContext - The type of context used by the agent.\n */\nexport interface Agent<TContext extends AnyContext = AnyContext> {\n  /**\n   * The memory store and vector store used by the agent.\n   */\n  memory: BaseMemory;\n\n  /**\n   * The current context of the agent.\n   */\n  context?: TContext;\n\n  /**\n   * Debugger function for the agent.\n   */\n  debugger: Debugger;\n\n  /**\n   * The container used by the agent.\n   */\n  container: Container;\n\n  /**\n   * The task runner used by the agent.\n   */\n  taskRunner: TaskRunner;\n\n  /**\n   * The primary language model used by the agent.\n   */\n  model: LanguageModelV1;\n\n  /**\n   * The reasoning model used by the agent, if any.\n   */\n  reasoningModel?: LanguageModelV1;\n\n  /**\n   * The vector model used by the agent, if any.\n   */\n  vectorModel?: LanguageModelV1;\n\n  /**\n   * A record of input configurations for the agent.\n   */\n  inputs: Record<string, InputConfig<any>>;\n\n  /**\n   * A record of output configurations for the agent.\n   */\n  outputs: Record<\n    string,\n    Omit<Output<any, AgentContext<TContext>, any, any>, \"type\">\n  >;\n\n  /**\n   * A record of event schemas for the agent.\n   */\n  events: Record<string, z.AnyZodObject>;\n\n  /**\n   * A record of expert configurations for the agent.\n   */\n  experts: Record<string, ExpertConfig>;\n\n  /**\n   * An array of actions available to the agent.\n   */\n  actions: Action<any, any, AnyContext, this, Memory<any>>[];\n\n  /**\n   * Whether to export training data for episodes\n   */\n  exportTrainingData?: boolean;\n\n  /**\n   * Path to save training data\n   */\n  trainingDataPath?: string;\n\n  /**\n   * Exports all episodes as training data\n   * @param filePath Optional path to save the training data\n   */\n  exportAllTrainingData?: (filePath?: string) => Promise<void>;\n\n  /**\n   * Emits an event with the provided arguments.\n   * @param args - Arguments to pass to the event handler.\n   */\n  emit: (...args: any[]) => void;\n\n  /**\n   * Runs the agent with the provided options.\n   * @param opts - Options for running the agent.\n   * @returns A promise that resolves to an array of logs.\n   */\n  run: <TContext extends AnyContext>(opts: {\n    context: TContext;\n    args: z.infer<TContext[\"schema\"]>;\n    model?: LanguageModelV1;\n    outputs?: Record<\n      string,\n      Omit<Output<any, AgentContext<TContext>, any, any>, \"type\">\n    >;\n    handlers?: Partial<Handlers>;\n    abortSignal?: AbortSignal;\n  }) => Promise<Log[]>;\n\n  /**\n   * Sends an input to the agent with the provided options.\n   * @param opts - Options for sending input to the agent.\n   * @returns A promise that resolves to an array of logs.\n   */\n  send: <SContext extends AnyContext>(opts: {\n    context: SContext;\n    args: z.infer<NonNullable<SContext[\"schema\"]>>;\n    input: { type: string; data: any };\n    model?: LanguageModelV1;\n    outputs?: Record<\n      string,\n      Omit<Output<any, AgentContext<SContext>, any, any>, \"type\">\n    >;\n    handlers?: Partial<Handlers>;\n    abortSignal?: AbortSignal;\n  }) => Promise<Log[]>;\n\n  /**\n   * Evaluates the provided context.\n   * @param ctx - The context to evaluate.\n   * @returns A promise that resolves when evaluation is complete.\n   */\n  evaluator: (ctx: AgentContext<TContext>) => Promise<void>;\n\n  /**\n   * Starts the agent with the provided arguments.\n   * @param args - Arguments to pass to the agent on start.\n   * @returns A promise that resolves to the agent instance.\n   */\n  start(args?: z.infer<TContext[\"schema\"]>): Promise<this>;\n\n  /**\n   * Stops the agent.\n   * @returns A promise that resolves when the agent is stopped.\n   */\n  stop(): Promise<void>;\n\n  /**\n   * Retrieves the contexts managed by the agent.\n   * @returns A promise that resolves to an array of context objects.\n   */\n  getContexts(): Promise<{ id: string; type: string; args?: any }[]>;\n\n  /**\n   * Retrieves the ID for a given context and arguments.\n   * @param params - Parameters for retrieving the context ID.\n   * @returns The context ID.\n   */\n  getContextId<TContext extends AnyContext>(params: {\n    context: TContext;\n    args: z.infer<NonNullable<TContext[\"schema\"]>>;\n  }): string;\n\n  /**\n   * Retrieves the state of a given context and arguments.\n   * @param params - Parameters for retrieving the context state.\n   * @returns A promise that resolves to the context state.\n   */\n  getContext<TContext extends AnyContext>(params: {\n    context: TContext;\n    args: z.infer<NonNullable<TContext[\"schema\"]>>;\n  }): Promise<ContextState<TContext>>;\n\n  // getContextById<TContext extends AnyContext>(params: {\n  //   context: TContext;\n  //   id: string;\n  // }): Promise<ContextState<TContext>>;\n\n  /**\n   * Retrieves the working memory for a given context ID.\n   * @param contextId - The ID of the context.\n   * @returns A promise that resolves to the working memory.\n   */\n  getWorkingMemory(contextId: string): Promise<WorkingMemory>;\n}\n\nexport type Debugger = (contextId: string, keys: string[], data: any) => void;\n\nexport type Config<TContext extends AnyContext = AnyContext> = Partial<\n  Agent<TContext>\n> & {\n  model: Agent[\"model\"];\n  reasoningModel?: Agent[\"reasoningModel\"];\n  logger?: LogLevel;\n  services?: ServiceProvider[];\n  extensions?: Extension<TContext>[];\n  /** Whether to export training data for episodes */\n  exportTrainingData?: boolean;\n  /** Path to save training data */\n  trainingDataPath?: string;\n};\n\n/** Configuration type for inputs without type field */\nexport type InputConfig<\n  Schema extends z.AnyZodObject = z.AnyZodObject,\n  TAgent extends AnyAgent = AnyAgent,\n> = Omit<Input<Schema, TAgent>, \"type\">;\n\n/** Configuration type for outputs without type field */\nexport type OutputConfig<\n  Schema extends OutputSchema = OutputSchema,\n  Context extends AgentContext<any> = AgentContext<any>,\n  Response extends OutputResponse = OutputResponse,\n  TAgent extends AnyAgent = AnyAgent,\n> = Omit<Output<Schema, Context, Response, TAgent>, \"type\">;\n\n/** Configuration type for experts without type field */\nexport type ExpertConfig = Omit<Expert, \"type\">;\n\n/** Function type for subscription cleanup */\nexport type Subscription = () => void;\n\n/** Enum defining available log levels */\nexport enum LogLevel {\n  ERROR = 0,\n  WARN = 1,\n  INFO = 2,\n  DEBUG = 3,\n  TRACE = 4,\n}\n\n/** Interface for custom log writers */\nexport interface LogWriter {\n  init(logPath: string): void;\n  write(data: string): void;\n}\n\n/** Configuration options for logging */\nexport interface LoggerConfig {\n  level: LogLevel;\n  enableTimestamp?: boolean;\n  enableColors?: boolean;\n  logToFile?: boolean;\n  logPath?: string;\n  logWriter?: LogWriter;\n}\n\n/** Structure of a log entry */\nexport interface LogEntry {\n  level: LogLevel;\n  timestamp: Date;\n  context: string;\n  message: string;\n  data?: any;\n}\n\n/** Results from a research operation */\nexport interface ResearchResult {\n  learnings: string[];\n  visitedUrls: string[];\n}\n\n/** Configuration for research operations */\nexport interface ResearchConfig {\n  query: string;\n  breadth: number;\n  depth: number;\n  learnings?: string[];\n  visitedUrls?: string[];\n}\n\nexport interface IChain {\n  /**\n   * A unique identifier for the chain (e.g., \"starknet\", \"ethereum\", \"solana\", etc.)\n   */\n  chainId: string;\n\n  /**\n   * Read (call) a contract or perform a query on this chain.\n   * The `call` parameter can be chain-specific data.\n   */\n  read(call: unknown): Promise<any>;\n\n  /**\n   * Write (execute a transaction) on this chain, typically requiring signatures, etc.\n   */\n  write(call: unknown): Promise<any>;\n}\n/** Type representing instructions that can be either a single string or array of strings */\nexport type Instruction = string | string[];\n\n/** Type representing any Context with generic type parameters */\nexport type AnyContext = Context<any, any, any>;\n\n/**\n * Extracts the Memory type from a Context type\n * @template TContext - The Context type to extract Memory from\n */\nexport type InferContextMemory<TContext extends AnyContext> =\n  TContext extends Context<infer Memory> ? Memory : never;\n\n/**\n * Extracts the Context type from a Context type\n * @template TContext - The Context type to extract Ctx from\n */\nexport type InferContextOptions<TContext extends AnyContext> =\n  TContext extends Context<any, any, infer Options> ? Options : never;\n\n/**\n * Configuration for a context that manages state and behavior\n * @template Memory - Type of memory for this context\n * @template Args - Zod schema type for context arguments\n * @template Ctx - Type of context data\n * @template Exports - Type of exported data\n */\n\nexport interface Context<\n  Memory = any,\n  Args extends z.ZodTypeAny = any,\n  Ctx = any,\n> {\n  /** Unique type identifier for this context */\n  type: string;\n  /** Zod schema for validating context arguments */\n  schema: Args;\n  /** Function to generate a unique key from context arguments */\n  key?: (args: z.infer<Args>) => string;\n\n  /** Optional description of this context */\n  description?:\n    | string\n    | string[]\n    | ((state: ContextState<this>) => string | string[]);\n\n  /** Setup function to initialize context data */\n  setup?: (args: z.infer<Args>, agent: AnyAgent) => Promise<Ctx> | Ctx;\n\n  /** Optional instructions for this context */\n  instructions?: Instruction | ((state: ContextState<this>) => Instruction);\n\n  /** Optional function to create new memory for this context */\n  create?: (state: Omit<ContextState<this>, \"memory\">) => Memory;\n\n  /** Optional function to load existing memory */\n  load?: (state: Omit<ContextState<this>, \"memory\">) => Promise<Memory>;\n  /** Optional function to save memory state */\n  save?: (state: ContextState<this>) => Promise<void>;\n\n  /** Optional function to render memory state */\n  render?: (state: ContextState<this>) => string | string[];\n\n  model?: LanguageModelV1;\n\n  onStep?: (ctx: AgentContext<this>) => Promise<void>;\n\n  maxSteps?: number;\n}\n\nexport type ContextState<TContext extends AnyContext = AnyContext> = {\n  id: string;\n  key: string;\n  context: TContext;\n  args: z.infer<TContext[\"schema\"]>;\n  options: InferContextOptions<TContext>;\n  memory: InferContextMemory<TContext>;\n};\n\n/** Enum defining roles for different types of handlers\n * @deprecated\n */\nexport enum HandlerRole {\n  /** Handler for processing inputs */\n  INPUT = \"input\",\n  /** Handler for processing outputs */\n  OUTPUT = \"output\",\n  /** Handler for executing actions */\n  ACTION = \"action\",\n}\n\nexport type Extension<\n  TContext extends AnyContext = AnyContext,\n  Contexts extends Record<string, AnyContext> = Record<string, AnyContext>,\n> = Pick<\n  Config<TContext>,\n  \"inputs\" | \"outputs\" | \"actions\" | \"services\" | \"events\"\n> & {\n  name: string;\n  install?: (agent: AnyAgent) => Promise<void> | void;\n  contexts?: Contexts;\n};\n\nexport interface Episode {\n  id: string;\n  timestamp: number;\n  observation: string; // Context and setup\n  result: string; // Outcomes of actions\n  thoughts: string;\n  metadata?: {\n    success?: boolean;\n    tags?: string[];\n    [key: string]: any;\n  };\n}\n\nexport interface EpisodicMemory {\n  episodes: Episode[];\n  index?: number; // For vector store indexing\n}\n","import { LogLevel } from \"./types\";\n\nimport type { LogEntry, LoggerConfig, LogWriter } from \"./types\";\n\nexport class Logger {\n  private config: Omit<Required<LoggerConfig>, \"logWriter\">;\n  private logWriter?: LogWriter;\n\n  constructor(config: LoggerConfig) {\n    this.config = {\n      level: config.level,\n      enableTimestamp: config.enableTimestamp ?? true,\n      enableColors: config.enableColors ?? true,\n      logToFile: config.logToFile ?? false,\n      logPath: config.logPath ?? \"./logs\",\n    };\n\n    if (this.config.logToFile && !config.logWriter) {\n      throw new Error(\"LogWriter must be provided when logToFile is enabled\");\n    }\n\n    if (config.logWriter) {\n      this.logWriter = config.logWriter;\n    }\n  }\n\n  error(context: string, message: string, data?: any) {\n    this.log(LogLevel.ERROR, context, message, data);\n\n    if (data) console.error(data);\n  }\n\n  warn(context: string, message: string, data?: any) {\n    this.log(LogLevel.WARN, context, message, data);\n  }\n\n  info(context: string, message: string, data?: any) {\n    this.log(LogLevel.INFO, context, message, data);\n  }\n\n  debug(context: string, message: string, data?: any) {\n    this.log(LogLevel.DEBUG, context, message, data);\n  }\n\n  trace(context: string, message: string, data?: any) {\n    this.log(LogLevel.TRACE, context, message, data);\n  }\n\n  private log(level: LogLevel, context: string, message: string, data?: any) {\n    if (level > this.config.level) return;\n\n    const entry: LogEntry = {\n      level,\n      timestamp: new Date(),\n      context,\n      message,\n      data,\n    };\n\n    const formatted = this.formatLogEntry(entry);\n\n    if (this.config.enableColors) {\n      console.log(this.colorize(formatted, level));\n    } else {\n      console.log(formatted);\n    }\n\n    if (this.config.logToFile) {\n      this.writeToFile(entry);\n    }\n  }\n\n  private formatLogEntry(entry: LogEntry): string {\n    const parts: string[] = [];\n\n    if (this.config.enableTimestamp) {\n      parts.push(`[${entry.timestamp.toISOString()}]`);\n    }\n\n    parts.push(`[${LogLevel[entry.level]}]`);\n    parts.push(`[${entry.context}]`);\n    parts.push(entry.message);\n\n    if (entry.data) {\n      parts.push(JSON.stringify(entry.data, null, 2));\n    }\n\n    return parts.join(\" \");\n  }\n\n  private colorize(message: string, level: LogLevel): string {\n    const colors = {\n      [LogLevel.ERROR]: \"\\x1b[31m\", // Red\n      [LogLevel.WARN]: \"\\x1b[33m\", // Yellow\n      [LogLevel.INFO]: \"\\x1b[36m\", // Cyan\n      [LogLevel.DEBUG]: \"\\x1b[32m\", // Green\n      [LogLevel.TRACE]: \"\\x1b[90m\", // Gray\n    };\n\n    const reset = \"\\x1b[0m\";\n    return `${colors[level]}${message}${reset}`;\n  }\n\n  private initLogFile() {\n    if (!this.logWriter) {\n      throw new Error(\"LogWriter not configured\");\n    }\n    this.logWriter.init(this.config.logPath);\n  }\n\n  private writeToFile(entry: LogEntry) {\n    if (!this.logWriter) {\n      throw new Error(\"LogWriter not configured\");\n    }\n\n    const logLine = this.formatLogEntry(entry) + \"\\n\";\n    this.logWriter.write(logLine);\n  }\n}\n","import type { Container } from \"./container\";\n\ntype ServiceProvider = {\n  register?: (container: Container) => void;\n  boot?: (container: Container) => void | Promise<void>;\n};\n\ntype ServiceState = {\n  providers: ServiceProvider[];\n  booted: Set<ServiceProvider>;\n  registered: Set<ServiceProvider>;\n};\n\ntype ServiceManager = {\n  register: (provider: ServiceProvider) => void;\n  bootAll: () => Promise<void>;\n  isBooted: (provider: ServiceProvider) => boolean;\n  isRegistered: (provider: ServiceProvider) => boolean;\n};\n\nconst service = (config: ServiceProvider): ServiceProvider => config;\n\nconst createServiceManager = (container: Container): ServiceManager => {\n  const state: ServiceState = {\n    providers: [],\n    booted: new Set(),\n    registered: new Set(),\n  };\n\n  const registerProvider = (\n    container: Container,\n    provider: ServiceProvider\n  ): void => {\n    if (state.registered.has(provider)) return;\n    state.registered.add(provider);\n    if (provider.register) provider.register(container);\n  };\n\n  const bootProvider = async (\n    container: Container,\n    provider: ServiceProvider\n  ): Promise<void> => {\n    if (state.booted.has(provider)) return;\n    state.booted.add(provider);\n    if (provider.boot) await provider.boot(container);\n  };\n\n  return {\n    register: (provider: ServiceProvider): void => {\n      if (!state.providers.includes(provider)) {\n        state.providers.push(provider);\n        registerProvider(container, provider);\n      }\n    },\n\n    bootAll: async (): Promise<void> => {\n      // First register all providers\n      for (const provider of state.providers) {\n        registerProvider(container, provider);\n      }\n\n      // Then boot them\n      for (const provider of state.providers) {\n        await bootProvider(container, provider);\n      }\n    },\n\n    isBooted: (provider: ServiceProvider): boolean =>\n      state.booted.has(provider),\n\n    isRegistered: (provider: ServiceProvider): boolean =>\n      state.registered.has(provider),\n  };\n};\n\nexport {\n  createServiceManager,\n  service,\n  type ServiceProvider,\n  type ServiceManager,\n};\n","import type { XMLElement } from \"./types\";\n\n/**\n * Formats an XML element into a string representation\n * @param tag - The XML tag name\n * @param params - Optional parameters/attributes for the XML tag\n * @param content - The content of the XML element (string or nested elements)\n * @returns Formatted XML string\n */\nexport function formatXml({ tag, params, content }: XMLElement): string {\n  const p = params\n    ? Object.entries(params)\n        .map(([k, v]) => ` ${k}=\"${v}\"`)\n        .join(\"\")\n    : \"\";\n  try {\n    return `<${tag}${p}>${typeof content === \"string\" ? content : Array.isArray(content) ? \"\\n\" + content.map((el) => (typeof el === \"string\" ? el : formatXml(el))).join(\"\\n\") + \"\\n\" : \"\"}</${tag}>`;\n  } catch (error) {\n    console.log(\"failed to format\", { tag, params, content });\n    throw error;\n  }\n}\n\n/**\n * Creates a regular expression to match XML tags with a specific name\n * @param tagName - The name of the XML tag to match\n * @returns RegExp that matches the specified XML tag and captures its attributes and content\n */\nexport function createTagRegex(tagName: string) {\n  return new RegExp(\n    `(<${tagName}(?:\\\\s+[^>]*)?>)([\\\\s\\\\S]*?)<\\/${tagName}>`,\n    \"gs\"\n  );\n}\n\nexport function createTagParser<T = string>(\n  tagName: string,\n  contentParser?: (content: any) => T\n) {\n  const regex = createTagRegex(tagName);\n\n  return (content: string) => {\n    const matches = Array.from(content.matchAll(regex));\n    try {\n      return matches.map((t) => ({\n        tag: tagName,\n        params: t[1] ? parseAttributes(t[1]) : {},\n        content: (contentParser\n          ? contentParser(t[2]?.trim())\n          : t[2]?.trim()) as T extends string ? string : T,\n      }));\n    } catch (error) {\n      throw error;\n    }\n  };\n}\n\n// new parser\nexport type TextNode = {\n  type: \"text\";\n  content: string;\n  parent?: Node;\n  children?: never;\n};\n\nexport type ElementNode<\n  Attributes extends Record<string, string> = Record<string, any>,\n> = {\n  type: \"element\";\n  name: string;\n  attributes: Attributes;\n  content: string;\n  parent?: Node;\n  children?: Node[];\n  closed?: true;\n};\n\nexport type Node = TextNode | ElementNode;\n\nexport type NodeVisitor = (node: Node, parse: () => Node[]) => Node;\n\nexport function parseAttributes(text: string): Record<string, string> {\n  const attrs: Record<string, string> = {};\n  if (text.length === 0) return attrs;\n  const matches = text.matchAll(/(\\w+)=\"([^\"]*)\"/g);\n  for (const match of matches) {\n    attrs[match[1]] = match[2];\n  }\n  return attrs;\n}\n\nexport function parse(\n  text: string,\n  visitor: NodeVisitor,\n  depth = 0,\n  parent: Node | undefined = undefined\n): Node[] {\n  const nodes: Node[] = [];\n\n  let workingText = text.trim();\n\n  while (workingText.length > 0) {\n    // Find first opening tag\n    const tagStart = workingText.indexOf(\"<\");\n    if (tagStart === -1) {\n      const textNode: TextNode = {\n        type: \"text\",\n        content: workingText.trim(),\n      };\n      nodes.push(visitor(textNode, () => []));\n      break;\n    }\n\n    const tagEnd = workingText.indexOf(\">\", tagStart);\n\n    if (tagStart > 0 || tagEnd === -1) {\n      const textNode: TextNode = {\n        type: \"text\",\n        content: workingText.slice(0, tagEnd === -1 ? -1 : tagStart).trim(),\n      };\n      nodes.push(visitor(textNode, () => []));\n    }\n\n    // Find end of opening tag\n    if (tagEnd === -1) break;\n\n    // Parse tag and attributes\n    let tagContent = workingText.slice(tagStart + 1, tagEnd);\n    let closed = false;\n    if (tagContent.at(-1) === \"/\") {\n      closed = true;\n      tagContent = tagContent.slice(0, -1);\n    }\n\n    const [name, ...attrParts] = tagContent.split(\" \");\n    const attributes = parseAttributes(attrParts.join(\" \").trim());\n\n    // Skip if it's a closing tag\n    if (closed) {\n      workingText = workingText.slice(tagEnd + 1).trim();\n      nodes.push(\n        visitor(\n          {\n            type: \"element\",\n            name,\n            attributes,\n            content: \"\",\n            closed,\n          },\n          () => []\n        )\n      );\n      continue;\n    }\n\n    // Find last matching close tag\n    const closeTag = `</${name}>`;\n    const closePos = workingText.indexOf(closeTag);\n    if (closePos === -1) break;\n\n    // Extract content between tags\n    const content = workingText.slice(tagEnd + 1, closePos).trim();\n\n    const node: ElementNode = {\n      type: \"element\",\n      name,\n      attributes,\n      content,\n    };\n\n    if (parent) node.parent = parent;\n\n    nodes.push(visitor(node, () => parse(content, visitor, depth + 1, node)));\n    // Continue with remaining text before this tag\n    workingText = workingText.slice(closePos + closeTag.length).trim();\n  }\n  return nodes;\n}\n\nexport function isElement(node: Node): node is ElementNode {\n  return node.type === \"element\";\n}\n\nexport function isText(node: Node): node is TextNode {\n  return node.type === \"text\";\n}\n\ntype StartTag = {\n  type: \"start\";\n  name: string;\n  attributes: Record<string, string>;\n};\n\ntype EndTag = {\n  type: \"end\";\n  name: string;\n};\n\ntype TextContent = {\n  type: \"text\";\n  content: string;\n};\n\ntype SelfClosingTag = {\n  type: \"self-closing\";\n  name: string;\n  attributes: Record<string, string>;\n};\n\ntype XMLToken = StartTag | EndTag | TextContent | SelfClosingTag;\n\nexport function* xmlStreamParser(\n  parseTags: Set<string>\n): Generator<XMLToken | void, void, string> {\n  let buffer = \"\";\n  let textContent = \"\";\n\n  while (true) {\n    const chunk = yield;\n    if (!chunk) continue;\n\n    buffer += chunk;\n\n    while (buffer.length > 0) {\n      const tagStart = buffer.indexOf(\"<\");\n\n      if (tagStart > 0) {\n        const text = buffer.slice(0, tagStart).trim();\n        textContent += text;\n        buffer = buffer.slice(tagStart);\n        break;\n      }\n\n      if (tagStart === -1) {\n        textContent += buffer;\n        buffer = \"\";\n        break;\n      }\n\n      const tagEnd = buffer.indexOf(\">\", tagStart);\n      if (tagEnd === -1) {\n        break;\n      }\n\n      let tagContent = buffer.slice(tagStart + 1, tagEnd);\n      const isClosingTag = tagContent.startsWith(\"/\");\n      const tagName = isClosingTag\n        ? tagContent.slice(1).trim().split(\" \")[0]\n        : tagContent.trim().split(\" \")[0];\n\n      if (parseTags.has(tagName)) {\n        // Emit accumulated text if any\n        if (textContent) {\n          yield { type: \"text\", content: textContent };\n          textContent = \"\";\n        }\n\n        if (isClosingTag) {\n          yield { type: \"end\", name: tagName };\n        } else {\n          const attributes = parseAttributes(tagContent.slice(tagName.length));\n          yield { type: \"start\", name: tagName, attributes };\n        }\n      } else {\n        // Not a tag we care about, treat as text\n        textContent += buffer.slice(0, tagEnd + 1);\n      }\n\n      buffer = buffer.slice(tagEnd + 1);\n    }\n\n    // Emit accumulated text if buffer is empty\n    if (textContent) {\n      yield { type: \"text\", content: textContent };\n      textContent = \"\";\n    }\n  }\n}\n","import { z } from \"zod\";\nimport type {\n  Action,\n  Agent,\n  AgentContext,\n  AnyAgent,\n  AnyContext,\n  ExpertConfig,\n  Extension,\n  InputConfig,\n  Memory,\n  OutputConfig,\n  OutputResponse,\n  OutputSchema,\n  TemplateVariables,\n  WorkingMemory,\n} from \"./types\";\nexport { v7 as randomUUIDv7 } from \"uuid\";\n\n/**\n * Renders a template string by replacing variables with provided values\n * @template Template - The template string type containing variables in {{var}} format\n * @param str - The template string to render\n * @param data - Object containing values for template variables\n * @returns The rendered string with variables replaced\n */\nexport function render<Template extends string>(\n  str: Template,\n  data: TemplateVariables<Template>\n) {\n  return str\n    .trim()\n    .replace(/\\{\\{(\\w+)\\}\\}/g, (match, key: string) =>\n      formatValue(data[key as keyof typeof data] ?? \"\")\n    );\n}\n\n/**\n * Formats a value for template rendering\n * @param value - The value to format\n * @returns Formatted string representation of the value\n */\nexport function formatValue(value: any): string {\n  if (Array.isArray(value)) return value.map((t) => formatValue(t)).join(\"\\n\");\n  if (typeof value !== \"string\")\n    return JSON.stringify(value, (_, value) => {\n      if (typeof value === \"bigint\") return value.toString();\n      return value;\n    });\n  return value.trim();\n}\n\n/**\n * Creates an input configuration\n * @template Schema - Zod schema type for input validation\n * @template Context - Context type for input handling\n * @param config - Input configuration object\n * @returns Typed input configuration\n */\nexport function input<\n  Schema extends z.AnyZodObject = z.AnyZodObject,\n  TAgent extends AnyAgent = AnyAgent,\n>(config: InputConfig<Schema, TAgent>) {\n  return config;\n}\n\n/**\n * Creates an action configuration\n * @template Schema - Zod schema type for action parameters\n * @template Result - Return type of the action\n * @template Context - Context type for action execution\n * @param action - Action configuration object\n * @returns Typed action configuration\n */\nexport function action<\n  Schema extends z.AnyZodObject = z.AnyZodObject,\n  Result = any,\n  TContext extends AnyContext = AnyContext,\n  TAgent extends AnyAgent = AnyAgent,\n  TMemory extends Memory<any> = Memory<any>,\n>(action: Action<Schema, Result, TContext, TAgent, TMemory>) {\n  return action;\n}\n\n/**\n * Creates an output configuration\n * @template Schema - Zod schema type for output validation\n * @template Context - Context type for output handling\n * @param config - Output configuration object\n * @returns Typed output configuration\n */\nexport function output<\n  Schema extends OutputSchema = OutputSchema,\n  Context extends AgentContext<any> = AgentContext<any>,\n  TResponse extends OutputResponse = OutputResponse,\n>(config: OutputConfig<Schema, Context, TResponse>) {\n  return config;\n}\n\n/**\n * Creates an expert configuration\n * @template Context - Context type for expert execution\n * @param config - Expert configuration object\n * @returns Typed expert configuration\n */\nexport function expert(config: ExpertConfig) {\n  return config;\n}\n\n/**\n * Options for text chunking\n */\ntype ChunkOptions = {\n  maxChunkSize: number;\n};\n\n/**\n * Splits text into chunks based on maximum chunk size\n * @param text - The text to split into chunks\n * @param options - Chunking options including maximum chunk size\n * @returns Array of text chunks\n */\nexport function splitTextIntoChunks(\n  text: string,\n  options: ChunkOptions\n): string[] {\n  const { maxChunkSize } = options;\n  const lines = text.split(\"\\n\");\n  const chunks: string[] = [];\n  let currentChunk = \"\";\n\n  for (const line of lines) {\n    // If adding this line would exceed maxChunkSize, start a new chunk\n    if (currentChunk.length + line.length + 1 > maxChunkSize) {\n      if (currentChunk) {\n        chunks.push(currentChunk.trim());\n      }\n      currentChunk = line;\n    } else {\n      // Add line to current chunk with a newline\n      currentChunk = currentChunk ? currentChunk + \"\\n\" + line : line;\n    }\n  }\n\n  // Don't forget to add the last chunk\n  if (currentChunk) {\n    chunks.push(currentChunk.trim());\n  }\n\n  return chunks;\n}\n\n/**\n * Creates a memory configuration\n * @template Data - Type of data stored in memory\n * @param memory - Memory configuration object\n * @returns Typed memory configuration\n */\nexport function memory<Data = any>(memory: Memory<Data>) {\n  return memory;\n}\n\nexport function extension<\n  Contexts extends Record<string, AnyContext> = Record<string, AnyContext>,\n>(config: Extension<AnyContext, Contexts>) {\n  return config;\n}\n\n/**\n * Validates environment variables against a Zod schema\n * @param schema The Zod schema to validate against\n * @param env The environment object to validate (defaults to process.env)\n * @returns The validated environment variables\n */\nexport function validateEnv<T extends z.ZodTypeAny>(\n  schema: T,\n  env = process.env\n): z.infer<T> {\n  try {\n    return schema.parse(env);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      console.error(\"Environment validation failed:\");\n      error.errors.forEach((err) => {\n        console.error(`- ${err.message}`);\n      });\n      process.exit(1);\n    }\n    throw error;\n  }\n}\n\ntype TrimWorkingMemoryOptions = {\n  thoughts: number;\n  inputs: number;\n  outputs: number;\n  actions: number;\n};\n\nconst defaultTrimOptions: TrimWorkingMemoryOptions = {\n  thoughts: 6,\n  inputs: 20,\n  outputs: 20,\n  actions: 20,\n};\n\nexport function trimWorkingMemory(\n  workingMemory: WorkingMemory,\n  options: TrimWorkingMemoryOptions = defaultTrimOptions\n) {\n  workingMemory.thoughts = workingMemory.thoughts.slice(-options.thoughts);\n  workingMemory.inputs = workingMemory.inputs.slice(-options.inputs);\n  workingMemory.outputs = workingMemory.outputs.slice(-options.outputs);\n  workingMemory.calls = workingMemory.calls.slice(-options.actions);\n  workingMemory.results = workingMemory.results.slice(-options.actions);\n}\n","import zodToJsonSchema from \"zod-to-json-schema\";\nimport type {\n  Action,\n  ContextState,\n  InputRef,\n  Log,\n  Output,\n  OutputRef,\n  WorkingMemory,\n  XMLElement,\n} from \"./types\";\nimport { formatXml } from \"./xml\";\nimport { formatValue } from \"./utils\";\nimport { renderWorkingMemory } from \"./context\";\n\n/**\n * Formats an input reference into XML format\n * @param input - The input reference to format\n * @returns XML string representation of the input\n */\nexport function formatInput(input: InputRef) {\n  return formatXml({\n    tag: \"input\",\n    params: { name: input.type, ...input.params },\n    content:\n      typeof input.data === \"string\" ? input.data : JSON.stringify(input.data),\n  });\n}\n\n/**\n * Formats an output reference into XML format\n * @param output - The output reference to format\n * @returns XML string representation of the output\n */\nexport function formatOutput(output: OutputRef) {\n  return formatXml({\n    tag: \"output\",\n    params: { name: output.type, ...output.params },\n    content:\n      typeof output.data === \"string\"\n        ? output.data\n        : JSON.stringify(output.data),\n  });\n}\n\n/**\n * Formats an output interface definition into XML format\n * @param output - The output interface to format\n * @returns XML string representation of the output interface\n */\nexport function formatOutputInterface(output: Output) {\n  const params: Record<string, string> = {\n    name: output.type,\n  };\n\n  if (output.required) {\n    params.required = \"true\";\n  }\n\n  return formatXml({\n    tag: \"output\",\n    params,\n    content: [\n      output.description\n        ? { tag: \"description\", content: output.description }\n        : null,\n      output.instructions\n        ? { tag: \"instructions\", content: output.instructions }\n        : null,\n      output.schema\n        ? {\n            tag: \"schema\",\n            content: JSON.stringify(zodToJsonSchema(output.schema, \"output\")),\n          }\n        : null,\n    ].filter((c) => !!c),\n  });\n}\n\nexport function formatAction(action: Action<any, any, any>) {\n  return formatXml({\n    tag: \"action\",\n    params: { name: action.name },\n    content: [\n      action.description\n        ? {\n            tag: \"description\",\n            content: action.description,\n          }\n        : null,\n      action.instructions\n        ? {\n            tag: \"instructions\",\n            content: action.instructions,\n          }\n        : null,\n      action.schema\n        ? {\n            tag: \"schema\",\n            content: JSON.stringify(zodToJsonSchema(action.schema, \"action\")),\n          }\n        : null,\n    ].filter((t) => !!t),\n  });\n}\n\nexport function formatContext({\n  type,\n  key,\n  description,\n  instructions,\n  content,\n}: {\n  type: string;\n  key: string;\n  description?: string | string[];\n  instructions?: string | string[];\n  content: XMLElement[\"content\"];\n}) {\n  return formatXml({\n    tag: \"context\",\n    params: { type, key },\n    content: [\n      description\n        ? formatXml({ tag: \"description\", content: description })\n        : \"\",\n      instructions\n        ? formatXml({\n            tag: \"instructions\",\n            content: instructions,\n          })\n        : \"\",\n      content,\n    ]\n      .filter((t) => !!t)\n      .flat(),\n  });\n}\n\nexport type Msg =\n  | {\n      role: \"user\";\n      user: string;\n      content: string;\n    }\n  | {\n      role: \"assistant\";\n      content: string;\n    };\n\nexport function formatMsg(msg: Msg) {\n  return formatXml({\n    tag: \"msg\",\n    params:\n      msg.role === \"user\"\n        ? {\n            role: \"user\",\n            user: msg.user,\n          }\n        : { role: \"assistant\" },\n    content: msg.content,\n  });\n}\n\nexport function formatContextLog(i: Log) {\n  switch (i.ref) {\n    case \"input\":\n      return (\n        i.formatted ??\n        formatXml({\n          tag: \"msg\",\n          params: {\n            ...i.params,\n            role: \"user\",\n          },\n          content: formatValue(i.data),\n        })\n      );\n    case \"output\":\n      return (\n        i.formatted ??\n        formatXml({\n          tag: \"output\",\n          params: {\n            type: i.type,\n            ...i.params,\n            // role: \"assistant\",\n          },\n          content: formatValue(i.data),\n        })\n      );\n    case \"thought\":\n      return formatXml({\n        tag: \"reasoning\",\n        // params: { role: \"assistant\" },\n        content: i.content,\n      });\n    case \"action_call\":\n      return formatXml({\n        tag: \"action_call\",\n        params: { id: i.id, name: i.name },\n        content: JSON.stringify(i.data),\n      });\n    case \"action_result\":\n      return formatXml({\n        tag: \"action_result\",\n        params: { name: i.name, callId: i.callId },\n        content: i.formatted ?? JSON.stringify(i.data),\n      });\n    default:\n      throw new Error(\"invalid context\");\n  }\n}\n\nexport function formatContexts(\n  mainContextId: string,\n  contexts: ContextState[],\n  workingMemory: WorkingMemory\n) {\n  return contexts\n    .map(({ id, context, key, args, memory, options }) =>\n      formatContext({\n        type: context.type,\n        key: key,\n        description:\n          typeof context.description === \"function\"\n            ? context.description({\n                key,\n                args,\n                options,\n                id,\n                context,\n                memory,\n              })\n            : context.description,\n        instructions:\n          typeof context.instructions === \"function\"\n            ? context.instructions({\n                key,\n                args,\n                options,\n                id,\n                context,\n                memory,\n              })\n            : context.instructions,\n        content: [\n          context.render\n            ? context.render({ id, context, key, args, memory, options })\n            : \"\",\n          mainContextId === id\n            ? renderWorkingMemory({\n                memory: workingMemory,\n                processed: true,\n              })\n            : \"\",\n        ]\n          .flat()\n          .filter((t) => !!t),\n      })\n    )\n    .flat()\n    .join(\"\\n\");\n}\n","import { z } from \"zod\";\nimport type {\n  AnyAgent,\n  AnyContext,\n  Context,\n  ContextState,\n  Log,\n  WorkingMemory,\n} from \"./types\";\nimport { formatContextLog } from \"./formatters\";\nimport { memory } from \"./utils\";\n\n/**\n * Creates a context configuration\n * @template Memory - Type of working memory\n * @template Args - Zod schema type for context arguments\n * @template Ctx - Type of context data\n * @template Exports - Type of exported data\n * @param ctx - Context configuration object\n * @returns Typed context configuration\n */\n\nexport function context<\n  Memory = any,\n  Args extends z.ZodTypeAny = z.ZodTypeAny,\n  Ctx = any,\n>(ctx: Context<Memory, Args, Ctx>): Context<Memory, Args, Ctx> {\n  return ctx;\n}\n\n/**\n * Retrieves and sorts working memory logs\n * @param memory - Working memory object\n * @param includeThoughts - Whether to include thought logs (default: true)\n * @returns Sorted array of memory logs\n */\nexport function getWorkingMemoryLogs(\n  memory: Partial<WorkingMemory>,\n  includeThoughts = true\n): Log[] {\n  return [\n    ...(memory.inputs ?? []),\n    ...(memory.outputs ?? []),\n    ...(memory.calls ?? []),\n    ...((includeThoughts ? memory.thoughts : undefined) ?? []),\n    ...(memory.results ?? []),\n  ].sort((a, b) => (a.timestamp > b.timestamp ? 1 : -1));\n}\n\nexport function renderWorkingMemory({\n  memory,\n  processed,\n}: {\n  memory: Partial<WorkingMemory>;\n  processed: boolean;\n}) {\n  return getWorkingMemoryLogs(memory, false)\n    .filter((i) => i.processed === processed)\n    .map((i) => formatContextLog(i))\n    .flat();\n}\n\n/**\n * Creates a default working memory object\n * @returns Empty working memory with initialized arrays\n */\nexport function createWorkingMemory(): WorkingMemory {\n  return {\n    inputs: [],\n    outputs: [],\n    thoughts: [],\n    calls: [],\n    results: [],\n  };\n}\n\n/**\n * Default working memory config\n * Provides a memory container with standard working memory structure\n */\nexport const defaultWorkingMemory = memory<WorkingMemory>({\n  key: \"working-memory\",\n  create: createWorkingMemory,\n});\n\n/**\n * Default context configuration\n * Provides a basic context with string schema and test property\n */\nexport const defaultContext = context({\n  type: \"default\",\n  schema: z.string(),\n  key: (key) => key,\n  create(state) {\n    return {\n      test: true,\n    };\n  },\n});\n\nexport function getContextId<TContext extends AnyContext>(\n  context: TContext,\n  args: z.infer<TContext[\"schema\"]>\n) {\n  const key = context.key ? context.key(args) : context.type;\n  return context.key ? [context.type, key].join(\":\") : context.type;\n}\n\nexport async function getContextState<TContext extends AnyContext>(\n  agent: AnyAgent,\n  context: TContext,\n  args: z.infer<TContext[\"schema\"]>\n): Promise<ContextState<TContext>> {\n  const key = context.key ? context.key(args) : context.type;\n  const id = context.key ? [context.type, key].join(\":\") : context.type;\n\n  const options = context.setup ? await context.setup(args, agent) : {};\n\n  const memory =\n    (await agent.memory.store.get(id)) ??\n    (context.create\n      ? context.create({ key, args, context, id: id, options })\n      : {});\n\n  return {\n    id,\n    key,\n    args,\n    options,\n    context,\n    memory,\n  };\n}\n\nexport async function getContextWorkingMemory(\n  agent: AnyAgent,\n  contextId: string\n) {\n  return (\n    (await agent.memory.store.get<WorkingMemory>(\n      [contextId, \"working-memory\"].join(\":\")\n    )) ?? (await defaultWorkingMemory.create())\n  );\n}\n\nexport async function saveContextWorkingMemory(\n  agent: AnyAgent,\n  contextId: string,\n  workingMemory: WorkingMemory\n) {\n  return await agent.memory.store.set(\n    [contextId, \"working-memory\"].join(\":\"),\n    workingMemory\n  );\n}\n"],"mappings":"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","names":["LogLevel","HandlerRole","Logger","config","context","message","data","level","entry","formatted","parts","LogLevel","logLine","service","config","createServiceManager","container","state","registerProvider","provider","bootProvider","formatXml","tag","params","content","p","k","v","el","error","createTagRegex","tagName","createTagParser","contentParser","regex","matches","t","parseAttributes","text","attrs","match","parse","visitor","depth","parent","nodes","workingText","tagStart","textNode","tagEnd","tagContent","closed","name","attrParts","attributes","closeTag","closePos","node","isElement","isText","xmlStreamParser","parseTags","buffer","textContent","chunk","isClosingTag","z","v7","render","str","data","match","key","formatValue","value","t","_","input","config","action","output","expert","splitTextIntoChunks","text","options","maxChunkSize","lines","chunks","currentChunk","line","memory","extension","validateEnv","schema","env","error","err","defaultTrimOptions","trimWorkingMemory","workingMemory","zodToJsonSchema","context","ctx","getWorkingMemoryLogs","memory","includeThoughts","a","b","renderWorkingMemory","processed","i","formatContextLog","createWorkingMemory","defaultWorkingMemory","defaultContext","key","state","getContextId","args","getContextState","agent","id","options","getContextWorkingMemory","contextId","saveContextWorkingMemory","workingMemory","formatInput","input","formatXml","formatOutput","output","formatOutputInterface","params","zodToJsonSchema","c","formatAction","action","t","formatContext","type","key","description","instructions","content","formatMsg","msg","formatContextLog","i","formatValue","formatContexts","mainContextId","contexts","workingMemory","id","context","args","memory","options","renderWorkingMemory"]}